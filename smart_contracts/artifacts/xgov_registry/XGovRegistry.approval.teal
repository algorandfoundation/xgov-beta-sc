#pragma version 10
#pragma typetrack false

// smart_contracts.xgov_registry.contract.XGovRegistry.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 4 8 19300
    bytecblock 0x7061757365645f7265676973747279 0x151f7c75 0x70 0x6f75747374616e64696e675f66756e6473 0x78 0x78676f765f6d616e61676572 0x78676f7673 0x70656e64696e675f70726f706f73616c73 0x00 0x7061 0x7061757365645f70726f706f73616c73 0x6f70656e5f70726f706f73616c5f666565 "ERR:" 0x78676f765f73756273637269626572 0x78676f765f7061796f72 0x6b79635f70726f7669646572 0x636f6d6d69747465655f6d616e61676572 0x78676f765f6461656d6f6e 0x78676f765f666565 0x70726f706f7365725f666565 0x72 "Wrong Proposal Status or finalized" 0x78676f765f636f756e63696c 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073 0x70726f706f73616c5f636f6d6d69746d656e745f627073 0x6d696e5f7265717565737465645f616d6f756e74 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d 0x6d61785f7265717565737465645f616d6f756e745f6c61726765 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d 0x64697363757373696f6e5f6475726174696f6e5f6c61726765 0x64697363757373696f6e5f6475726174696f6e5f786c61726765 0x766f74696e675f6475726174696f6e5f736d616c6c 0x766f74696e675f6475726174696f6e5f6d656469756d 0x766f74696e675f6475726174696f6e5f6c61726765 0x766f74696e675f6475726174696f6e5f786c61726765 0x71756f72756d5f736d616c6c 0x71756f72756d5f6d656469756d 0x71756f72756d5f6c61726765 0x77656967687465645f71756f72756d5f736d616c6c 0x77656967687465645f71756f72756d5f6d656469756d 0x77656967687465645f71756f72756d5f6c61726765 0x636f6d6d69747465655f6d656d62657273 0x636f6d6d69747465655f766f746573 0x726571756573745f6964 0x6d61785f636f6d6d69747465655f73697a65 "Missing Config" 0x0000000000000000 0x636f6d6d69747465655f6964 TMPL_entropy
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/xgov_registry/contract.py:55-56
    // # Preconditions
    // assert Txn.global_num_byte_slice == cfg.GLOBAL_BYTES, err.WRONG_GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 28 // 28
    ==
    assert // Wrong Global Bytes allocation
    // smart_contracts/xgov_registry/contract.py:57
    // assert Txn.global_num_uint == cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    pushint 36 // 36
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/xgov_registry/contract.py:58
    // assert Txn.local_num_byte_slice == cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/xgov_registry/contract.py:59
    // assert Txn.local_num_uint == cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/xgov_registry/contract.py:61-62
    // # Initialize global state variables
    // self.paused_registry = GlobalState(UInt64(), key=cfg.GS_KEY_PAUSED_REGISTRY)
    bytec_0 // 0x7061757365645f7265676973747279
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:63
    // self.paused_proposals = GlobalState(UInt64(), key=cfg.GS_KEY_PAUSED_PROPOSALS)
    bytec 10 // 0x7061757365645f70726f706f73616c73
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:65
    // self.xgov_manager = GlobalState(arc4.Address(), key=cfg.GS_KEY_XGOV_MANAGER)
    bytec 5 // 0x78676f765f6d616e61676572
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:67
    // arc4.Address(), key=cfg.GS_KEY_XGOV_SUBSCRIBER
    bytec 13 // 0x78676f765f73756273637269626572
    global ZeroAddress
    // smart_contracts/xgov_registry/contract.py:66-68
    // self.xgov_subscriber = GlobalState(
    //     arc4.Address(), key=cfg.GS_KEY_XGOV_SUBSCRIBER
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:69
    // self.xgov_payor = GlobalState(arc4.Address(), key=cfg.GS_KEY_XGOV_PAYOR)
    bytec 14 // 0x78676f765f7061796f72
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:70
    // self.xgov_council = GlobalState(arc4.Address(), key=cfg.GS_KEY_XGOV_COUNCIL)
    bytec 22 // 0x78676f765f636f756e63696c
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:72
    // self.kyc_provider = GlobalState(arc4.Address(), key=cfg.GS_KEY_KYC_PROVIDER)
    bytec 15 // 0x6b79635f70726f7669646572
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:74
    // arc4.Address(), key=cfg.GS_KEY_COMMITTEE_MANAGER
    bytec 16 // 0x636f6d6d69747465655f6d616e61676572
    global ZeroAddress
    // smart_contracts/xgov_registry/contract.py:73-75
    // self.committee_manager = GlobalState(
    //     arc4.Address(), key=cfg.GS_KEY_COMMITTEE_MANAGER
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:76
    // self.xgov_daemon = GlobalState(arc4.Address(), key=cfg.GS_KEY_XGOV_DAEMON)
    bytec 17 // 0x78676f765f6461656d6f6e
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:78
    // self.xgov_fee = GlobalState(UInt64(), key=cfg.GS_KEY_XGOV_FEE)
    bytec 18 // 0x78676f765f666565
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:79
    // self.xgovs = GlobalState(UInt64(), key=cfg.GS_KEY_XGOVS)
    bytec 6 // 0x78676f7673
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:80
    // self.proposer_fee = GlobalState(UInt64(), key=cfg.GS_KEY_PROPOSER_FEE)
    bytec 19 // 0x70726f706f7365725f666565
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:81
    // self.open_proposal_fee = GlobalState(UInt64(), key=cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    bytec 11 // 0x6f70656e5f70726f706f73616c5f666565
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:83
    // UInt64(), key=cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS
    bytec 23 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:82-84
    // self.daemon_ops_funding_bps = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:86
    // UInt64(), key=cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS
    bytec 24 // 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:85-87
    // self.proposal_commitment_bps = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:90
    // UInt64(), key=cfg.GS_KEY_MIN_REQUESTED_AMOUNT
    bytec 25 // 0x6d696e5f7265717565737465645f616d6f756e74
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:89-91
    // self.min_requested_amount = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MIN_REQUESTED_AMOUNT
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:94
    // UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL
    bytec 26 // 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:93-95
    // self.max_requested_amount_small = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:97
    // UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM
    bytec 27 // 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:96-98
    // self.max_requested_amount_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:100
    // UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE
    bytec 28 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:99-101
    // self.max_requested_amount_large = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:104
    // UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_SMALL
    bytec 29 // 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:103-105
    // self.discussion_duration_small = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_SMALL
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:107
    // UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM
    bytec 30 // 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:106-108
    // self.discussion_duration_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:110
    // UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_LARGE
    bytec 31 // 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:109-111
    // self.discussion_duration_large = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_LARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:113
    // UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_XLARGE
    bytec 32 // 0x64697363757373696f6e5f6475726174696f6e5f786c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:112-114
    // self.discussion_duration_xlarge = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_XLARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:117
    // UInt64(), key=cfg.GS_KEY_VOTING_DURATION_SMALL
    bytec 33 // 0x766f74696e675f6475726174696f6e5f736d616c6c
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:116-118
    // self.voting_duration_small = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_VOTING_DURATION_SMALL
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:120
    // UInt64(), key=cfg.GS_KEY_VOTING_DURATION_MEDIUM
    bytec 34 // 0x766f74696e675f6475726174696f6e5f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:119-121
    // self.voting_duration_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_VOTING_DURATION_MEDIUM
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:123
    // UInt64(), key=cfg.GS_KEY_VOTING_DURATION_LARGE
    bytec 35 // 0x766f74696e675f6475726174696f6e5f6c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:122-124
    // self.voting_duration_large = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_VOTING_DURATION_LARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:126
    // UInt64(), key=cfg.GS_KEY_VOTING_DURATION_XLARGE
    bytec 36 // 0x766f74696e675f6475726174696f6e5f786c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:125-127
    // self.voting_duration_xlarge = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_VOTING_DURATION_XLARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:129
    // self.quorum_small = GlobalState(UInt64(), key=cfg.GS_KEY_QUORUM_SMALL)
    bytec 37 // 0x71756f72756d5f736d616c6c
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:130
    // self.quorum_medium = GlobalState(UInt64(), key=cfg.GS_KEY_QUORUM_MEDIUM)
    bytec 38 // 0x71756f72756d5f6d656469756d
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:131
    // self.quorum_large = GlobalState(UInt64(), key=cfg.GS_KEY_QUORUM_LARGE)
    bytec 39 // 0x71756f72756d5f6c61726765
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:134
    // UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_SMALL
    bytec 40 // 0x77656967687465645f71756f72756d5f736d616c6c
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:133-135
    // self.weighted_quorum_small = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_SMALL
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:137
    // UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM
    bytec 41 // 0x77656967687465645f71756f72756d5f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:136-138
    // self.weighted_quorum_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:140
    // UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_LARGE
    bytec 42 // 0x77656967687465645f71756f72756d5f6c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:139-141
    // self.weighted_quorum_large = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_LARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:143
    // self.outstanding_funds = GlobalState(UInt64(), key=cfg.GS_KEY_OUTSTANDING_FUNDS)
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:146
    // self.committee_members = GlobalState(UInt64(), key=cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 43 // 0x636f6d6d69747465655f6d656d62657273
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:147
    // self.committee_votes = GlobalState(UInt64(), key=cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 44 // 0x636f6d6d69747465655f766f746573
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:149
    // self.pending_proposals = GlobalState(UInt64(), key=cfg.GS_KEY_PENDING_PROPOSALS)
    bytec 7 // 0x70656e64696e675f70726f706f73616c73
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:151
    // self.request_id = GlobalState(UInt64(), key=cfg.GS_KEY_REQUEST_ID)
    bytec 45 // 0x726571756573745f6964
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:154
    // UInt64(), key=cfg.GS_KEY_MAX_COMMITTEE_SIZE
    bytec 46 // 0x6d61785f636f6d6d69747465655f73697a65
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:153-155
    // self.max_committee_size = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MAX_COMMITTEE_SIZE
    // )
    app_global_put

main_after_if_else@2:
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn NumAppArgs
    bz main_after_if_else@44
    pushbytess 0x4c5c61ba 0x959c4762 0x6c1f564d 0xe10a512e 0x86f7e0e6 0x39e26d8a 0x98352e86 0xfa4ed6e2 0xd6c9cc1a 0x5c484055 0x37d6adf1 0xd4216b6e 0xba8520f2 0x1677b30e 0x84b7d268 0x653a0bdb 0x4956c1ab 0xa082cef8 0x76725559 0x45077390 0x3c31bc02 0x0d2c7891 0x0da27885 0x7a4fee43 0x52dd10d7 0xd4d37a64 0x34349dcc 0x158f8dd6 0xdb27b9af 0xf5910756 0x65610a9f 0xfdc695c2 0xba90ab54 0xb3b58482 0x00b3cef5 0x6f752007 0x3a8d568f 0x230cc121 0x26983200 // method "create()void", method "init_proposal_contract(uint64)void", method "load_proposal_contract(uint64,byte[])void", method "delete_proposal_contract_box()void", method "pause_registry()void", method "pause_proposals()void", method "resume_registry()void", method "resume_proposals()void", method "set_xgov_manager(address)void", method "set_payor(address)void", method "set_xgov_council(address)void", method "set_xgov_subscriber(address)void", method "set_kyc_provider(address)void", method "set_committee_manager(address)void", method "set_xgov_daemon(address)void", method "config_xgov_registry((uint64,uint64,uint64,uint64,uint64,uint64,uint64[3],uint64[4],uint64[4],uint64[3],uint64[3]))void", method "update_xgov_registry()void", method "subscribe_xgov(address,pay)void", method "unsubscribe_xgov(address)void", method "request_subscribe_xgov(address,address,uint64,pay)void", method "approve_subscribe_xgov(uint64)void", method "reject_subscribe_xgov(uint64)void", method "set_voting_account(address,address)void", method "subscribe_proposer(pay)void", method "set_proposer_kyc(address,bool,uint64)void", method "declare_committee(byte[32],uint64,uint64)void", method "open_proposal(pay)uint64", method "vote_proposal(uint64,address,uint64,uint64)void", method "pay_grant_proposal(uint64)void", method "finalize_proposal(uint64)void", method "drop_proposal(uint64)void", method "deposit_funds(pay)void", method "withdraw_funds(uint64)void", method "withdraw_balance()void", method "get_state()(bool,bool,address,address,address,address,address,address,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64[3],uint64[4],uint64[4],uint64[3],uint64[3],uint64,uint64,byte[32],uint64,uint64)", method "get_xgov_box(address)(address,uint64,uint64,uint64)", method "get_proposer_box(address)(bool,bool,uint64)", method "get_request_box(uint64)(address,address,uint64)", method "is_proposal(uint64)void"
    txna ApplicationArgs 0
    match main_create_route@5 main_init_proposal_contract_route@6 main_load_proposal_contract_route@7 main_delete_proposal_contract_box_route@8 main_pause_registry_route@9 main_pause_proposals_route@10 main_resume_registry_route@11 main_resume_proposals_route@12 main_set_xgov_manager_route@13 main_set_payor_route@14 main_set_xgov_council_route@15 main_set_xgov_subscriber_route@16 main_set_kyc_provider_route@17 main_set_committee_manager_route@18 main_set_xgov_daemon_route@19 main_config_xgov_registry_route@20 main_update_xgov_registry_route@21 main_subscribe_xgov_route@22 main_unsubscribe_xgov_route@23 main_request_subscribe_xgov_route@24 main_approve_subscribe_xgov_route@25 main_reject_subscribe_xgov_route@26 main_set_voting_account_route@27 main_subscribe_proposer_route@28 main_set_proposer_kyc_route@29 main_declare_committee_route@30 main_open_proposal_route@31 main_vote_proposal_route@32 main_pay_grant_proposal_route@33 main_finalize_proposal_route@34 main_drop_proposal_route@35 main_deposit_funds_route@36 main_withdraw_funds_route@37 main_withdraw_balance_route@38 main_get_state_route@39 main_get_xgov_box_route@40 main_get_proposer_box_route@41 main_get_request_box_route@42 main_is_proposal_route@43

main_after_if_else@44:
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    intc_0 // 0
    return

main_is_proposal_route@43:
    // smart_contracts/xgov_registry/contract.py:1382
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:1382
    // @arc4.abimethod()
    callsub is_proposal
    intc_1 // 1
    return

main_get_request_box_route@42:
    // smart_contracts/xgov_registry/contract.py:1367
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:1367
    // @arc4.abimethod(readonly=True)
    callsub get_request_box
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_proposer_box_route@41:
    // smart_contracts/xgov_registry/contract.py:1354
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:1354
    // @arc4.abimethod(readonly=True)
    callsub get_proposer_box
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_xgov_box_route@40:
    // smart_contracts/xgov_registry/contract.py:1341
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:1341
    // @arc4.abimethod(readonly=True)
    callsub get_xgov_box
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_state_route@39:
    // smart_contracts/xgov_registry/contract.py:1285
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_state
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_withdraw_balance_route@38:
    // smart_contracts/xgov_registry/contract.py:1256
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub withdraw_balance
    intc_1 // 1
    return

main_withdraw_funds_route@37:
    // smart_contracts/xgov_registry/contract.py:1231
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/xgov_registry/contract.py:1231
    // @arc4.abimethod()
    callsub withdraw_funds
    intc_1 // 1
    return

main_deposit_funds_route@36:
    // smart_contracts/xgov_registry/contract.py:1214
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:1214
    // @arc4.abimethod()
    callsub deposit_funds
    intc_1 // 1
    return

main_drop_proposal_route@35:
    // smart_contracts/xgov_registry/contract.py:1175
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:1175
    // @arc4.abimethod()
    callsub drop_proposal
    intc_1 // 1
    return

main_finalize_proposal_route@34:
    // smart_contracts/xgov_registry/contract.py:1130
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:1130
    // @arc4.abimethod()
    callsub finalize_proposal
    intc_1 // 1
    return

main_pay_grant_proposal_route@33:
    // smart_contracts/xgov_registry/contract.py:1077
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:1077
    // @arc4.abimethod()
    callsub pay_grant_proposal
    intc_1 // 1
    return

main_vote_proposal_route@32:
    // smart_contracts/xgov_registry/contract.py:998
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/xgov_registry/contract.py:998
    // @arc4.abimethod()
    callsub vote_proposal
    intc_1 // 1
    return

main_open_proposal_route@31:
    // smart_contracts/xgov_registry/contract.py:903
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:903
    // @arc4.abimethod
    callsub open_proposal
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_declare_committee_route@30:
    // smart_contracts/xgov_registry/contract.py:875
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/xgov_registry/contract.py:875
    // @arc4.abimethod()
    callsub declare_committee
    intc_1 // 1
    return

main_set_proposer_kyc_route@29:
    // smart_contracts/xgov_registry/contract.py:848
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/xgov_registry/contract.py:848
    // @arc4.abimethod()
    callsub set_proposer_kyc
    intc_1 // 1
    return

main_subscribe_proposer_route@28:
    // smart_contracts/xgov_registry/contract.py:821
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:821
    // @arc4.abimethod()
    callsub subscribe_proposer
    intc_1 // 1
    return

main_set_voting_account_route@27:
    // smart_contracts/xgov_registry/contract.py:789
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/xgov_registry/contract.py:789
    // @arc4.abimethod()
    callsub set_voting_account
    intc_1 // 1
    return

main_reject_subscribe_xgov_route@26:
    // smart_contracts/xgov_registry/contract.py:772
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:772
    // @arc4.abimethod()
    callsub reject_subscribe_xgov
    intc_1 // 1
    return

main_approve_subscribe_xgov_route@25:
    // smart_contracts/xgov_registry/contract.py:750
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:750
    // @arc4.abimethod()
    callsub approve_subscribe_xgov
    intc_1 // 1
    return

main_request_subscribe_xgov_route@24:
    // smart_contracts/xgov_registry/contract.py:707
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:707
    // @arc4.abimethod()
    callsub request_subscribe_xgov
    intc_1 // 1
    return

main_unsubscribe_xgov_route@23:
    // smart_contracts/xgov_registry/contract.py:680
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:680
    // @arc4.abimethod()
    callsub unsubscribe_xgov
    intc_1 // 1
    return

main_subscribe_xgov_route@22:
    // smart_contracts/xgov_registry/contract.py:654
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:654
    // @arc4.abimethod()
    callsub subscribe_xgov
    intc_1 // 1
    return

main_update_xgov_registry_route@21:
    // smart_contracts/xgov_registry/contract.py:643
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    txn OnCompletion
    intc_2 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub update_xgov_registry
    intc_1 // 1
    return

main_config_xgov_registry_route@20:
    // smart_contracts/xgov_registry/contract.py:562
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:562
    // @arc4.abimethod()
    callsub config_xgov_registry
    intc_1 // 1
    return

main_set_xgov_daemon_route@19:
    // smart_contracts/xgov_registry/contract.py:547
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:547
    // @arc4.abimethod()
    callsub set_xgov_daemon
    intc_1 // 1
    return

main_set_committee_manager_route@18:
    // smart_contracts/xgov_registry/contract.py:532
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:532
    // @arc4.abimethod()
    callsub set_committee_manager
    intc_1 // 1
    return

main_set_kyc_provider_route@17:
    // smart_contracts/xgov_registry/contract.py:517
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:517
    // @arc4.abimethod()
    callsub set_kyc_provider
    intc_1 // 1
    return

main_set_xgov_subscriber_route@16:
    // smart_contracts/xgov_registry/contract.py:502
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:502
    // @arc4.abimethod()
    callsub set_xgov_subscriber
    intc_1 // 1
    return

main_set_xgov_council_route@15:
    // smart_contracts/xgov_registry/contract.py:487
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:487
    // @arc4.abimethod()
    callsub set_xgov_council
    intc_1 // 1
    return

main_set_payor_route@14:
    // smart_contracts/xgov_registry/contract.py:472
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:472
    // @arc4.abimethod()
    callsub set_payor
    intc_1 // 1
    return

main_set_xgov_manager_route@13:
    // smart_contracts/xgov_registry/contract.py:457
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:457
    // @arc4.abimethod()
    callsub set_xgov_manager
    intc_1 // 1
    return

main_resume_proposals_route@12:
    // smart_contracts/xgov_registry/contract.py:448
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub resume_proposals
    intc_1 // 1
    return

main_resume_registry_route@11:
    // smart_contracts/xgov_registry/contract.py:439
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub resume_registry
    intc_1 // 1
    return

main_pause_proposals_route@10:
    // smart_contracts/xgov_registry/contract.py:430
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pause_proposals
    intc_1 // 1
    return

main_pause_registry_route@9:
    // smart_contracts/xgov_registry/contract.py:421
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pause_registry
    intc_1 // 1
    return

main_delete_proposal_contract_box_route@8:
    // smart_contracts/xgov_registry/contract.py:407
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub delete_proposal_contract_box
    intc_1 // 1
    return

main_load_proposal_contract_route@7:
    // smart_contracts/xgov_registry/contract.py:389
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/xgov_registry/contract.py:389
    // @arc4.abimethod()
    callsub load_proposal_contract
    intc_1 // 1
    return

main_init_proposal_contract_route@6:
    // smart_contracts/xgov_registry/contract.py:368
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/xgov_registry/contract.py:368
    // @arc4.abimethod()
    callsub init_proposal_contract
    intc_1 // 1
    return

main_create_route@5:
    // smart_contracts/xgov_registry/contract.py:359
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub create
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.is_xgov_manager() -> uint64:
is_xgov_manager:
    // smart_contracts/xgov_registry/contract.py:189
    // return Txn.sender == self.xgov_manager.value.native
    txn Sender
    intc_0 // 0
    bytec 5 // 0x78676f765f6d616e61676572
    app_global_get_ex
    assert // check self.xgov_manager exists
    ==
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.is_xgov_subscriber() -> uint64:
is_xgov_subscriber:
    // smart_contracts/xgov_registry/contract.py:193
    // return Txn.sender == self.xgov_subscriber.value.native
    txn Sender
    intc_0 // 0
    bytec 13 // 0x78676f765f73756273637269626572
    app_global_get_ex
    assert // check self.xgov_subscriber exists
    ==
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry._is_proposal(proposal_id: uint64) -> uint64:
_is_proposal:
    // smart_contracts/xgov_registry/contract.py:203-204
    // @subroutine
    // def _is_proposal(self, proposal_id: UInt64) -> bool:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:205
    // return Application(proposal_id).creator == Global.current_application_address
    frame_dig -1
    app_params_get AppCreator
    assert // application exists
    global CurrentApplicationAddress
    ==
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.get_proposal_proposer(proposal_id: uint64) -> bytes:
get_proposal_proposer:
    // smart_contracts/xgov_registry/contract.py:215-216
    // @subroutine
    // def get_proposal_proposer(self, proposal_id: UInt64) -> Account:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:217-219
    // proposer_bytes, proposer_exists = op.AppGlobal.get_ex_bytes(
    //     proposal_id, pcfg.GS_KEY_PROPOSER
    // )
    frame_dig -1
    // smart_contracts/xgov_registry/contract.py:218
    // proposal_id, pcfg.GS_KEY_PROPOSER
    pushbytes 0x70726f706f736572
    // smart_contracts/xgov_registry/contract.py:217-219
    // proposer_bytes, proposer_exists = op.AppGlobal.get_ex_bytes(
    //     proposal_id, pcfg.GS_KEY_PROPOSER
    // )
    app_global_get_ex
    // smart_contracts/xgov_registry/contract.py:220
    // assert proposer_exists, err.MISSING_KEY
    assert // Missing key in state
    // smart_contracts/xgov_registry/contract.py:221
    // return Account(proposer_bytes)
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.valid_xgov_payment(payment: uint64) -> uint64:
valid_xgov_payment:
    // smart_contracts/xgov_registry/contract.py:239-240
    // @subroutine
    // def valid_xgov_payment(self, payment: gtxn.PaymentTransaction) -> bool:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:242
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/xgov_registry/contract.py:242-243
    // payment.receiver == Global.current_application_address
    // and payment.amount == self.xgov_fee.value
    bz valid_xgov_payment_bool_false@3
    // smart_contracts/xgov_registry/contract.py:243
    // and payment.amount == self.xgov_fee.value
    frame_dig -1
    gtxns Amount
    intc_0 // 0
    bytec 18 // 0x78676f765f666565
    app_global_get_ex
    assert // check self.xgov_fee exists
    ==
    // smart_contracts/xgov_registry/contract.py:242-243
    // payment.receiver == Global.current_application_address
    // and payment.amount == self.xgov_fee.value
    bz valid_xgov_payment_bool_false@3
    intc_1 // 1
    // smart_contracts/xgov_registry/contract.py:241-244
    // return (
    //     payment.receiver == Global.current_application_address
    //     and payment.amount == self.xgov_fee.value
    // )
    retsub

valid_xgov_payment_bool_false@3:
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:241-244
    // return (
    //     payment.receiver == Global.current_application_address
    //     and payment.amount == self.xgov_fee.value
    // )
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.valid_kyc(address: bytes) -> uint64:
valid_kyc:
    // smart_contracts/xgov_registry/contract.py:246-247
    // @subroutine
    // def valid_kyc(self, address: Account) -> bool:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:249
    // self.proposer_box[address].kyc_status.native
    bytec_2 // 0x70
    frame_dig -1
    concat
    dup
    box_get
    assert // check self.proposer_box entry exists
    intc_1 // 1
    getbit
    bytec 8 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/xgov_registry/contract.py:249-250
    // self.proposer_box[address].kyc_status.native
    // and self.proposer_box[address].kyc_expiring.native > Global.latest_timestamp
    bz valid_kyc_bool_false@3
    // smart_contracts/xgov_registry/contract.py:250
    // and self.proposer_box[address].kyc_expiring.native > Global.latest_timestamp
    frame_dig 0
    box_get
    assert // check self.proposer_box entry exists
    intc_1 // 1
    extract_uint64
    global LatestTimestamp
    >
    // smart_contracts/xgov_registry/contract.py:249-250
    // self.proposer_box[address].kyc_status.native
    // and self.proposer_box[address].kyc_expiring.native > Global.latest_timestamp
    bz valid_kyc_bool_false@3
    intc_1 // 1

valid_kyc_bool_merge@4:
    // smart_contracts/xgov_registry/contract.py:248-251
    // return (
    //     self.proposer_box[address].kyc_status.native
    //     and self.proposer_box[address].kyc_expiring.native > Global.latest_timestamp
    // )
    swap
    retsub

valid_kyc_bool_false@3:
    intc_0 // 0
    b valid_kyc_bool_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.decrement_pending_proposals(proposal_id: uint64) -> void:
decrement_pending_proposals:
    // smart_contracts/xgov_registry/contract.py:308-309
    // @subroutine
    // def decrement_pending_proposals(self, proposal_id: UInt64) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:310-311
    // # Decrement pending proposals count
    // self.pending_proposals.value -= 1
    intc_0 // 0
    bytec 7 // 0x70656e64696e675f70726f706f73616c73
    app_global_get_ex
    assert // check self.pending_proposals exists
    intc_1 // 1
    -
    bytec 7 // 0x70656e64696e675f70726f706f73616c73
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:313-314
    // # Update proposer's active proposal status
    // proposer = self.get_proposal_proposer(proposal_id)
    frame_dig -1
    callsub get_proposal_proposer
    // smart_contracts/xgov_registry/contract.py:315
    // self.proposer_box[proposer].active_proposal = arc4.Bool(False)  # noqa: FBT003
    bytec_2 // 0x70
    swap
    concat
    dup
    box_get
    assert // check self.proposer_box entry exists
    intc_0 // 0
    dup
    setbit
    box_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.make_xgov_box(voting_address: bytes) -> bytes:
make_xgov_box:
    // smart_contracts/xgov_registry/contract.py:317-318
    // @subroutine
    // def make_xgov_box(self, voting_address: arc4.Address) -> typ.XGovBoxValue:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:332
    // subscription_round=arc4.UInt64(Global.round),
    global Round
    itob
    // smart_contracts/xgov_registry/contract.py:328-333
    // return typ.XGovBoxValue(
    //     voting_address=voting_address,
    //     voted_proposals=arc4.UInt64(0),
    //     last_vote_timestamp=arc4.UInt64(0),
    //     subscription_round=arc4.UInt64(Global.round),
    // )
    frame_dig -1
    // smart_contracts/xgov_registry/contract.py:330
    // voted_proposals=arc4.UInt64(0),
    bytec 48 // 0x0000000000000000
    // smart_contracts/xgov_registry/contract.py:328-333
    // return typ.XGovBoxValue(
    //     voting_address=voting_address,
    //     voted_proposals=arc4.UInt64(0),
    //     last_vote_timestamp=arc4.UInt64(0),
    //     subscription_round=arc4.UInt64(Global.round),
    // )
    concat
    // smart_contracts/xgov_registry/contract.py:331
    // last_vote_timestamp=arc4.UInt64(0),
    bytec 48 // 0x0000000000000000
    // smart_contracts/xgov_registry/contract.py:328-333
    // return typ.XGovBoxValue(
    //     voting_address=voting_address,
    //     voted_proposals=arc4.UInt64(0),
    //     last_vote_timestamp=arc4.UInt64(0),
    //     subscription_round=arc4.UInt64(Global.round),
    // )
    concat
    swap
    concat
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.create() -> void:
create:
    // smart_contracts/xgov_registry/contract.py:365
    // self.xgov_manager.value = arc4.Address(Txn.sender)
    bytec 5 // 0x78676f765f6d616e61676572
    txn Sender
    app_global_put
    // smart_contracts/xgov_registry/contract.py:185
    // return TemplateVar[Bytes]("entropy")  # trick to allow fresh deployment
    bytec 50 // TMPL_entropy
    // smart_contracts/xgov_registry/contract.py:366
    // assert self.entropy() == TemplateVar[Bytes]("entropy")
    dup
    ==
    assert
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.init_proposal_contract(size: bytes) -> void:
init_proposal_contract:
    // smart_contracts/xgov_registry/contract.py:368-369
    // @arc4.abimethod()
    // def init_proposal_contract(self, size: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:380
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:382
    // box, exist = self.proposal_approval_program.maybe()
    bytec 9 // 0x7061
    box_get
    bury 1
    // smart_contracts/xgov_registry/contract.py:383
    // if exist:
    bz init_proposal_contract_else_body@2
    // smart_contracts/xgov_registry/contract.py:384
    // self.proposal_approval_program.resize(size.native)
    frame_dig -1
    btoi
    bytec 9 // 0x7061
    swap
    box_resize
    retsub

init_proposal_contract_else_body@2:
    // smart_contracts/xgov_registry/contract.py:386-387
    // # Initialize the Proposal Approval Program contract
    // self.proposal_approval_program.create(size=size.native)
    frame_dig -1
    btoi
    bytec 9 // 0x7061
    swap
    box_create
    pop
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.load_proposal_contract(offset: bytes, data: bytes) -> void:
load_proposal_contract:
    // smart_contracts/xgov_registry/contract.py:389-390
    // @arc4.abimethod()
    // def load_proposal_contract(self, offset: arc4.UInt64, data: Bytes) -> None:
    proto 2 0
    // smart_contracts/xgov_registry/contract.py:402
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:404-405
    // # Load the Proposal Approval Program contract
    // self.proposal_approval_program.replace(start_index=offset.native, value=data)
    frame_dig -2
    btoi
    bytec 9 // 0x7061
    swap
    frame_dig -1
    box_replace
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.delete_proposal_contract_box() -> void:
delete_proposal_contract_box:
    // smart_contracts/xgov_registry/contract.py:416
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:418-419
    // # Delete the Proposal Approval Program contract box
    // self.proposal_approval_program.delete()
    bytec 9 // 0x7061
    box_del
    pop
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.pause_registry() -> void:
pause_registry:
    // smart_contracts/xgov_registry/contract.py:427
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:428
    // self.paused_registry.value = UInt64(1)
    bytec_0 // 0x7061757365645f7265676973747279
    intc_1 // 1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.pause_proposals() -> void:
pause_proposals:
    // smart_contracts/xgov_registry/contract.py:436
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:437
    // self.paused_proposals.value = UInt64(1)
    bytec 10 // 0x7061757365645f70726f706f73616c73
    intc_1 // 1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.resume_registry() -> void:
resume_registry:
    // smart_contracts/xgov_registry/contract.py:445
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:446
    // self.paused_registry.value = UInt64(0)
    bytec_0 // 0x7061757365645f7265676973747279
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.resume_proposals() -> void:
resume_proposals:
    // smart_contracts/xgov_registry/contract.py:454
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:455
    // self.paused_proposals.value = UInt64(0)
    bytec 10 // 0x7061757365645f70726f706f73616c73
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_xgov_manager(manager: bytes) -> void:
set_xgov_manager:
    // smart_contracts/xgov_registry/contract.py:457-458
    // @arc4.abimethod()
    // def set_xgov_manager(self, manager: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:469
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:470
    // self.xgov_manager.value = manager
    bytec 5 // 0x78676f765f6d616e61676572
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_payor(payor: bytes) -> void:
set_payor:
    // smart_contracts/xgov_registry/contract.py:472-473
    // @arc4.abimethod()
    // def set_payor(self, payor: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:484
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:485
    // self.xgov_payor.value = payor
    bytec 14 // 0x78676f765f7061796f72
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_xgov_council(council: bytes) -> void:
set_xgov_council:
    // smart_contracts/xgov_registry/contract.py:487-488
    // @arc4.abimethod()
    // def set_xgov_council(self, council: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:499
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:500
    // self.xgov_council.value = council
    bytec 22 // 0x78676f765f636f756e63696c
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_xgov_subscriber(subscriber: bytes) -> void:
set_xgov_subscriber:
    // smart_contracts/xgov_registry/contract.py:502-503
    // @arc4.abimethod()
    // def set_xgov_subscriber(self, subscriber: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:514
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:515
    // self.xgov_subscriber.value = subscriber
    bytec 13 // 0x78676f765f73756273637269626572
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_kyc_provider(provider: bytes) -> void:
set_kyc_provider:
    // smart_contracts/xgov_registry/contract.py:517-518
    // @arc4.abimethod()
    // def set_kyc_provider(self, provider: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:529
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:530
    // self.kyc_provider.value = provider
    bytec 15 // 0x6b79635f70726f7669646572
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_committee_manager(manager: bytes) -> void:
set_committee_manager:
    // smart_contracts/xgov_registry/contract.py:532-533
    // @arc4.abimethod()
    // def set_committee_manager(self, manager: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:544
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:545
    // self.committee_manager.value = manager
    bytec 16 // 0x636f6d6d69747465655f6d616e61676572
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_xgov_daemon(xgov_daemon: bytes) -> void:
set_xgov_daemon:
    // smart_contracts/xgov_registry/contract.py:547-548
    // @arc4.abimethod()
    // def set_xgov_daemon(self, xgov_daemon: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:559
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:560
    // self.xgov_daemon.value = xgov_daemon
    bytec 17 // 0x78676f765f6461656d6f6e
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.config_xgov_registry(config: bytes) -> void:
config_xgov_registry:
    // smart_contracts/xgov_registry/contract.py:562-563
    // @arc4.abimethod()
    // def config_xgov_registry(self, config: typ.XGovRegistryConfig) -> None:
    proto 1 0
    intc_0 // 0
    pushbytes ""
    dupn 3
    // smart_contracts/xgov_registry/contract.py:575
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:201
    // return self.pending_proposals.value == 0
    intc_0 // 0
    bytec 7 // 0x70656e64696e675f70726f706f73616c73
    app_global_get_ex
    assert // check self.pending_proposals exists
    !
    // smart_contracts/xgov_registry/contract.py:576
    // assert self.no_pending_proposals(), err.NO_PENDING_PROPOSALS
    assert // Cannot perform operation with pending proposals
    // smart_contracts/xgov_registry/contract.py:597
    // config.xgov_fee.native >= xgov_box_mbr
    frame_dig -1
    intc_0 // 0
    extract_uint64
    dup
    // smart_contracts/xgov_registry/contract.py:274-276
    // return (
    //     key_prefix_length + key_type_size + value_type_size
    // ) * PER_BYTE_IN_BOX_MBR + PER_BOX_MBR
    pushint 38100 // 38100
    // smart_contracts/xgov_registry/contract.py:597
    // config.xgov_fee.native >= xgov_box_mbr
    >=
    // smart_contracts/xgov_registry/contract.py:597-598
    // config.xgov_fee.native >= xgov_box_mbr
    // and config.xgov_fee.native >= xgov_request_box_mbr
    bz config_xgov_registry_bool_false@3
    // smart_contracts/xgov_registry/contract.py:598
    // and config.xgov_fee.native >= xgov_request_box_mbr
    frame_dig 5
    // smart_contracts/xgov_registry/contract.py:274-276
    // return (
    //     key_prefix_length + key_type_size + value_type_size
    // ) * PER_BYTE_IN_BOX_MBR + PER_BOX_MBR
    pushint 34900 // 34900
    // smart_contracts/xgov_registry/contract.py:598
    // and config.xgov_fee.native >= xgov_request_box_mbr
    >=
    // smart_contracts/xgov_registry/contract.py:597-598
    // config.xgov_fee.native >= xgov_box_mbr
    // and config.xgov_fee.native >= xgov_request_box_mbr
    bz config_xgov_registry_bool_false@3
    intc_1 // 1

config_xgov_registry_bool_merge@4:
    // smart_contracts/xgov_registry/contract.py:596-599
    // assert (
    //     config.xgov_fee.native >= xgov_box_mbr
    //     and config.xgov_fee.native >= xgov_request_box_mbr
    // ), err.INVALID_XGOV_FEE
    assert // Invalid xGov fee
    // smart_contracts/xgov_registry/contract.py:601
    // assert config.proposer_fee.native >= proposer_box_mbr, err.INVALID_PROPOSER_FEE
    frame_dig -1
    intc_3 // 8
    extract_uint64
    dup
    frame_bury 3
    // smart_contracts/xgov_registry/contract.py:274-276
    // return (
    //     key_prefix_length + key_type_size + value_type_size
    // ) * PER_BYTE_IN_BOX_MBR + PER_BOX_MBR
    intc 4 // 19300
    // smart_contracts/xgov_registry/contract.py:601
    // assert config.proposer_fee.native >= proposer_box_mbr, err.INVALID_PROPOSER_FEE
    >=
    assert // Invalid proposer fee
    // smart_contracts/xgov_registry/contract.py:604
    // config.min_requested_amount.native
    frame_dig -1
    pushint 40 // 40
    extract_uint64
    dup
    frame_bury 4
    // smart_contracts/xgov_registry/contract.py:605
    // < config.max_requested_amount[0].native
    frame_dig -1
    extract 48 24 // on error: Index access is out of bounds
    dup
    frame_bury 0
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 1
    // smart_contracts/xgov_registry/contract.py:604-605
    // config.min_requested_amount.native
    // < config.max_requested_amount[0].native
    <
    // smart_contracts/xgov_registry/contract.py:604-606
    // config.min_requested_amount.native
    // < config.max_requested_amount[0].native
    // < config.max_requested_amount[1].native
    bz config_xgov_registry_bool_false@8
    // smart_contracts/xgov_registry/contract.py:606
    // < config.max_requested_amount[1].native
    frame_dig 0
    intc_3 // 8
    extract_uint64
    dup
    frame_bury 2
    // smart_contracts/xgov_registry/contract.py:605-606
    // < config.max_requested_amount[0].native
    // < config.max_requested_amount[1].native
    frame_dig 1
    >
    // smart_contracts/xgov_registry/contract.py:604-606
    // config.min_requested_amount.native
    // < config.max_requested_amount[0].native
    // < config.max_requested_amount[1].native
    bz config_xgov_registry_bool_false@8
    // smart_contracts/xgov_registry/contract.py:607
    // < config.max_requested_amount[2].native
    frame_dig 0
    pushint 16 // 16
    extract_uint64
    // smart_contracts/xgov_registry/contract.py:606-607
    // < config.max_requested_amount[1].native
    // < config.max_requested_amount[2].native
    frame_dig 2
    >
    // smart_contracts/xgov_registry/contract.py:605-607
    // < config.max_requested_amount[0].native
    // < config.max_requested_amount[1].native
    // < config.max_requested_amount[2].native
    bz config_xgov_registry_bool_false@8
    intc_1 // 1

config_xgov_registry_bool_merge@9:
    // smart_contracts/xgov_registry/contract.py:603-608
    // assert (
    //     config.min_requested_amount.native
    //     < config.max_requested_amount[0].native
    //     < config.max_requested_amount[1].native
    //     < config.max_requested_amount[2].native
    // ), err.INCOSISTENT_REQUESTED_AMOUNT_CONFIG
    assert // Inconsistent requested amount config
    // smart_contracts/xgov_registry/contract.py:611
    // config.open_proposal_fee.native, config.daemon_ops_funding_bps.native
    frame_dig -1
    pushint 16 // 16
    extract_uint64
    frame_dig -1
    pushint 24 // 24
    extract_uint64
    // smart_contracts/xgov_registry/contract.py:257
    // return amount * fraction_in_bps // BPS
    dup2
    *
    pushint 10000 // 10000
    /
    // smart_contracts/xgov_registry/contract.py:295
    // UInt64(MAX_MBR_PER_APP + MAX_MBR_PER_BOX + ACCOUNT_MBR) + daemon_ops_funding
    pushint 16835300 // 16835300
    +
    // smart_contracts/xgov_registry/contract.py:298
    // assert open_proposal_fee > to_substract, err.INVALID_OPEN_PROPOSAL_FEE
    dig 2
    dig 1
    >
    assert // Invalid open proposal fee
    // smart_contracts/xgov_registry/contract.py:300
    // mbr_available_for_committee = open_proposal_fee - to_substract
    dig 2
    swap
    -
    // smart_contracts/xgov_registry/contract.py:274-276
    // return (
    //     key_prefix_length + key_type_size + value_type_size
    // ) * PER_BYTE_IN_BOX_MBR + PER_BOX_MBR
    intc 4 // 19300
    // smart_contracts/xgov_registry/contract.py:306
    // self.max_committee_size.value = mbr_available_for_committee // per_voter_mbr
    /
    bytec 46 // 0x6d61785f636f6d6d69747465655f73697a65
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:614
    // self.xgov_fee.value = config.xgov_fee.native
    bytec 18 // 0x78676f765f666565
    frame_dig 5
    app_global_put
    // smart_contracts/xgov_registry/contract.py:615
    // self.proposer_fee.value = config.proposer_fee.native
    bytec 19 // 0x70726f706f7365725f666565
    frame_dig 3
    app_global_put
    // smart_contracts/xgov_registry/contract.py:616
    // self.open_proposal_fee.value = config.open_proposal_fee.native
    bytec 11 // 0x6f70656e5f70726f706f73616c5f666565
    uncover 2
    app_global_put
    // smart_contracts/xgov_registry/contract.py:617
    // self.daemon_ops_funding_bps.value = config.daemon_ops_funding_bps.native
    bytec 23 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:618
    // self.proposal_commitment_bps.value = config.proposal_commitment_bps.native
    frame_dig -1
    pushint 32 // 32
    extract_uint64
    bytec 24 // 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:620
    // self.min_requested_amount.value = config.min_requested_amount.native
    bytec 25 // 0x6d696e5f7265717565737465645f616d6f756e74
    frame_dig 4
    app_global_put
    // smart_contracts/xgov_registry/contract.py:621
    // self.max_requested_amount_small.value = config.max_requested_amount[0].native
    bytec 26 // 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    frame_dig 1
    app_global_put
    // smart_contracts/xgov_registry/contract.py:622
    // self.max_requested_amount_medium.value = config.max_requested_amount[1].native
    frame_dig 0
    dup
    intc_3 // 8
    extract_uint64
    bytec 27 // 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:623
    // self.max_requested_amount_large.value = config.max_requested_amount[2].native
    pushint 16 // 16
    extract_uint64
    bytec 28 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:625
    // self.discussion_duration_small.value = config.discussion_duration[0].native
    frame_dig -1
    extract 72 32 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    bytec 29 // 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:626
    // self.discussion_duration_medium.value = config.discussion_duration[1].native
    dup
    intc_3 // 8
    extract_uint64
    bytec 30 // 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:627
    // self.discussion_duration_large.value = config.discussion_duration[2].native
    dup
    pushint 16 // 16
    extract_uint64
    bytec 31 // 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:628
    // self.discussion_duration_xlarge.value = config.discussion_duration[3].native
    pushint 24 // 24
    extract_uint64
    bytec 32 // 0x64697363757373696f6e5f6475726174696f6e5f786c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:630
    // self.voting_duration_small.value = config.voting_duration[0].native
    frame_dig -1
    extract 104 32 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    bytec 33 // 0x766f74696e675f6475726174696f6e5f736d616c6c
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:631
    // self.voting_duration_medium.value = config.voting_duration[1].native
    dup
    intc_3 // 8
    extract_uint64
    bytec 34 // 0x766f74696e675f6475726174696f6e5f6d656469756d
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:632
    // self.voting_duration_large.value = config.voting_duration[2].native
    dup
    pushint 16 // 16
    extract_uint64
    bytec 35 // 0x766f74696e675f6475726174696f6e5f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:633
    // self.voting_duration_xlarge.value = config.voting_duration[3].native
    pushint 24 // 24
    extract_uint64
    bytec 36 // 0x766f74696e675f6475726174696f6e5f786c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:635
    // self.quorum_small.value = config.quorum[0].native
    frame_dig -1
    extract 136 24 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    bytec 37 // 0x71756f72756d5f736d616c6c
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:636
    // self.quorum_medium.value = config.quorum[1].native
    dup
    intc_3 // 8
    extract_uint64
    bytec 38 // 0x71756f72756d5f6d656469756d
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:637
    // self.quorum_large.value = config.quorum[2].native
    pushint 16 // 16
    extract_uint64
    bytec 39 // 0x71756f72756d5f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:639
    // self.weighted_quorum_small.value = config.weighted_quorum[0].native
    frame_dig -1
    extract 160 24 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    bytec 40 // 0x77656967687465645f71756f72756d5f736d616c6c
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:640
    // self.weighted_quorum_medium.value = config.weighted_quorum[1].native
    dup
    intc_3 // 8
    extract_uint64
    bytec 41 // 0x77656967687465645f71756f72756d5f6d656469756d
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:641
    // self.weighted_quorum_large.value = config.weighted_quorum[2].native
    pushint 16 // 16
    extract_uint64
    bytec 42 // 0x77656967687465645f71756f72756d5f6c61726765
    swap
    app_global_put
    retsub

config_xgov_registry_bool_false@8:
    intc_0 // 0
    b config_xgov_registry_bool_merge@9

config_xgov_registry_bool_false@3:
    intc_0 // 0
    b config_xgov_registry_bool_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.update_xgov_registry() -> void:
update_xgov_registry:
    // smart_contracts/xgov_registry/contract.py:652
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.subscribe_xgov(voting_address: bytes, payment: uint64) -> void:
subscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:654-657
    // @arc4.abimethod()
    // def subscribe_xgov(
    //     self, voting_address: arc4.Address, payment: gtxn.PaymentTransaction
    // ) -> None:
    proto 2 0
    // smart_contracts/xgov_registry/contract.py:670
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:672
    // assert Txn.sender not in self.xgov_box, err.ALREADY_XGOV
    bytec 4 // 0x78
    txn Sender
    concat
    box_len
    bury 1
    !
    assert // Already an xGov
    // smart_contracts/xgov_registry/contract.py:673-674
    // # check payment
    // assert self.valid_xgov_payment(payment), err.INVALID_PAYMENT
    frame_dig -1
    callsub valid_xgov_payment
    assert // Invalid payment
    // smart_contracts/xgov_registry/contract.py:676-677
    // # create box
    // self.xgov_box[Txn.sender] = self.make_xgov_box(voting_address)
    frame_dig -2
    callsub make_xgov_box
    bytec 4 // 0x78
    txn Sender
    concat
    swap
    box_put
    // smart_contracts/xgov_registry/contract.py:678
    // self.xgovs.value += 1
    intc_0 // 0
    bytec 6 // 0x78676f7673
    app_global_get_ex
    assert // check self.xgovs exists
    intc_1 // 1
    +
    bytec 6 // 0x78676f7673
    swap
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.unsubscribe_xgov(xgov_address: bytes) -> void:
unsubscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:680-681
    // @arc4.abimethod()
    // def unsubscribe_xgov(self, xgov_address: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:692
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:694-695
    // # ensure the provided address is an xGov
    // assert xgov_address.native in self.xgov_box, err.UNAUTHORIZED
    bytec 4 // 0x78
    frame_dig -1
    concat
    dupn 2
    box_len
    bury 1
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:696-697
    // # get the voting address
    // voting_address = self.xgov_box[xgov_address.native].voting_address.native
    box_get
    assert // check self.xgov_box entry exists
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/xgov_registry/contract.py:700
    // xgov_address.native == Txn.sender or voting_address == Txn.sender
    frame_dig -1
    txn Sender
    ==
    bnz unsubscribe_xgov_bool_true@2
    frame_dig 1
    txn Sender
    ==
    bz unsubscribe_xgov_bool_false@3

unsubscribe_xgov_bool_true@2:
    intc_1 // 1

unsubscribe_xgov_bool_merge@4:
    // smart_contracts/xgov_registry/contract.py:698-701
    // # ensure the sender is the xGov or the voting address
    // assert (
    //     xgov_address.native == Txn.sender or voting_address == Txn.sender
    // ), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:703-704
    // # delete box
    // del self.xgov_box[xgov_address.native]
    frame_dig 0
    box_del
    pop
    // smart_contracts/xgov_registry/contract.py:705
    // self.xgovs.value -= 1
    intc_0 // 0
    bytec 6 // 0x78676f7673
    app_global_get_ex
    assert // check self.xgovs exists
    intc_1 // 1
    -
    bytec 6 // 0x78676f7673
    swap
    app_global_put
    retsub

unsubscribe_xgov_bool_false@3:
    intc_0 // 0
    b unsubscribe_xgov_bool_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.request_subscribe_xgov(xgov_address: bytes, owner_address: bytes, relation_type: bytes, payment: uint64) -> void:
request_subscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:707-714
    // @arc4.abimethod()
    // def request_subscribe_xgov(
    //     self,
    //     xgov_address: arc4.Address,
    //     owner_address: arc4.Address,
    //     relation_type: arc4.UInt64,
    //     payment: gtxn.PaymentTransaction,
    // ) -> None:
    proto 4 0
    // smart_contracts/xgov_registry/contract.py:730
    // assert Txn.sender == owner_address.native, err.UNAUTHORIZED
    txn Sender
    frame_dig -3
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:731
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:733-734
    // # ensure the xgov_address is not already an xGov
    // assert xgov_address.native not in self.xgov_box, err.ALREADY_XGOV
    bytec 4 // 0x78
    frame_dig -4
    concat
    box_len
    bury 1
    !
    assert // Already an xGov
    // smart_contracts/xgov_registry/contract.py:736-737
    // # check payment
    // assert self.valid_xgov_payment(payment), err.INVALID_PAYMENT
    frame_dig -1
    callsub valid_xgov_payment
    assert // Invalid payment
    // smart_contracts/xgov_registry/contract.py:739-740
    // # create request box
    // rid = self.request_id.value
    intc_0 // 0
    bytec 45 // 0x726571756573745f6964
    app_global_get_ex
    assert // check self.request_id exists
    // smart_contracts/xgov_registry/contract.py:741-745
    // self.request_box[rid] = typ.XGovSubscribeRequestBoxValue(
    //     xgov_addr=xgov_address,
    //     owner_addr=owner_address,
    //     relation_type=relation_type,
    // )
    frame_dig -4
    frame_dig -3
    concat
    frame_dig -2
    concat
    // smart_contracts/xgov_registry/contract.py:741
    // self.request_box[rid] = typ.XGovSubscribeRequestBoxValue(
    dig 1
    itob
    bytec 20 // 0x72
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:741-745
    // self.request_box[rid] = typ.XGovSubscribeRequestBoxValue(
    //     xgov_addr=xgov_address,
    //     owner_addr=owner_address,
    //     relation_type=relation_type,
    // )
    swap
    box_put
    // smart_contracts/xgov_registry/contract.py:747-748
    // # increment request id
    // self.request_id.value += 1
    intc_1 // 1
    +
    bytec 45 // 0x726571756573745f6964
    swap
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.approve_subscribe_xgov(request_id: bytes) -> void:
approve_subscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:750-751
    // @arc4.abimethod()
    // def approve_subscribe_xgov(self, request_id: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:762
    // assert self.is_xgov_subscriber(), err.UNAUTHORIZED
    callsub is_xgov_subscriber
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:764-765
    // # get the request
    // request = self.request_box[request_id.native].copy()
    frame_dig -1
    btoi
    itob
    bytec 20 // 0x72
    swap
    concat
    dup
    box_get
    assert // check self.request_box entry exists
    // smart_contracts/xgov_registry/contract.py:766-767
    // # create the xGov
    // self.xgov_box[request.xgov_addr.native] = self.make_xgov_box(request.owner_addr)
    dup
    extract 32 32 // on error: Index access is out of bounds
    callsub make_xgov_box
    swap
    extract 0 32 // on error: Index access is out of bounds
    bytec 4 // 0x78
    swap
    concat
    swap
    box_put
    // smart_contracts/xgov_registry/contract.py:768
    // self.xgovs.value += 1
    intc_0 // 0
    bytec 6 // 0x78676f7673
    app_global_get_ex
    assert // check self.xgovs exists
    intc_1 // 1
    +
    bytec 6 // 0x78676f7673
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:769-770
    // # delete the request
    // del self.request_box[request_id.native]
    box_del
    pop
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.reject_subscribe_xgov(request_id: bytes) -> void:
reject_subscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:772-773
    // @arc4.abimethod()
    // def reject_subscribe_xgov(self, request_id: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:784
    // assert self.is_xgov_subscriber(), err.UNAUTHORIZED
    callsub is_xgov_subscriber
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:786-787
    // # delete the request
    // del self.request_box[request_id.native]
    frame_dig -1
    btoi
    itob
    bytec 20 // 0x72
    swap
    concat
    box_del
    pop
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_voting_account(xgov_address: bytes, voting_address: bytes) -> void:
set_voting_account:
    // smart_contracts/xgov_registry/contract.py:789-792
    // @arc4.abimethod()
    // def set_voting_account(
    //     self, xgov_address: arc4.Address, voting_address: arc4.Address
    // ) -> None:
    proto 2 0
    // smart_contracts/xgov_registry/contract.py:805
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:807-808
    // # Check if the sender is an xGov member
    // exists = xgov_address.native in self.xgov_box
    bytec 4 // 0x78
    frame_dig -2
    concat
    dupn 2
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:809
    // assert exists, err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:810
    // xgov_box = self.xgov_box[xgov_address.native].copy()
    box_get
    assert // check self.xgov_box entry exists
    // smart_contracts/xgov_registry/contract.py:814
    // Txn.sender == xgov_box.voting_address.native
    txn Sender
    swap
    extract 0 32 // on error: Index access is out of bounds
    ==
    // smart_contracts/xgov_registry/contract.py:814-815
    // Txn.sender == xgov_box.voting_address.native
    // or Txn.sender == xgov_address.native
    bnz set_voting_account_bool_true@2
    // smart_contracts/xgov_registry/contract.py:815
    // or Txn.sender == xgov_address.native
    txn Sender
    frame_dig -2
    ==
    // smart_contracts/xgov_registry/contract.py:814-815
    // Txn.sender == xgov_box.voting_address.native
    // or Txn.sender == xgov_address.native
    bz set_voting_account_bool_false@3

set_voting_account_bool_true@2:
    intc_1 // 1

set_voting_account_bool_merge@4:
    // smart_contracts/xgov_registry/contract.py:812-816
    // # Check that the sender is either the xGov or the voting address
    // assert (
    //     Txn.sender == xgov_box.voting_address.native
    //     or Txn.sender == xgov_address.native
    // ), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:818-819
    // # Update the voting account in the xGov box
    // self.xgov_box[xgov_address.native].voting_address = voting_address
    frame_dig 0
    dup
    box_get
    assert // check self.xgov_box entry exists
    frame_dig -1
    replace2 0
    box_put
    retsub

set_voting_account_bool_false@3:
    intc_0 // 0
    b set_voting_account_bool_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.subscribe_proposer(payment: uint64) -> void:
subscribe_proposer:
    // smart_contracts/xgov_registry/contract.py:821-822
    // @arc4.abimethod()
    // def subscribe_proposer(self, payment: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:835
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:837
    // assert Txn.sender not in self.proposer_box, err.ALREADY_PROPOSER
    bytec_2 // 0x70
    txn Sender
    concat
    box_len
    bury 1
    !
    assert // Already a proposer
    // smart_contracts/xgov_registry/contract.py:840
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/xgov_registry/contract.py:838-841
    // # check fee
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/xgov_registry/contract.py:842
    // assert payment.amount == self.proposer_fee.value, err.WRONG_PAYMENT_AMOUNT
    frame_dig -1
    gtxns Amount
    intc_0 // 0
    bytec 19 // 0x70726f706f7365725f666565
    app_global_get_ex
    assert // check self.proposer_fee exists
    ==
    assert // Wrong payment amount
    // smart_contracts/xgov_registry/contract.py:844
    // self.proposer_box[Txn.sender] = self.make_proposer_box(
    bytec_2 // 0x70
    txn Sender
    concat
    // smart_contracts/xgov_registry/contract.py:353-357
    // return typ.ProposerBoxValue(
    //     active_proposal=active_proposal,
    //     kyc_status=kyc_status,
    //     kyc_expiring=kyc_expiring,
    // )
    pushbytes 0x000000000000000000
    // smart_contracts/xgov_registry/contract.py:844-846
    // self.proposer_box[Txn.sender] = self.make_proposer_box(
    //     arc4.Bool(False), arc4.Bool(False), arc4.UInt64(0)  # noqa: FBT003
    // )
    box_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.set_proposer_kyc(proposer: bytes, kyc_status: bytes, kyc_expiring: bytes) -> void:
set_proposer_kyc:
    // smart_contracts/xgov_registry/contract.py:848-851
    // @arc4.abimethod()
    // def set_proposer_kyc(
    //     self, proposer: arc4.Address, kyc_status: arc4.Bool, kyc_expiring: arc4.UInt64
    // ) -> None:
    proto 3 0
    // smart_contracts/xgov_registry/contract.py:865-866
    // # check if kyc provider
    // assert Txn.sender == self.kyc_provider.value.native, err.UNAUTHORIZED
    txn Sender
    intc_0 // 0
    bytec 15 // 0x6b79635f70726f7669646572
    app_global_get_ex
    assert // check self.kyc_provider exists
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:867
    // assert proposer.native in self.proposer_box, err.PROPOSER_DOES_NOT_EXIST
    bytec_2 // 0x70
    frame_dig -3
    concat
    dup
    box_len
    bury 1
    assert // Proposer does not exist
    // smart_contracts/xgov_registry/contract.py:869
    // active_proposal = self.proposer_box[proposer.native].copy().active_proposal
    dup
    box_get
    assert // check self.proposer_box entry exists
    intc_0 // 0
    getbit
    bytec 8 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/xgov_registry/contract.py:353-357
    // return typ.ProposerBoxValue(
    //     active_proposal=active_proposal,
    //     kyc_status=kyc_status,
    //     kyc_expiring=kyc_expiring,
    // )
    frame_dig -2
    intc_0 // 0
    getbit
    intc_1 // 1
    swap
    setbit
    frame_dig -1
    concat
    // smart_contracts/xgov_registry/contract.py:871-873
    // self.proposer_box[proposer.native] = self.make_proposer_box(
    //     active_proposal, kyc_status, kyc_expiring
    // )
    box_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.declare_committee(committee_id: bytes, size: bytes, votes: bytes) -> void:
declare_committee:
    // smart_contracts/xgov_registry/contract.py:875-878
    // @arc4.abimethod()
    // def declare_committee(
    //     self, committee_id: typ.Bytes32, size: arc4.UInt64, votes: arc4.UInt64
    // ) -> None:
    proto 3 0
    // smart_contracts/xgov_registry/contract.py:197
    // return Txn.sender == self.committee_manager.value.native
    txn Sender
    intc_0 // 0
    bytec 16 // 0x636f6d6d69747465655f6d616e61676572
    app_global_get_ex
    assert // check self.committee_manager exists
    ==
    // smart_contracts/xgov_registry/contract.py:893
    // assert self.is_xgov_committee_manager(), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:896
    // size.native <= self.max_committee_size.value
    frame_dig -2
    btoi
    intc_0 // 0
    bytec 46 // 0x6d61785f636f6d6d69747465655f73697a65
    app_global_get_ex
    assert // check self.max_committee_size exists
    dig 1
    >=
    // smart_contracts/xgov_registry/contract.py:895-897
    // assert (
    //     size.native <= self.max_committee_size.value
    // ), err.COMMITTEE_SIZE_TOO_LARGE
    assert // Committee size is too large
    // smart_contracts/xgov_registry/contract.py:899
    // self.committee_id.value = committee_id.copy()
    bytec 49 // 0x636f6d6d69747465655f6964
    frame_dig -3
    app_global_put
    // smart_contracts/xgov_registry/contract.py:900
    // self.committee_members.value = size.native
    bytec 43 // 0x636f6d6d69747465655f6d656d62657273
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:901
    // self.committee_votes.value = votes.native
    frame_dig -1
    btoi
    bytec 44 // 0x636f6d6d69747465655f766f746573
    swap
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.open_proposal(payment: uint64) -> uint64:
open_proposal:
    // smart_contracts/xgov_registry/contract.py:903-904
    // @arc4.abimethod
    // def open_proposal(self, payment: gtxn.PaymentTransaction) -> UInt64:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:920
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:921
    // assert not self.paused_proposals.value, err.PAUSED_PROPOSALS
    intc_0 // 0
    bytec 10 // 0x7061757365645f70726f706f73616c73
    app_global_get_ex
    assert // check self.paused_proposals exists
    !
    assert // Creation of proposals is paused
    // smart_contracts/xgov_registry/contract.py:923-924
    // # Check if the caller is a registered proposer
    // assert Txn.sender in self.proposer_box, err.UNAUTHORIZED
    bytec_2 // 0x70
    txn Sender
    concat
    box_len
    bury 1
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:926-927
    // # Check if the proposer already has an active proposal
    // assert not self.proposer_box[
    bytec_2 // 0x70
    // smart_contracts/xgov_registry/contract.py:928
    // Txn.sender
    txn Sender
    // smart_contracts/xgov_registry/contract.py:926-929
    // # Check if the proposer already has an active proposal
    // assert not self.proposer_box[
    //     Txn.sender
    // ].active_proposal, err.ALREADY_ACTIVE_PROPOSAL
    concat
    box_get
    assert // check self.proposer_box entry exists
    intc_0 // 0
    getbit
    bytec 8 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 8 // 0x00
    ==
    assert // Proposer already has an active proposal
    // smart_contracts/xgov_registry/contract.py:930
    // assert self.valid_kyc(Txn.sender), err.INVALID_KYC
    txn Sender
    callsub valid_kyc
    assert // Invalid KYC
    // smart_contracts/xgov_registry/contract.py:932
    // assert Txn.fee >= (Global.min_txn_fee * 3), err.INSUFFICIENT_FEE
    txn Fee
    global MinTxnFee
    pushint 3 // 3
    *
    >=
    assert // Insufficient fee
    // smart_contracts/xgov_registry/contract.py:936
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/xgov_registry/contract.py:934-937
    // # Ensure the transaction has the correct payment
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/xgov_registry/contract.py:938
    // assert payment.amount == self.open_proposal_fee.value, err.WRONG_PAYMENT_AMOUNT
    frame_dig -1
    gtxns Amount
    intc_0 // 0
    bytec 11 // 0x6f70656e5f70726f706f73616c5f666565
    app_global_get_ex
    assert // check self.open_proposal_fee exists
    ==
    assert // Wrong payment amount
    // smart_contracts/xgov_registry/contract.py:940
    // mbr_before = Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/xgov_registry/contract.py:942
    // proposal_approval, exist = self.proposal_approval_program.maybe()
    bytec 9 // 0x7061
    box_get
    // smart_contracts/xgov_registry/contract.py:943
    // assert exist, err.MISSING_PROPOSAL_APPROVAL_PROGRAM
    assert // Missing proposal approval program
    // smart_contracts/xgov_registry/contract.py:952
    // total_size = proposal_approval.length + compiled_clear_state_1.length
    dup
    len
    intc_2 // 4
    +
    // smart_contracts/xgov_registry/contract.py:951
    // bytes_per_page = UInt64(BYTES_PER_APP_PAGE)
    pushint 2048 // 2048
    // smart_contracts/xgov_registry/contract.py:953
    // extra_pages = total_size // bytes_per_page
    /
    // smart_contracts/xgov_registry/contract.py:955-963
    // error, tx = arc4.abi_call(
    //     proposal_contract.Proposal.create,
    //     Txn.sender,
    //     approval_program=proposal_approval,
    //     clear_state_program=compiled_clear_state_1,
    //     global_num_uint=pcfg.GLOBAL_UINTS,
    //     global_num_bytes=pcfg.GLOBAL_BYTES,
    //     extra_program_pages=extra_pages,
    // )
    itxn_begin
    // smart_contracts/xgov_registry/contract.py:957
    // Txn.sender,
    txn Sender
    swap
    itxn_field ExtraProgramPages
    // smart_contracts/xgov_registry/contract.py:961
    // global_num_bytes=pcfg.GLOBAL_BYTES,
    pushint 3 // 3
    itxn_field GlobalNumByteSlice
    // smart_contracts/xgov_registry/contract.py:960
    // global_num_uint=pcfg.GLOBAL_UINTS,
    pushint 20 // 20
    itxn_field GlobalNumUint
    // smart_contracts/xgov_registry/contract.py:945-949
    // # clear_state_program is a tuple of 2 Bytes elements where each is max 4096 bytes
    // # we only use the first element here as we assume the clear state program is small enough
    // compiled_clear_state_1, compiled_clear_state_2 = compile_contract(
    //     proposal_contract.Proposal
    // ).clear_state_program
    pushbytes base64(CoEBQw==)
    itxn_field ClearStateProgramPages
    swap
    itxn_field ApprovalProgramPages
    // smart_contracts/xgov_registry/contract.py:955-963
    // error, tx = arc4.abi_call(
    //     proposal_contract.Proposal.create,
    //     Txn.sender,
    //     approval_program=proposal_approval,
    //     clear_state_program=compiled_clear_state_1,
    //     global_num_uint=pcfg.GLOBAL_UINTS,
    //     global_num_bytes=pcfg.GLOBAL_BYTES,
    //     extra_program_pages=extra_pages,
    // )
    pushbytes 0x216b1e07 // method "create(address)string"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    itxn CreatedApplicationID
    swap
    // smart_contracts/xgov_registry/contract.py:965
    // if error.native.startswith(err.ARC_65_PREFIX):
    extract 6 0
    dup
    len
    dup
    intc_2 // 4
    <
    bz open_proposal_ternary_false@3
    intc_0 // 0

open_proposal_ternary_merge@4:
    // smart_contracts/xgov_registry/contract.py:965
    // if error.native.startswith(err.ARC_65_PREFIX):
    bz open_proposal_else_body@11
    // smart_contracts/xgov_registry/contract.py:966
    // error_without_prefix = String.from_bytes(error.native.bytes[4:])
    intc_2 // 4
    frame_dig 4
    dup
    cover 2
    >=
    intc_2 // 4
    dig 2
    uncover 2
    select
    frame_dig 3
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:968
    // case err.MISSING_CONFIG:
    bytec 47 // "Missing Config"
    // smart_contracts/xgov_registry/contract.py:970
    // case err.EMPTY_COMMITTEE_ID:
    pushbytess "Empty Committee ID" "Wrong Committee Members" "Wrong Committee Votes" // "Empty Committee ID", "Wrong Committee Members", "Wrong Committee Votes"
    // smart_contracts/xgov_registry/contract.py:967-977
    // match error_without_prefix:
    //     case err.MISSING_CONFIG:
    //         assert False, err.MISSING_CONFIG  # noqa
    //     case err.EMPTY_COMMITTEE_ID:
    //         assert False, err.EMPTY_COMMITTEE_ID  # noqa
    //     case err.WRONG_COMMITTEE_MEMBERS:
    //         assert False, err.WRONG_COMMITTEE_MEMBERS  # noqa
    //     case err.WRONG_COMMITTEE_VOTES:
    //         assert False, err.WRONG_COMMITTEE_VOTES  # noqa
    //     case _:
    //         assert False, "Unknown error"  # noqa
    uncover 4
    match open_proposal_switch_case_0@6 open_proposal_switch_case_1@7 open_proposal_switch_case_2@8 open_proposal_switch_case_3@9
    // smart_contracts/xgov_registry/contract.py:977
    // assert False, "Unknown error"  # noqa
    err // Unknown error

open_proposal_switch_case_3@9:
    // smart_contracts/xgov_registry/contract.py:975
    // assert False, err.WRONG_COMMITTEE_VOTES  # noqa
    err // Wrong Committee Votes

open_proposal_switch_case_2@8:
    // smart_contracts/xgov_registry/contract.py:973
    // assert False, err.WRONG_COMMITTEE_MEMBERS  # noqa
    err // Wrong Committee Members

open_proposal_switch_case_1@7:
    // smart_contracts/xgov_registry/contract.py:971
    // assert False, err.EMPTY_COMMITTEE_ID  # noqa
    err // Empty Committee ID

open_proposal_switch_case_0@6:
    // smart_contracts/xgov_registry/contract.py:969
    // assert False, err.MISSING_CONFIG  # noqa
    err // Missing Config

open_proposal_else_body@11:
    // smart_contracts/xgov_registry/contract.py:979
    // assert error.native == "", "Unknown error"
    frame_dig 3
    pushbytes ""
    ==
    assert // Unknown error
    // smart_contracts/xgov_registry/contract.py:981
    // mbr_after = Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/xgov_registry/contract.py:983-984
    // # Update proposer state
    // self.proposer_box[Txn.sender].active_proposal = arc4.Bool(True)  # noqa: FBT003
    bytec_2 // 0x70
    txn Sender
    concat
    dup
    box_get
    assert // check self.proposer_box entry exists
    intc_0 // 0
    intc_1 // 1
    setbit
    box_put
    // smart_contracts/xgov_registry/contract.py:986-991
    // # Transfer funds to the new Proposal App, excluding the MBR needed for the Proposal App
    // itxn.Payment(
    //     receiver=tx.created_app.address,
    //     amount=self.open_proposal_fee.value - (mbr_after - mbr_before),
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/xgov_registry/contract.py:988
    // receiver=tx.created_app.address,
    frame_dig 2
    dup
    cover 2
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/xgov_registry/contract.py:989
    // amount=self.open_proposal_fee.value - (mbr_after - mbr_before),
    intc_0 // 0
    bytec 11 // 0x6f70656e5f70726f706f73616c5f666565
    app_global_get_ex
    assert // check self.open_proposal_fee exists
    uncover 2
    frame_dig 0
    -
    -
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/xgov_registry/contract.py:986-987
    // # Transfer funds to the new Proposal App, excluding the MBR needed for the Proposal App
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/xgov_registry/contract.py:990
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/xgov_registry/contract.py:986-991
    // # Transfer funds to the new Proposal App, excluding the MBR needed for the Proposal App
    // itxn.Payment(
    //     receiver=tx.created_app.address,
    //     amount=self.open_proposal_fee.value - (mbr_after - mbr_before),
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/xgov_registry/contract.py:993-994
    // # Increment pending proposals
    // self.pending_proposals.value += 1
    intc_0 // 0
    bytec 7 // 0x70656e64696e675f70726f706f73616c73
    app_global_get_ex
    assert // check self.pending_proposals exists
    intc_1 // 1
    +
    bytec 7 // 0x70656e64696e675f70726f706f73616c73
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:996
    // return tx.created_app.id
    frame_bury 0
    retsub

open_proposal_ternary_false@3:
    // smart_contracts/xgov_registry/contract.py:965
    // if error.native.startswith(err.ARC_65_PREFIX):
    frame_dig 1
    extract 6 4
    bytec 12 // "ERR:"
    ==
    b open_proposal_ternary_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.vote_proposal(proposal_id: bytes, xgov_address: bytes, approval_votes: bytes, rejection_votes: bytes) -> void:
vote_proposal:
    // smart_contracts/xgov_registry/contract.py:998-1005
    // @arc4.abimethod()
    // def vote_proposal(
    //     self,
    //     proposal_id: arc4.UInt64,
    //     xgov_address: arc4.Address,
    //     approval_votes: arc4.UInt64,
    //     rejection_votes: arc4.UInt64,
    // ) -> None:
    proto 4 0
    // smart_contracts/xgov_registry/contract.py:1029
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:1031-1032
    // # verify proposal id is genuine proposal
    // assert self._is_proposal(proposal_id.native), err.INVALID_PROPOSAL
    frame_dig -4
    btoi
    dup
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1034-1035
    // # make sure they're voting on behalf of an xGov
    // exists = xgov_address.native in self.xgov_box
    bytec 4 // 0x78
    frame_dig -3
    concat
    dup
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:1036
    // assert exists, err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1037
    // xgov_box = self.xgov_box[xgov_address.native].copy()
    dup
    box_get
    assert // check self.xgov_box entry exists
    // smart_contracts/xgov_registry/contract.py:1039
    // xgov_box.voted_proposals.native + UInt64(1)
    dup
    pushint 32 // 32
    extract_uint64
    intc_1 // 1
    +
    // smart_contracts/xgov_registry/contract.py:1038-1040
    // self.xgov_box[xgov_address.native].voted_proposals = arc4.UInt64(
    //     xgov_box.voted_proposals.native + UInt64(1)
    // )
    itob
    dig 1
    swap
    replace2 32
    // smart_contracts/xgov_registry/contract.py:1042
    // Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/xgov_registry/contract.py:1041-1043
    // self.xgov_box[xgov_address.native].last_vote_timestamp = arc4.UInt64(
    //     Global.latest_timestamp
    // )
    itob
    replace2 40
    uncover 2
    swap
    box_put
    // smart_contracts/xgov_registry/contract.py:1045-1046
    // # Verify the caller is using their voting address
    // assert Txn.sender == xgov_box.voting_address.native, err.MUST_BE_VOTING_ADDRESS
    txn Sender
    swap
    extract 0 32 // on error: Index access is out of bounds
    ==
    assert // Must be voting address
    // smart_contracts/xgov_registry/contract.py:1048-1055
    // # Call the Proposal App to register the vote
    // error, tx = arc4.abi_call(
    //     proposal_contract.Proposal.vote,
    //     xgov_address,
    //     approval_votes,
    //     rejection_votes,
    //     app_id=proposal_id.native,
    // )
    itxn_begin
    itxn_field ApplicationID
    pushbytes 0x1841a0d2 // method "vote(address,uint64,uint64)string"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    // smart_contracts/xgov_registry/contract.py:1057
    // if error.native.startswith(err.ARC_65_PREFIX):
    extract 6 0
    dup
    len
    dup
    intc_2 // 4
    <
    bz vote_proposal_ternary_false@3
    intc_0 // 0

vote_proposal_ternary_merge@4:
    // smart_contracts/xgov_registry/contract.py:1057
    // if error.native.startswith(err.ARC_65_PREFIX):
    bz vote_proposal_else_body@13
    // smart_contracts/xgov_registry/contract.py:1058
    // error_without_prefix = String.from_bytes(error.native.bytes[4:])
    intc_2 // 4
    frame_dig 2
    dup
    cover 2
    >=
    intc_2 // 4
    dig 2
    uncover 2
    select
    frame_dig 1
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1060
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 21 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1062
    // case err.MISSING_CONFIG:
    bytec 47 // "Missing Config"
    // smart_contracts/xgov_registry/contract.py:1064
    // case err.VOTER_NOT_FOUND:
    pushbytess "Voter not found" "Voter already voted" "Votes exceeded" "Voting Period Expired" // "Voter not found", "Voter already voted", "Votes exceeded", "Voting Period Expired"
    // smart_contracts/xgov_registry/contract.py:1059-1073
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         assert False, err.WRONG_PROPOSAL_STATUS  # noqa
    //     case err.MISSING_CONFIG:
    //         assert False, err.MISSING_CONFIG  # noqa
    //     case err.VOTER_NOT_FOUND:
    //         assert False, err.VOTER_NOT_FOUND  # noqa
    //     case err.VOTER_ALREADY_VOTED:
    //         assert False, err.VOTER_ALREADY_VOTED  # noqa
    //     case err.VOTES_EXCEEDED:
    //         assert False, err.VOTES_EXCEEDED  # noqa
    //     case err.VOTING_PERIOD_EXPIRED:
    //         assert False, err.VOTING_PERIOD_EXPIRED  # noqa
    //     case _:
    //         assert False, "Unknown error"  # noqa
    uncover 6
    match vote_proposal_switch_case_0@6 vote_proposal_switch_case_1@7 vote_proposal_switch_case_2@8 vote_proposal_switch_case_3@9 vote_proposal_switch_case_4@10 vote_proposal_switch_case_5@11
    // smart_contracts/xgov_registry/contract.py:1073
    // assert False, "Unknown error"  # noqa
    err // Unknown error

vote_proposal_switch_case_5@11:
    // smart_contracts/xgov_registry/contract.py:1071
    // assert False, err.VOTING_PERIOD_EXPIRED  # noqa
    err // Voting Period Expired

vote_proposal_switch_case_4@10:
    // smart_contracts/xgov_registry/contract.py:1069
    // assert False, err.VOTES_EXCEEDED  # noqa
    err // Votes exceeded

vote_proposal_switch_case_3@9:
    // smart_contracts/xgov_registry/contract.py:1067
    // assert False, err.VOTER_ALREADY_VOTED  # noqa
    err // Voter already voted

vote_proposal_switch_case_2@8:
    // smart_contracts/xgov_registry/contract.py:1065
    // assert False, err.VOTER_NOT_FOUND  # noqa
    err // Voter not found

vote_proposal_switch_case_1@7:
    // smart_contracts/xgov_registry/contract.py:1063
    // assert False, err.MISSING_CONFIG  # noqa
    err // Missing Config

vote_proposal_switch_case_0@6:
    // smart_contracts/xgov_registry/contract.py:1061
    // assert False, err.WRONG_PROPOSAL_STATUS  # noqa
    err // Wrong Proposal Status or finalized

vote_proposal_else_body@13:
    // smart_contracts/xgov_registry/contract.py:1075
    // assert error.native == "", "Unknown error"
    frame_dig 1
    pushbytes ""
    ==
    assert // Unknown error
    retsub

vote_proposal_ternary_false@3:
    // smart_contracts/xgov_registry/contract.py:1057
    // if error.native.startswith(err.ARC_65_PREFIX):
    frame_dig 0
    extract 6 4
    bytec 12 // "ERR:"
    ==
    b vote_proposal_ternary_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.pay_grant_proposal(proposal_id: bytes) -> void:
pay_grant_proposal:
    // smart_contracts/xgov_registry/contract.py:1077-1078
    // @arc4.abimethod()
    // def pay_grant_proposal(self, proposal_id: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:1095-1096
    // # Verify the caller is the xGov Payor
    // assert arc4.Address(Txn.sender) == self.xgov_payor.value, err.UNAUTHORIZED
    txn Sender
    intc_0 // 0
    bytec 14 // 0x78676f765f7061796f72
    app_global_get_ex
    assert // check self.xgov_payor exists
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1098-1099
    // # Verify proposal_id is a genuine proposal created by this registry
    // assert self._is_proposal(proposal_id.native), err.INVALID_PROPOSAL
    frame_dig -1
    btoi
    dup
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1101-1102
    // # Read proposal state directly from the Proposal App's global state
    // proposer = self.get_proposal_proposer(proposal_id.native)
    dup
    callsub get_proposal_proposer
    // smart_contracts/xgov_registry/contract.py:225-227
    // requested_amount, requested_amount_exists = op.AppGlobal.get_ex_uint64(
    //     proposal_id, pcfg.GS_KEY_REQUESTED_AMOUNT
    // )
    dig 1
    // smart_contracts/xgov_registry/contract.py:226
    // proposal_id, pcfg.GS_KEY_REQUESTED_AMOUNT
    pushbytes 0x7265717565737465645f616d6f756e74
    // smart_contracts/xgov_registry/contract.py:225-227
    // requested_amount, requested_amount_exists = op.AppGlobal.get_ex_uint64(
    //     proposal_id, pcfg.GS_KEY_REQUESTED_AMOUNT
    // )
    app_global_get_ex
    // smart_contracts/xgov_registry/contract.py:228
    // assert requested_amount_exists, err.MISSING_KEY
    assert // Missing key in state
    // smart_contracts/xgov_registry/contract.py:1105
    // assert proposer in self.proposer_box, err.WRONG_PROPOSER
    bytec_2 // 0x70
    dig 2
    concat
    box_len
    bury 1
    assert // Wrong proposer
    // smart_contracts/xgov_registry/contract.py:1107
    // assert self.valid_kyc(proposer), err.INVALID_KYC
    dig 1
    callsub valid_kyc
    assert // Invalid KYC
    // smart_contracts/xgov_registry/contract.py:1111
    // self.outstanding_funds.value >= requested_amount
    intc_0 // 0
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    dup
    dig 2
    >=
    // smart_contracts/xgov_registry/contract.py:1109-1112
    // # Verify sufficient funds are available
    // assert (
    //     self.outstanding_funds.value >= requested_amount
    // ), err.INSUFFICIENT_TREASURY_FUNDS
    assert // Insufficient treasury funds
    // smart_contracts/xgov_registry/contract.py:233-234
    // # Transfer the funds to the receiver
    // itxn.Payment(receiver=recipient, amount=amount, fee=0).submit()
    itxn_begin
    dig 1
    itxn_field Amount
    uncover 2
    itxn_field Receiver
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/xgov_registry/contract.py:236-237
    // # Update the outstanding funds
    // self.outstanding_funds.value -= amount
    swap
    -
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1116-1118
    // error, tx = arc4.abi_call(
    //     proposal_contract.Proposal.fund, app_id=proposal_id.native
    // )
    itxn_begin
    itxn_field ApplicationID
    pushbytes 0x8a5e4c80 // method "fund()string"
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    // smart_contracts/xgov_registry/contract.py:1120
    // if error.native.startswith(err.ARC_65_PREFIX):
    extract 6 0
    dup
    len
    dup
    intc_2 // 4
    <
    bz pay_grant_proposal_ternary_false@3
    intc_0 // 0

pay_grant_proposal_ternary_merge@4:
    // smart_contracts/xgov_registry/contract.py:1120
    // if error.native.startswith(err.ARC_65_PREFIX):
    bz pay_grant_proposal_else_body@8
    // smart_contracts/xgov_registry/contract.py:1121
    // error_without_prefix = String.from_bytes(error.native.bytes[4:])
    intc_2 // 4
    frame_dig 2
    dup
    cover 2
    >=
    intc_2 // 4
    dig 2
    uncover 2
    select
    frame_dig 1
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1123
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 21 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1122-1126
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         assert False, err.WRONG_PROPOSAL_STATUS  # noqa
    //     case _:
    //         assert False, "Unknown error"  # noqa
    swap
    match pay_grant_proposal_switch_case_0@6
    // smart_contracts/xgov_registry/contract.py:1126
    // assert False, "Unknown error"  # noqa
    err // Unknown error

pay_grant_proposal_switch_case_0@6:
    // smart_contracts/xgov_registry/contract.py:1124
    // assert False, err.WRONG_PROPOSAL_STATUS  # noqa
    err // Wrong Proposal Status or finalized

pay_grant_proposal_else_body@8:
    // smart_contracts/xgov_registry/contract.py:1128
    // assert error.native == "", "Unknown error"
    frame_dig 1
    pushbytes ""
    ==
    assert // Unknown error
    retsub

pay_grant_proposal_ternary_false@3:
    // smart_contracts/xgov_registry/contract.py:1120
    // if error.native.startswith(err.ARC_65_PREFIX):
    frame_dig 0
    extract 6 4
    bytec 12 // "ERR:"
    ==
    b pay_grant_proposal_ternary_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.finalize_proposal(proposal_id: bytes) -> void:
finalize_proposal:
    // smart_contracts/xgov_registry/contract.py:1130-1131
    // @arc4.abimethod()
    // def finalize_proposal(self, proposal_id: arc4.UInt64) -> None:
    proto 1 0
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/xgov_registry/contract.py:1146
    // proposal_status = self.get_proposal_status(proposal_id.native)
    frame_dig -1
    btoi
    dup
    // smart_contracts/xgov_registry/contract.py:210
    // proposal_id, pcfg.GS_KEY_STATUS
    pushbytes 0x737461747573
    // smart_contracts/xgov_registry/contract.py:209-211
    // status, status_exists = op.AppGlobal.get_ex_uint64(
    //     proposal_id, pcfg.GS_KEY_STATUS
    // )
    app_global_get_ex
    swap
    dup
    uncover 2
    // smart_contracts/xgov_registry/contract.py:212
    // assert status_exists, err.MISSING_KEY
    assert // Missing key in state
    // smart_contracts/xgov_registry/contract.py:1147-1149
    // if proposal_status == UInt64(penm.STATUS_EMPTY) or proposal_status == UInt64(
    //     penm.STATUS_DRAFT
    // ):
    bz finalize_proposal_if_body@2
    frame_dig 4
    pushint 10 // 10
    ==
    bz finalize_proposal_after_if_else@3

finalize_proposal_if_body@2:
    // smart_contracts/xgov_registry/contract.py:1150
    // assert arc4.Address(Txn.sender) == self.xgov_daemon.value, err.UNAUTHORIZED
    txn Sender
    intc_0 // 0
    bytec 17 // 0x78676f765f6461656d6f6e
    app_global_get_ex
    assert // check self.xgov_daemon exists
    ==
    assert // Unauthorized

finalize_proposal_after_if_else@3:
    // smart_contracts/xgov_registry/contract.py:1152-1153
    // # Verify proposal_id is a genuine proposal created by this registry
    // assert self._is_proposal(proposal_id.native), err.INVALID_PROPOSAL
    frame_dig 3
    dup
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1155-1157
    // error, tx = arc4.abi_call(
    //     proposal_contract.Proposal.finalize, app_id=proposal_id.native
    // )
    itxn_begin
    itxn_field ApplicationID
    pushbytes 0x802069b4 // method "finalize()string"
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    frame_bury 0
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    // smart_contracts/xgov_registry/contract.py:1159
    // if error.native.startswith(err.ARC_65_PREFIX):
    extract 6 0
    dup
    frame_bury 1
    len
    dup
    frame_bury 2
    intc_2 // 4
    <
    bz finalize_proposal_ternary_false@6
    intc_0 // 0

finalize_proposal_ternary_merge@7:
    // smart_contracts/xgov_registry/contract.py:1159
    // if error.native.startswith(err.ARC_65_PREFIX):
    bz finalize_proposal_else_body@13
    // smart_contracts/xgov_registry/contract.py:1160
    // error_without_prefix = String.from_bytes(error.native.bytes[4:])
    intc_2 // 4
    frame_dig 2
    dup
    cover 2
    >=
    intc_2 // 4
    dig 2
    uncover 2
    select
    frame_dig 1
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1162
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 21 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1164
    // case err.MISSING_CONFIG:
    bytec 47 // "Missing Config"
    // smart_contracts/xgov_registry/contract.py:1166
    // case err.VOTERS_ASSIGNED:
    pushbytes "There are voters assigned to this proposal"
    // smart_contracts/xgov_registry/contract.py:1161-1169
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         assert False, err.WRONG_PROPOSAL_STATUS  # noqa
    //     case err.MISSING_CONFIG:
    //         assert False, err.MISSING_CONFIG  # noqa
    //     case err.VOTERS_ASSIGNED:
    //         assert False, err.VOTERS_ASSIGNED  # noqa
    //     case _:
    //         assert False, "Unknown error"  # noqa
    uncover 3
    match finalize_proposal_switch_case_0@9 finalize_proposal_switch_case_1@10 finalize_proposal_switch_case_2@11
    // smart_contracts/xgov_registry/contract.py:1169
    // assert False, "Unknown error"  # noqa
    err // Unknown error

finalize_proposal_switch_case_2@11:
    // smart_contracts/xgov_registry/contract.py:1167
    // assert False, err.VOTERS_ASSIGNED  # noqa
    err // There are voters assigned to this proposal

finalize_proposal_switch_case_1@10:
    // smart_contracts/xgov_registry/contract.py:1165
    // assert False, err.MISSING_CONFIG  # noqa
    err // Missing Config

finalize_proposal_switch_case_0@9:
    // smart_contracts/xgov_registry/contract.py:1163
    // assert False, err.WRONG_PROPOSAL_STATUS  # noqa
    err // Wrong Proposal Status or finalized

finalize_proposal_else_body@13:
    // smart_contracts/xgov_registry/contract.py:1171
    // assert error.native == "", "Unknown error"
    frame_dig 1
    pushbytes ""
    ==
    assert // Unknown error
    // smart_contracts/xgov_registry/contract.py:1173
    // self.decrement_pending_proposals(proposal_id.native)
    frame_dig 3
    callsub decrement_pending_proposals
    retsub

finalize_proposal_ternary_false@6:
    // smart_contracts/xgov_registry/contract.py:1159
    // if error.native.startswith(err.ARC_65_PREFIX):
    frame_dig 0
    extract 6 4
    bytec 12 // "ERR:"
    ==
    b finalize_proposal_ternary_merge@7


// smart_contracts.xgov_registry.contract.XGovRegistry.drop_proposal(proposal_id: bytes) -> void:
drop_proposal:
    // smart_contracts/xgov_registry/contract.py:1175-1176
    // @arc4.abimethod()
    // def drop_proposal(self, proposal_id: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:1190
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:1192-1193
    // # Verify proposal_id is a genuine proposal created by this registry
    // assert self._is_proposal(proposal_id.native), err.INVALID_PROPOSAL
    frame_dig -1
    btoi
    dupn 2
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1195
    // proposer = self.get_proposal_proposer(proposal_id.native)
    dup
    callsub get_proposal_proposer
    // smart_contracts/xgov_registry/contract.py:1196
    // assert Txn.sender == proposer, err.UNAUTHORIZED
    txn Sender
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1198-1200
    // error, tx = arc4.abi_call(
    //     proposal_contract.Proposal.drop, app_id=proposal_id.native
    // )
    itxn_begin
    itxn_field ApplicationID
    pushbytes 0x7371321a // method "drop()string"
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    // smart_contracts/xgov_registry/contract.py:1202
    // if error.native.startswith(err.ARC_65_PREFIX):
    extract 6 0
    dup
    len
    dup
    intc_2 // 4
    <
    bz drop_proposal_ternary_false@3
    intc_0 // 0

drop_proposal_ternary_merge@4:
    // smart_contracts/xgov_registry/contract.py:1202
    // if error.native.startswith(err.ARC_65_PREFIX):
    bz drop_proposal_else_body@8
    // smart_contracts/xgov_registry/contract.py:1203
    // error_without_prefix = String.from_bytes(error.native.bytes[4:])
    intc_2 // 4
    frame_dig 3
    dup
    cover 2
    >=
    intc_2 // 4
    dig 2
    uncover 2
    select
    frame_dig 2
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1205
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 21 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1204-1208
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         assert False, err.WRONG_PROPOSAL_STATUS  # noqa
    //     case _:
    //         assert False, "Unknown error"  # noqa
    swap
    match drop_proposal_switch_case_0@6
    // smart_contracts/xgov_registry/contract.py:1208
    // assert False, "Unknown error"  # noqa
    err // Unknown error

drop_proposal_switch_case_0@6:
    // smart_contracts/xgov_registry/contract.py:1206
    // assert False, err.WRONG_PROPOSAL_STATUS  # noqa
    err // Wrong Proposal Status or finalized

drop_proposal_else_body@8:
    // smart_contracts/xgov_registry/contract.py:1210
    // assert error.native == "", "Unknown error"
    frame_dig 2
    pushbytes ""
    ==
    assert // Unknown error
    // smart_contracts/xgov_registry/contract.py:1212
    // self.decrement_pending_proposals(proposal_id.native)
    frame_dig 0
    callsub decrement_pending_proposals
    retsub

drop_proposal_ternary_false@3:
    // smart_contracts/xgov_registry/contract.py:1202
    // if error.native.startswith(err.ARC_65_PREFIX):
    frame_dig 1
    extract 6 4
    bytec 12 // "ERR:"
    ==
    b drop_proposal_ternary_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.deposit_funds(payment: uint64) -> void:
deposit_funds:
    // smart_contracts/xgov_registry/contract.py:1214-1215
    // @arc4.abimethod()
    // def deposit_funds(self, payment: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:1227
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/xgov_registry/contract.py:1226-1228
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/xgov_registry/contract.py:1229
    // self.outstanding_funds.value += payment.amount
    intc_0 // 0
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    frame_dig -1
    gtxns Amount
    +
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    swap
    app_global_put
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.withdraw_funds(amount: uint64) -> void:
withdraw_funds:
    // smart_contracts/xgov_registry/contract.py:1231-1232
    // @arc4.abimethod()
    // def withdraw_funds(self, amount: UInt64) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:1245
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1246
    // assert amount <= self.outstanding_funds.value, err.INSUFFICIENT_FUNDS
    intc_0 // 0
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    frame_dig -1
    dig 1
    <=
    assert // Insufficient funds
    // smart_contracts/xgov_registry/contract.py:1247
    // assert Txn.fee >= (Global.min_txn_fee * 2), err.INSUFFICIENT_FEE
    txn Fee
    global MinTxnFee
    pushint 2 // 2
    *
    >=
    assert // Insufficient fee
    // smart_contracts/xgov_registry/contract.py:1248
    // self.outstanding_funds.value -= amount
    frame_dig -1
    -
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1250-1254
    // itxn.Payment(
    //     receiver=self.xgov_manager.value.native,
    //     amount=amount,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/xgov_registry/contract.py:1251
    // receiver=self.xgov_manager.value.native,
    intc_0 // 0
    bytec 5 // 0x78676f765f6d616e61676572
    app_global_get_ex
    assert // check self.xgov_manager exists
    frame_dig -1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/xgov_registry/contract.py:1250
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/xgov_registry/contract.py:1253
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/xgov_registry/contract.py:1250-1254
    // itxn.Payment(
    //     receiver=self.xgov_manager.value.native,
    //     amount=amount,
    //     fee=0,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.withdraw_balance() -> void:
withdraw_balance:
    // smart_contracts/xgov_registry/contract.py:1268
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1269
    // assert Txn.fee >= (Global.min_txn_fee * 2), err.INSUFFICIENT_FEE
    txn Fee
    global MinTxnFee
    pushint 2 // 2
    *
    >=
    assert // Insufficient fee
    // smart_contracts/xgov_registry/contract.py:1273
    // Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/xgov_registry/contract.py:1274
    // - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/xgov_registry/contract.py:1273-1274
    // Global.current_application_address.balance
    // - Global.current_application_address.min_balance
    -
    // smart_contracts/xgov_registry/contract.py:1275
    // - self.outstanding_funds.value
    intc_0 // 0
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    // smart_contracts/xgov_registry/contract.py:1273-1275
    // Global.current_application_address.balance
    // - Global.current_application_address.min_balance
    // - self.outstanding_funds.value
    -
    // smart_contracts/xgov_registry/contract.py:1278
    // assert amount > 0, err.INSUFFICIENT_FUNDS
    dup
    assert // Insufficient funds
    // smart_contracts/xgov_registry/contract.py:1279-1283
    // itxn.Payment(
    //     receiver=self.xgov_manager.value.native,
    //     amount=amount,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/xgov_registry/contract.py:1280
    // receiver=self.xgov_manager.value.native,
    intc_0 // 0
    bytec 5 // 0x78676f765f6d616e61676572
    app_global_get_ex
    assert // check self.xgov_manager exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/xgov_registry/contract.py:1279
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/xgov_registry/contract.py:1282
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/xgov_registry/contract.py:1279-1283
    // itxn.Payment(
    //     receiver=self.xgov_manager.value.native,
    //     amount=amount,
    //     fee=0,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.get_state() -> bytes:
get_state:
    // smart_contracts/xgov_registry/contract.py:1292
    // paused_registry=arc4.Bool(bool(self.paused_registry.value)),
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    bytec 8 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/xgov_registry/contract.py:1293
    // paused_proposals=arc4.Bool(bool(self.paused_proposals.value)),
    intc_0 // 0
    bytec 10 // 0x7061757365645f70726f706f73616c73
    app_global_get_ex
    assert // check self.paused_proposals exists
    bytec 8 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/xgov_registry/contract.py:1294
    // xgov_manager=self.xgov_manager.value,
    intc_0 // 0
    bytec 5 // 0x78676f765f6d616e61676572
    app_global_get_ex
    assert // check self.xgov_manager exists
    // smart_contracts/xgov_registry/contract.py:1295
    // xgov_payor=self.xgov_payor.value,
    intc_0 // 0
    bytec 14 // 0x78676f765f7061796f72
    app_global_get_ex
    assert // check self.xgov_payor exists
    // smart_contracts/xgov_registry/contract.py:1296
    // xgov_council=self.xgov_council.value,
    intc_0 // 0
    bytec 22 // 0x78676f765f636f756e63696c
    app_global_get_ex
    assert // check self.xgov_council exists
    // smart_contracts/xgov_registry/contract.py:1297
    // xgov_subscriber=self.xgov_subscriber.value,
    intc_0 // 0
    bytec 13 // 0x78676f765f73756273637269626572
    app_global_get_ex
    assert // check self.xgov_subscriber exists
    // smart_contracts/xgov_registry/contract.py:1298
    // kyc_provider=self.kyc_provider.value,
    intc_0 // 0
    bytec 15 // 0x6b79635f70726f7669646572
    app_global_get_ex
    assert // check self.kyc_provider exists
    // smart_contracts/xgov_registry/contract.py:1299
    // committee_manager=self.committee_manager.value,
    intc_0 // 0
    bytec 16 // 0x636f6d6d69747465655f6d616e61676572
    app_global_get_ex
    assert // check self.committee_manager exists
    // smart_contracts/xgov_registry/contract.py:1300
    // xgov_daemon=self.xgov_daemon.value,
    intc_0 // 0
    bytec 17 // 0x78676f765f6461656d6f6e
    app_global_get_ex
    assert // check self.xgov_daemon exists
    // smart_contracts/xgov_registry/contract.py:1301
    // xgov_fee=arc4.UInt64(self.xgov_fee.value),
    intc_0 // 0
    bytec 18 // 0x78676f765f666565
    app_global_get_ex
    assert // check self.xgov_fee exists
    itob
    // smart_contracts/xgov_registry/contract.py:1302
    // proposer_fee=arc4.UInt64(self.proposer_fee.value),
    intc_0 // 0
    bytec 19 // 0x70726f706f7365725f666565
    app_global_get_ex
    assert // check self.proposer_fee exists
    itob
    // smart_contracts/xgov_registry/contract.py:1303
    // open_proposal_fee=arc4.UInt64(self.open_proposal_fee.value),
    intc_0 // 0
    bytec 11 // 0x6f70656e5f70726f706f73616c5f666565
    app_global_get_ex
    assert // check self.open_proposal_fee exists
    itob
    // smart_contracts/xgov_registry/contract.py:1304
    // daemon_ops_funding_bps=arc4.UInt64(self.daemon_ops_funding_bps.value),
    intc_0 // 0
    bytec 23 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    app_global_get_ex
    assert // check self.daemon_ops_funding_bps exists
    itob
    // smart_contracts/xgov_registry/contract.py:1305
    // proposal_commitment_bps=arc4.UInt64(self.proposal_commitment_bps.value),
    intc_0 // 0
    bytec 24 // 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    app_global_get_ex
    assert // check self.proposal_commitment_bps exists
    itob
    // smart_contracts/xgov_registry/contract.py:1306
    // min_requested_amount=arc4.UInt64(self.min_requested_amount.value),
    intc_0 // 0
    bytec 25 // 0x6d696e5f7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.min_requested_amount exists
    itob
    // smart_contracts/xgov_registry/contract.py:1308
    // arc4.UInt64(self.max_requested_amount_small.value),
    intc_0 // 0
    bytec 26 // 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    app_global_get_ex
    assert // check self.max_requested_amount_small exists
    itob
    // smart_contracts/xgov_registry/contract.py:1309
    // arc4.UInt64(self.max_requested_amount_medium.value),
    intc_0 // 0
    bytec 27 // 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    app_global_get_ex
    assert // check self.max_requested_amount_medium exists
    itob
    // smart_contracts/xgov_registry/contract.py:1310
    // arc4.UInt64(self.max_requested_amount_large.value),
    intc_0 // 0
    bytec 28 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    app_global_get_ex
    assert // check self.max_requested_amount_large exists
    itob
    // smart_contracts/xgov_registry/contract.py:1307-1311
    // max_requested_amount=arc4.StaticArray[arc4.UInt64, t.Literal[3]](
    //     arc4.UInt64(self.max_requested_amount_small.value),
    //     arc4.UInt64(self.max_requested_amount_medium.value),
    //     arc4.UInt64(self.max_requested_amount_large.value),
    // ),
    cover 2
    concat
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:1313
    // arc4.UInt64(self.discussion_duration_small.value),
    intc_0 // 0
    bytec 29 // 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    app_global_get_ex
    assert // check self.discussion_duration_small exists
    itob
    // smart_contracts/xgov_registry/contract.py:1314
    // arc4.UInt64(self.discussion_duration_medium.value),
    intc_0 // 0
    bytec 30 // 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    app_global_get_ex
    assert // check self.discussion_duration_medium exists
    itob
    // smart_contracts/xgov_registry/contract.py:1315
    // arc4.UInt64(self.discussion_duration_large.value),
    intc_0 // 0
    bytec 31 // 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    app_global_get_ex
    assert // check self.discussion_duration_large exists
    itob
    // smart_contracts/xgov_registry/contract.py:1316
    // arc4.UInt64(self.discussion_duration_xlarge.value),
    intc_0 // 0
    bytec 32 // 0x64697363757373696f6e5f6475726174696f6e5f786c61726765
    app_global_get_ex
    assert // check self.discussion_duration_xlarge exists
    itob
    // smart_contracts/xgov_registry/contract.py:1312-1317
    // discussion_duration=arc4.StaticArray[arc4.UInt64, t.Literal[4]](
    //     arc4.UInt64(self.discussion_duration_small.value),
    //     arc4.UInt64(self.discussion_duration_medium.value),
    //     arc4.UInt64(self.discussion_duration_large.value),
    //     arc4.UInt64(self.discussion_duration_xlarge.value),
    // ),
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:1319
    // arc4.UInt64(self.voting_duration_small.value),
    intc_0 // 0
    bytec 33 // 0x766f74696e675f6475726174696f6e5f736d616c6c
    app_global_get_ex
    assert // check self.voting_duration_small exists
    itob
    // smart_contracts/xgov_registry/contract.py:1320
    // arc4.UInt64(self.voting_duration_medium.value),
    intc_0 // 0
    bytec 34 // 0x766f74696e675f6475726174696f6e5f6d656469756d
    app_global_get_ex
    assert // check self.voting_duration_medium exists
    itob
    // smart_contracts/xgov_registry/contract.py:1321
    // arc4.UInt64(self.voting_duration_large.value),
    intc_0 // 0
    bytec 35 // 0x766f74696e675f6475726174696f6e5f6c61726765
    app_global_get_ex
    assert // check self.voting_duration_large exists
    itob
    // smart_contracts/xgov_registry/contract.py:1322
    // arc4.UInt64(self.voting_duration_xlarge.value),
    intc_0 // 0
    bytec 36 // 0x766f74696e675f6475726174696f6e5f786c61726765
    app_global_get_ex
    assert // check self.voting_duration_xlarge exists
    itob
    // smart_contracts/xgov_registry/contract.py:1318-1323
    // voting_duration=arc4.StaticArray[arc4.UInt64, t.Literal[4]](
    //     arc4.UInt64(self.voting_duration_small.value),
    //     arc4.UInt64(self.voting_duration_medium.value),
    //     arc4.UInt64(self.voting_duration_large.value),
    //     arc4.UInt64(self.voting_duration_xlarge.value),
    // ),
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:1325
    // arc4.UInt64(self.quorum_small.value),
    intc_0 // 0
    bytec 37 // 0x71756f72756d5f736d616c6c
    app_global_get_ex
    assert // check self.quorum_small exists
    itob
    // smart_contracts/xgov_registry/contract.py:1326
    // arc4.UInt64(self.quorum_medium.value),
    intc_0 // 0
    bytec 38 // 0x71756f72756d5f6d656469756d
    app_global_get_ex
    assert // check self.quorum_medium exists
    itob
    // smart_contracts/xgov_registry/contract.py:1327
    // arc4.UInt64(self.quorum_large.value),
    intc_0 // 0
    bytec 39 // 0x71756f72756d5f6c61726765
    app_global_get_ex
    assert // check self.quorum_large exists
    itob
    // smart_contracts/xgov_registry/contract.py:1324-1328
    // quorum=arc4.StaticArray[arc4.UInt64, t.Literal[3]](
    //     arc4.UInt64(self.quorum_small.value),
    //     arc4.UInt64(self.quorum_medium.value),
    //     arc4.UInt64(self.quorum_large.value),
    // ),
    cover 2
    concat
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:1330
    // arc4.UInt64(self.weighted_quorum_small.value),
    intc_0 // 0
    bytec 40 // 0x77656967687465645f71756f72756d5f736d616c6c
    app_global_get_ex
    assert // check self.weighted_quorum_small exists
    itob
    // smart_contracts/xgov_registry/contract.py:1331
    // arc4.UInt64(self.weighted_quorum_medium.value),
    intc_0 // 0
    bytec 41 // 0x77656967687465645f71756f72756d5f6d656469756d
    app_global_get_ex
    assert // check self.weighted_quorum_medium exists
    itob
    // smart_contracts/xgov_registry/contract.py:1332
    // arc4.UInt64(self.weighted_quorum_large.value),
    intc_0 // 0
    bytec 42 // 0x77656967687465645f71756f72756d5f6c61726765
    app_global_get_ex
    assert // check self.weighted_quorum_large exists
    itob
    // smart_contracts/xgov_registry/contract.py:1329-1333
    // weighted_quorum=arc4.StaticArray[arc4.UInt64, t.Literal[3]](
    //     arc4.UInt64(self.weighted_quorum_small.value),
    //     arc4.UInt64(self.weighted_quorum_medium.value),
    //     arc4.UInt64(self.weighted_quorum_large.value),
    // ),
    cover 2
    concat
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:1334
    // outstanding_funds=arc4.UInt64(self.outstanding_funds.value),
    intc_0 // 0
    bytec_3 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    itob
    // smart_contracts/xgov_registry/contract.py:1335
    // pending_proposals=arc4.UInt64(self.pending_proposals.value),
    intc_0 // 0
    bytec 7 // 0x70656e64696e675f70726f706f73616c73
    app_global_get_ex
    assert // check self.pending_proposals exists
    itob
    // smart_contracts/xgov_registry/contract.py:1336
    // committee_id=self.committee_id.value.copy(),
    intc_0 // 0
    bytec 49 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    // smart_contracts/xgov_registry/contract.py:1337
    // committee_members=arc4.UInt64(self.committee_members.value),
    intc_0 // 0
    bytec 43 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    itob
    // smart_contracts/xgov_registry/contract.py:1338
    // committee_votes=arc4.UInt64(self.committee_votes.value),
    intc_0 // 0
    bytec 44 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    itob
    // smart_contracts/xgov_registry/contract.py:1291-1339
    // return typ.TypedGlobalState(
    //     paused_registry=arc4.Bool(bool(self.paused_registry.value)),
    //     paused_proposals=arc4.Bool(bool(self.paused_proposals.value)),
    //     xgov_manager=self.xgov_manager.value,
    //     xgov_payor=self.xgov_payor.value,
    //     xgov_council=self.xgov_council.value,
    //     xgov_subscriber=self.xgov_subscriber.value,
    //     kyc_provider=self.kyc_provider.value,
    //     committee_manager=self.committee_manager.value,
    //     xgov_daemon=self.xgov_daemon.value,
    //     xgov_fee=arc4.UInt64(self.xgov_fee.value),
    //     proposer_fee=arc4.UInt64(self.proposer_fee.value),
    //     open_proposal_fee=arc4.UInt64(self.open_proposal_fee.value),
    //     daemon_ops_funding_bps=arc4.UInt64(self.daemon_ops_funding_bps.value),
    //     proposal_commitment_bps=arc4.UInt64(self.proposal_commitment_bps.value),
    //     min_requested_amount=arc4.UInt64(self.min_requested_amount.value),
    //     max_requested_amount=arc4.StaticArray[arc4.UInt64, t.Literal[3]](
    //         arc4.UInt64(self.max_requested_amount_small.value),
    //         arc4.UInt64(self.max_requested_amount_medium.value),
    //         arc4.UInt64(self.max_requested_amount_large.value),
    //     ),
    //     discussion_duration=arc4.StaticArray[arc4.UInt64, t.Literal[4]](
    //         arc4.UInt64(self.discussion_duration_small.value),
    //         arc4.UInt64(self.discussion_duration_medium.value),
    //         arc4.UInt64(self.discussion_duration_large.value),
    //         arc4.UInt64(self.discussion_duration_xlarge.value),
    //     ),
    //     voting_duration=arc4.StaticArray[arc4.UInt64, t.Literal[4]](
    //         arc4.UInt64(self.voting_duration_small.value),
    //         arc4.UInt64(self.voting_duration_medium.value),
    //         arc4.UInt64(self.voting_duration_large.value),
    //         arc4.UInt64(self.voting_duration_xlarge.value),
    //     ),
    //     quorum=arc4.StaticArray[arc4.UInt64, t.Literal[3]](
    //         arc4.UInt64(self.quorum_small.value),
    //         arc4.UInt64(self.quorum_medium.value),
    //         arc4.UInt64(self.quorum_large.value),
    //     ),
    //     weighted_quorum=arc4.StaticArray[arc4.UInt64, t.Literal[3]](
    //         arc4.UInt64(self.weighted_quorum_small.value),
    //         arc4.UInt64(self.weighted_quorum_medium.value),
    //         arc4.UInt64(self.weighted_quorum_large.value),
    //     ),
    //     outstanding_funds=arc4.UInt64(self.outstanding_funds.value),
    //     pending_proposals=arc4.UInt64(self.pending_proposals.value),
    //     committee_id=self.committee_id.value.copy(),
    //     committee_members=arc4.UInt64(self.committee_members.value),
    //     committee_votes=arc4.UInt64(self.committee_votes.value),
    // )
    uncover 23
    intc_0 // 0
    getbit
    uncover 24
    intc_1 // 1
    uncover 2
    setbit
    uncover 23
    concat
    uncover 22
    concat
    uncover 21
    concat
    uncover 20
    concat
    uncover 19
    concat
    uncover 18
    concat
    uncover 17
    concat
    uncover 16
    concat
    uncover 15
    concat
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.get_xgov_box(xgov_address: bytes) -> bytes:
get_xgov_box:
    // smart_contracts/xgov_registry/contract.py:1341-1342
    // @arc4.abimethod(readonly=True)
    // def get_xgov_box(self, xgov_address: arc4.Address) -> typ.XGovBoxValue:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:1352
    // return self.xgov_box[xgov_address.native].copy()
    bytec 4 // 0x78
    frame_dig -1
    concat
    box_get
    assert // check self.xgov_box entry exists
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.get_proposer_box(proposer_address: bytes) -> bytes:
get_proposer_box:
    // smart_contracts/xgov_registry/contract.py:1354-1355
    // @arc4.abimethod(readonly=True)
    // def get_proposer_box(self, proposer_address: arc4.Address) -> typ.ProposerBoxValue:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:1365
    // return self.proposer_box[proposer_address.native].copy()
    bytec_2 // 0x70
    frame_dig -1
    concat
    box_get
    assert // check self.proposer_box entry exists
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.get_request_box(request_id: bytes) -> bytes:
get_request_box:
    // smart_contracts/xgov_registry/contract.py:1367-1370
    // @arc4.abimethod(readonly=True)
    // def get_request_box(
    //     self, request_id: arc4.UInt64
    // ) -> typ.XGovSubscribeRequestBoxValue:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:1380
    // return self.request_box[request_id.native].copy()
    frame_dig -1
    btoi
    itob
    bytec 20 // 0x72
    swap
    concat
    box_get
    assert // check self.request_box entry exists
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.is_proposal(proposal_id: bytes) -> void:
is_proposal:
    // smart_contracts/xgov_registry/contract.py:1382-1383
    // @arc4.abimethod()
    // def is_proposal(self, proposal_id: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:1384
    // assert self._is_proposal(proposal_id.native), err.INVALID_PROPOSAL
    frame_dig -1
    btoi
    callsub _is_proposal
    assert // Invalid proposal
    retsub
