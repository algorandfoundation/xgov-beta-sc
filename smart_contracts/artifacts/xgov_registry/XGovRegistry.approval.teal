#pragma version 10
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 8 2048
    bytecblock 0x7061757365645f7265676973747279 0x78 0x151f7c75 0x70 0x6f75747374616e64696e675f66756e6473 0x7061 0x78676f765f6d616e61676572 0x00 0x70656e64696e675f70726f706f73616c73 0x7061757365645f70726f706f73616c73 0x78676f7673 0x726571756573745f6964 "Wrong Proposal Status or finalized" "ERR:" 0x78676f765f73756273637269626572 0x78676f765f7061796f72 0x6b79635f70726f7669646572 0x636f6d6d69747465655f6d616e61676572 0x78676f765f6461656d6f6e 0x78676f765f666565 0x70726f706f7365725f666565 0x6f70656e5f70726f706f73616c5f666565 0x616273656e63655f746f6c6572616e6365 0x72 0x7275 0x78676f765f636f756e63696c 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073 0x70726f706f73616c5f636f6d6d69746d656e745f627073 0x6d696e5f7265717565737465645f616d6f756e74 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d 0x6d61785f7265717565737465645f616d6f756e745f6c61726765 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d 0x64697363757373696f6e5f6475726174696f6e5f6c61726765 0x64697363757373696f6e5f6475726174696f6e5f786c61726765 0x766f74696e675f6475726174696f6e5f736d616c6c 0x766f74696e675f6475726174696f6e5f6d656469756d 0x766f74696e675f6475726174696f6e5f6c61726765 0x766f74696e675f6475726174696f6e5f786c61726765 0x71756f72756d5f736d616c6c 0x71756f72756d5f6d656469756d 0x71756f72756d5f6c61726765 0x77656967687465645f71756f72756d5f736d616c6c 0x77656967687465645f71756f72756d5f6d656469756d 0x77656967687465645f71756f72756d5f6c61726765 0x636f6d6d69747465655f6d656d62657273 0x636f6d6d69747465655f766f746573 0x6d61785f636f6d6d69747465655f73697a65 0x676f7665726e616e63655f706572696f64 0x636f6d6d69747465655f67726163655f706572696f64 0x636f6d6d69747465655f6c6173745f616e63686f72 0x000000000000000000 0x636f6d6d69747465655f6964 "Voter not found" base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) TMPL_entropy
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/xgov_registry/contract.py:57-58
    // # Preconditions
    // assert Txn.global_num_byte_slice == cfg.GLOBAL_BYTES, err.WRONG_GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 28
    ==
    assert // Wrong Global Bytes allocation
    // smart_contracts/xgov_registry/contract.py:59
    // assert Txn.global_num_uint == cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    pushint 36
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/xgov_registry/contract.py:60
    // assert Txn.local_num_byte_slice == cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/xgov_registry/contract.py:61
    // assert Txn.local_num_uint == cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/xgov_registry/contract.py:63-64
    // # Role-Based Access Control (RBAC)
    // self.xgov_manager = GlobalState(Account(), key=cfg.GS_KEY_XGOV_MANAGER)
    bytec 6 // 0x78676f765f6d616e61676572
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:65
    // self.xgov_subscriber = GlobalState(Account(), key=cfg.GS_KEY_XGOV_SUBSCRIBER)
    bytec 14 // 0x78676f765f73756273637269626572
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:66
    // self.xgov_payor = GlobalState(Account(), key=cfg.GS_KEY_XGOV_PAYOR)
    bytec 15 // 0x78676f765f7061796f72
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:67
    // self.xgov_council = GlobalState(Account(), key=cfg.GS_KEY_XGOV_COUNCIL)
    bytec 25 // 0x78676f765f636f756e63696c
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:68
    // self.kyc_provider = GlobalState(Account(), key=cfg.GS_KEY_KYC_PROVIDER)
    bytec 16 // 0x6b79635f70726f7669646572
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:70
    // Account(), key=cfg.GS_KEY_COMMITTEE_MANAGER
    bytec 17 // 0x636f6d6d69747465655f6d616e61676572
    global ZeroAddress
    // smart_contracts/xgov_registry/contract.py:69-71
    // self.committee_manager = GlobalState(
    //     Account(), key=cfg.GS_KEY_COMMITTEE_MANAGER
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:72
    // self.xgov_daemon = GlobalState(Account(), key=cfg.GS_KEY_XGOV_DAEMON)
    bytec 18 // 0x78676f765f6461656d6f6e
    global ZeroAddress
    app_global_put
    // smart_contracts/xgov_registry/contract.py:76
    // False, key=cfg.GS_KEY_PAUSED_REGISTRY  # noqa: FBT003
    bytec_0 // 0x7061757365645f7265676973747279
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:74-77
    // # Registry Control States
    // self.paused_registry = GlobalState(
    //     False, key=cfg.GS_KEY_PAUSED_REGISTRY  # noqa: FBT003
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:79
    // False, key=cfg.GS_KEY_PAUSED_PROPOSALS  # noqa: FBT003
    bytec 9 // 0x7061757365645f70726f706f73616c73
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:78-80
    // self.paused_proposals = GlobalState(
    //     False, key=cfg.GS_KEY_PAUSED_PROPOSALS  # noqa: FBT003
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:82-83
    // # xGov Treasury
    // self.outstanding_funds = GlobalState(UInt64(), key=cfg.GS_KEY_OUTSTANDING_FUNDS)
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:85-86
    // # Fees
    // self.xgov_fee = GlobalState(UInt64(), key=cfg.GS_KEY_XGOV_FEE)
    bytec 19 // 0x78676f765f666565
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:87
    // self.proposer_fee = GlobalState(UInt64(), key=cfg.GS_KEY_PROPOSER_FEE)
    bytec 20 // 0x70726f706f7365725f666565
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:88
    // self.open_proposal_fee = GlobalState(UInt64(), key=cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    bytec 21 // 0x6f70656e5f70726f706f73616c5f666565
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:90
    // UInt64(), key=cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS
    bytec 26 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:89-91
    // self.daemon_ops_funding_bps = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:93
    // UInt64(), key=cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS
    bytec 27 // 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:92-94
    // self.proposal_commitment_bps = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:98
    // UInt64(), key=cfg.GS_KEY_MIN_REQUESTED_AMOUNT
    bytec 28 // 0x6d696e5f7265717565737465645f616d6f756e74
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:96-99
    // # Requested Amount Limits
    // self.min_requested_amount = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MIN_REQUESTED_AMOUNT
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:102
    // UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL
    bytec 29 // 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:101-103
    // self.max_requested_amount_small = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:105
    // UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM
    bytec 30 // 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:104-106
    // self.max_requested_amount_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:108
    // UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE
    bytec 31 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:107-109
    // self.max_requested_amount_large = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:113
    // UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_SMALL
    bytec 32 // 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:111-114
    // # Time Limits
    // self.discussion_duration_small = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_SMALL
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:116
    // UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM
    bytec 33 // 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:115-117
    // self.discussion_duration_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:119
    // UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_LARGE
    bytec 34 // 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:118-120
    // self.discussion_duration_large = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_LARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:122
    // UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_XLARGE
    bytec 35 // 0x64697363757373696f6e5f6475726174696f6e5f786c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:121-123
    // self.discussion_duration_xlarge = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_DISCUSSION_DURATION_XLARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:125
    // UInt64(), key=cfg.GS_KEY_VOTING_DURATION_SMALL
    bytec 36 // 0x766f74696e675f6475726174696f6e5f736d616c6c
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:124-126
    // self.voting_duration_small = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_VOTING_DURATION_SMALL
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:128
    // UInt64(), key=cfg.GS_KEY_VOTING_DURATION_MEDIUM
    bytec 37 // 0x766f74696e675f6475726174696f6e5f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:127-129
    // self.voting_duration_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_VOTING_DURATION_MEDIUM
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:131
    // UInt64(), key=cfg.GS_KEY_VOTING_DURATION_LARGE
    bytec 38 // 0x766f74696e675f6475726174696f6e5f6c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:130-132
    // self.voting_duration_large = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_VOTING_DURATION_LARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:134
    // UInt64(), key=cfg.GS_KEY_VOTING_DURATION_XLARGE
    bytec 39 // 0x766f74696e675f6475726174696f6e5f786c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:133-135
    // self.voting_duration_xlarge = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_VOTING_DURATION_XLARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:137-138
    // # Quorums
    // self.quorum_small = GlobalState(UInt64(), key=cfg.GS_KEY_QUORUM_SMALL)
    bytec 40 // 0x71756f72756d5f736d616c6c
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:140
    // UInt64(), key=cfg.GS_KEY_QUORUM_MEDIUM
    bytec 41 // 0x71756f72756d5f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:139-141
    // self.quorum_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_QUORUM_MEDIUM
    // )  # No longer used
    app_global_put
    // smart_contracts/xgov_registry/contract.py:142
    // self.quorum_large = GlobalState(UInt64(), key=cfg.GS_KEY_QUORUM_LARGE)
    bytec 42 // 0x71756f72756d5f6c61726765
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:146
    // UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_SMALL
    bytec 43 // 0x77656967687465645f71756f72756d5f736d616c6c
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:144-147
    // # Weighted Quorums
    // self.weighted_quorum_small = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_SMALL
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:149
    // UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM  # No longer used
    bytec 44 // 0x77656967687465645f71756f72756d5f6d656469756d
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:148-150
    // self.weighted_quorum_medium = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM  # No longer used
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:152
    // UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_LARGE
    bytec 45 // 0x77656967687465645f71756f72756d5f6c61726765
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:151-153
    // self.weighted_quorum_large = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_WEIGHTED_QUORUM_LARGE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:157
    // self.committee_members = GlobalState(UInt64(), key=cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 46 // 0x636f6d6d69747465655f6d656d62657273
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:158
    // self.committee_votes = GlobalState(UInt64(), key=cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 47 // 0x636f6d6d69747465655f766f746573
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:160
    // UInt64(), key=cfg.GS_KEY_MAX_COMMITTEE_SIZE
    bytec 48 // 0x6d61785f636f6d6d69747465655f73697a65
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:159-161
    // self.max_committee_size = GlobalState(
    //     UInt64(), key=cfg.GS_KEY_MAX_COMMITTEE_SIZE
    // )
    app_global_put
    // smart_contracts/xgov_registry/contract.py:163-164
    // # Counters
    // self.xgovs = GlobalState(UInt64(), key=cfg.GS_KEY_XGOVS)
    bytec 10 // 0x78676f7673
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:165
    // self.pending_proposals = GlobalState(UInt64(), key=cfg.GS_KEY_PENDING_PROPOSALS)
    bytec 8 // 0x70656e64696e675f70726f706f73616c73
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:166
    // self.request_id = GlobalState(UInt64(), key=cfg.GS_KEY_REQUEST_ID)
    bytec 11 // 0x726571756573745f6964
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     XGovRegistryInterface,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x4956c1ab // method "update_xgov_registry()void"
    txna ApplicationArgs 0
    match main_update_xgov_registry_route@4

main_switch_case_next@5:
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     XGovRegistryInterface,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@52
    pushbytess 0x959c4762 0x6c1f564d 0xe10a512e 0x86f7e0e6 0x39e26d8a 0x98352e86 0xfa4ed6e2 0xd6c9cc1a 0x5c484055 0x37d6adf1 0xd4216b6e 0xba8520f2 0x1677b30e 0x84b7d268 0xaf7f1860 0xa082cef8 0xdf39fdb9 0xca0f6a3a 0x45077390 0x3c31bc02 0x0d2c7891 0x93facdba 0xce8b3a1c 0xfaea081f 0x0da27885 0x7a4fee43 0x52dd10d7 0xd4d37a64 0x34349dcc 0x158f8dd6 0x5fe25935 0xdb27b9af 0xf5910756 0x65610a9f 0xfdc695c2 0xba90ab54 0xb3b58482 0x6ae5eb46 0x27630d65 0x824f98bc 0x49548ba0 0x826784f6 0x26983200 0xdbd83dd9 // method "init_proposal_contract(uint64)void", method "load_proposal_contract(uint64,byte[])void", method "delete_proposal_contract_box()void", method "pause_registry()void", method "pause_proposals()void", method "resume_registry()void", method "resume_proposals()void", method "set_xgov_manager(address)void", method "set_payor(address)void", method "set_xgov_council(address)void", method "set_xgov_subscriber(address)void", method "set_kyc_provider(address)void", method "set_committee_manager(address)void", method "set_xgov_daemon(address)void", method "config_xgov_registry((uint64,uint64,uint64,uint64,uint64,uint64,uint64[3],uint64[4],uint64[4],uint64[3],uint64[3],uint64,uint64,uint64))void", method "subscribe_xgov(address,pay)void", method "unsubscribe_xgov()void", method "unsubscribe_absentee(address)void", method "request_subscribe_xgov(address,address,uint64,pay)void", method "approve_subscribe_xgov(uint64)void", method "reject_subscribe_xgov(uint64)void", method "request_unsubscribe_xgov(address,address,uint64,pay)void", method "approve_unsubscribe_xgov(uint64)void", method "reject_unsubscribe_xgov(uint64)void", method "set_voting_account(address,address)void", method "subscribe_proposer(pay)void", method "set_proposer_kyc(address,bool,uint64)void", method "declare_committee(byte[32],uint64,uint64)void", method "open_proposal(pay)uint64", method "vote_proposal(uint64,address,uint64,uint64)void", method "unassign_absentee_from_proposal(uint64,address[])void", method "pay_grant_proposal(uint64)void", method "finalize_proposal(uint64)void", method "drop_proposal(uint64)void", method "deposit_funds(pay)void", method "withdraw_funds(uint64)void", method "withdraw_balance()void", method "get_state()(bool,bool,address,address,address,address,address,address,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64[3],uint64[4],uint64[4],uint64[3],uint64[3],uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)", method "get_xgov_box(address)((address,uint64,uint64,uint64),bool)", method "get_proposer_box(address)((bool,bool,uint64),bool)", method "get_request_box(uint64)((address,address,uint64),bool)", method "get_request_unsubscribe_box(uint64)((address,address,uint64),bool)", method "is_proposal(uint64)void", method "op_up()void"
    txna ApplicationArgs 0
    match init_proposal_contract load_proposal_contract delete_proposal_contract_box pause_registry pause_proposals resume_registry resume_proposals set_xgov_manager set_payor set_xgov_council set_xgov_subscriber set_kyc_provider set_committee_manager set_xgov_daemon config_xgov_registry subscribe_xgov unsubscribe_xgov unsubscribe_absentee request_subscribe_xgov approve_subscribe_xgov reject_subscribe_xgov request_unsubscribe_xgov approve_unsubscribe_xgov reject_unsubscribe_xgov set_voting_account subscribe_proposer set_proposer_kyc declare_committee open_proposal vote_proposal unassign_absentee_from_proposal pay_grant_proposal finalize_proposal drop_proposal deposit_funds withdraw_funds withdraw_balance get_state get_xgov_box get_proposer_box get_request_box get_request_unsubscribe_box is_proposal main_op_up_route@50
    err

main_op_up_route@50:
    // smart_contracts/xgov_registry/contract.py:1704
    // @arc4.abimethod()
    intc_1 // 1
    return

main_create_NoOp@52:
    // smart_contracts/xgov_registry/contract.py:45-53
    // class XGovRegistry(
    //     XGovRegistryInterface,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x4c5c61ba // method "create()void"
    txna ApplicationArgs 0
    match create
    err

main_update_xgov_registry_route@4:
    // smart_contracts/xgov_registry/contract.py:720
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert
    b update_xgov_registry


// smart_contracts.xgov_registry.contract.XGovRegistry.create[routing]() -> void:
create:
    // smart_contracts/xgov_registry/contract.py:401
    // self.xgov_manager.value = Txn.sender
    bytec 6 // 0x78676f765f6d616e61676572
    txn Sender
    app_global_put
    // smart_contracts/xgov_registry/contract.py:212
    // return TemplateVar[Bytes]("entropy")  # trick to allow fresh deployment
    bytec 56 // TMPL_entropy
    // smart_contracts/xgov_registry/contract.py:402
    // assert self.entropy() == TemplateVar[Bytes]("entropy")
    dup
    ==
    assert
    // smart_contracts/xgov_registry/contract.py:395
    // @arc4.abimethod(create="require")
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.init_proposal_contract[routing]() -> void:
init_proposal_contract:
    // smart_contracts/xgov_registry/contract.py:404
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:416
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:418
    // if self.proposal_approval_program:
    bytec 5 // 0x7061
    box_len
    bury 1
    bz init_proposal_contract_else_body@3
    // smart_contracts/xgov_registry/contract.py:419
    // self.proposal_approval_program.resize(size)
    bytec 5 // 0x7061
    swap
    box_resize

init_proposal_contract_after_if_else@4:
    // smart_contracts/xgov_registry/contract.py:404
    // @arc4.abimethod()
    intc_1 // 1
    return

init_proposal_contract_else_body@3:
    // smart_contracts/xgov_registry/contract.py:421-422
    // # Initialize the Proposal Approval Program contract
    // _created = self.proposal_approval_program.create(size=size)
    bytec 5 // 0x7061
    swap
    box_create
    pop
    b init_proposal_contract_after_if_else@4


// smart_contracts.xgov_registry.contract.XGovRegistry.load_proposal_contract[routing]() -> void:
load_proposal_contract:
    // smart_contracts/xgov_registry/contract.py:424
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/xgov_registry/contract.py:437
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:439-440
    // # Load the Proposal Approval Program contract
    // self.proposal_approval_program.replace(start_index=offset, value=data)
    bytec 5 // 0x7061
    cover 2
    box_replace
    // smart_contracts/xgov_registry/contract.py:424
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.delete_proposal_contract_box[routing]() -> void:
delete_proposal_contract_box:
    // smart_contracts/xgov_registry/contract.py:451
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:453-454
    // # Delete the Proposal Approval Program contract box
    // del self.proposal_approval_program.value
    bytec 5 // 0x7061
    box_del
    pop
    // smart_contracts/xgov_registry/contract.py:442
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.pause_registry[routing]() -> void:
pause_registry:
    // smart_contracts/xgov_registry/contract.py:462
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:463
    // self.paused_registry.value = True
    bytec_0 // 0x7061757365645f7265676973747279
    intc_1 // 1
    app_global_put
    // smart_contracts/xgov_registry/contract.py:456
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.pause_proposals[routing]() -> void:
pause_proposals:
    // smart_contracts/xgov_registry/contract.py:471
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:472
    // self.paused_proposals.value = True
    bytec 9 // 0x7061757365645f70726f706f73616c73
    intc_1 // 1
    app_global_put
    // smart_contracts/xgov_registry/contract.py:465
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.resume_registry[routing]() -> void:
resume_registry:
    // smart_contracts/xgov_registry/contract.py:480
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:481
    // self.paused_registry.value = False
    bytec_0 // 0x7061757365645f7265676973747279
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:474
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.resume_proposals[routing]() -> void:
resume_proposals:
    // smart_contracts/xgov_registry/contract.py:489
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:490
    // self.paused_proposals.value = False
    bytec 9 // 0x7061757365645f70726f706f73616c73
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:483
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_xgov_manager[routing]() -> void:
set_xgov_manager:
    // smart_contracts/xgov_registry/contract.py:492
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:504
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:505
    // self.xgov_manager.value = manager
    bytec 6 // 0x78676f765f6d616e61676572
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:492
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_payor[routing]() -> void:
set_payor:
    // smart_contracts/xgov_registry/contract.py:507
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:519
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:520
    // self.xgov_payor.value = payor
    bytec 15 // 0x78676f765f7061796f72
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:507
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_xgov_council[routing]() -> void:
set_xgov_council:
    // smart_contracts/xgov_registry/contract.py:522
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:534
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:535
    // self.xgov_council.value = council
    bytec 25 // 0x78676f765f636f756e63696c
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:522
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_xgov_subscriber[routing]() -> void:
set_xgov_subscriber:
    // smart_contracts/xgov_registry/contract.py:537
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:549
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:550
    // self.xgov_subscriber.value = subscriber
    bytec 14 // 0x78676f765f73756273637269626572
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:537
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_kyc_provider[routing]() -> void:
set_kyc_provider:
    // smart_contracts/xgov_registry/contract.py:552
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:564
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:565
    // self.kyc_provider.value = provider
    bytec 16 // 0x6b79635f70726f7669646572
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:552
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_committee_manager[routing]() -> void:
set_committee_manager:
    // smart_contracts/xgov_registry/contract.py:567
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:579
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:580
    // self.committee_manager.value = manager
    bytec 17 // 0x636f6d6d69747465655f6d616e61676572
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:567
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_xgov_daemon[routing]() -> void:
set_xgov_daemon:
    // smart_contracts/xgov_registry/contract.py:582
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:594
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:595
    // self.xgov_daemon.value = xgov_daemon
    bytec 18 // 0x78676f765f6461656d6f6e
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:582
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.config_xgov_registry[routing]() -> void:
config_xgov_registry:
    intc_0 // 0
    dupn 4
    pushbytes ""
    dupn 13
    // smart_contracts/xgov_registry/contract.py:597
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    len
    pushint 208
    ==
    assert // invalid number of bytes for smart_contracts.common.abi_types.XGovRegistryConfig
    // smart_contracts/xgov_registry/contract.py:609
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:638
    // config.xgov_fee >= xgov_box_mbr and config.xgov_fee >= xgov_request_box_mbr
    intc_0 // 0
    extract_uint64
    dup
    // smart_contracts/xgov_registry/contract.py:292-294
    // return (
    //     key_prefix_length + key_type_size + value_type_size
    // ) * PER_BYTE_IN_BOX_MBR + PER_BOX_MBR
    pushint 38100
    // smart_contracts/xgov_registry/contract.py:638
    // config.xgov_fee >= xgov_box_mbr and config.xgov_fee >= xgov_request_box_mbr
    >=
    bz config_xgov_registry_bool_false@4
    dup
    // smart_contracts/xgov_registry/contract.py:292-294
    // return (
    //     key_prefix_length + key_type_size + value_type_size
    // ) * PER_BYTE_IN_BOX_MBR + PER_BOX_MBR
    pushint 34900
    // smart_contracts/xgov_registry/contract.py:638
    // config.xgov_fee >= xgov_box_mbr and config.xgov_fee >= xgov_request_box_mbr
    >=
    bz config_xgov_registry_bool_false@4
    intc_1 // 1

config_xgov_registry_bool_merge@5:
    // smart_contracts/xgov_registry/contract.py:637-639
    // assert (
    //     config.xgov_fee >= xgov_box_mbr and config.xgov_fee >= xgov_request_box_mbr
    // ), err.INVALID_XGOV_FEE
    assert // Invalid xGov fee
    // smart_contracts/xgov_registry/contract.py:641
    // assert config.proposer_fee >= proposer_box_mbr, err.INVALID_PROPOSER_FEE
    dig 1
    dup
    intc_3 // 8
    extract_uint64
    dup
    bury 9
    // smart_contracts/xgov_registry/contract.py:292-294
    // return (
    //     key_prefix_length + key_type_size + value_type_size
    // ) * PER_BYTE_IN_BOX_MBR + PER_BOX_MBR
    pushint 19300
    // smart_contracts/xgov_registry/contract.py:641
    // assert config.proposer_fee >= proposer_box_mbr, err.INVALID_PROPOSER_FEE
    >=
    assert // Invalid proposer fee
    // smart_contracts/xgov_registry/contract.py:645
    // < config.min_requested_amount
    pushint 40
    extract_uint64
    dup
    bury 7
    // smart_contracts/xgov_registry/contract.py:644-646
    // 0
    // < config.min_requested_amount
    // < config.max_requested_amount[0]
    bz config_xgov_registry_bool_false@10
    // smart_contracts/xgov_registry/contract.py:646
    // < config.max_requested_amount[0]
    dig 1
    extract 48 24
    dup
    bury 19
    intc_0 // 0
    extract_uint64
    dup
    bury 6
    // smart_contracts/xgov_registry/contract.py:645-646
    // < config.min_requested_amount
    // < config.max_requested_amount[0]
    dig 6
    >
    // smart_contracts/xgov_registry/contract.py:644-646
    // 0
    // < config.min_requested_amount
    // < config.max_requested_amount[0]
    bz config_xgov_registry_bool_false@10
    // smart_contracts/xgov_registry/contract.py:647
    // < config.max_requested_amount[1]
    dig 17
    // smart_contracts/xgov_registry/contract.py:646-647
    // < config.max_requested_amount[0]
    // < config.max_requested_amount[1]
    intc_3 // 8
    // smart_contracts/xgov_registry/contract.py:647
    // < config.max_requested_amount[1]
    extract_uint64
    dup
    bury 5
    // smart_contracts/xgov_registry/contract.py:646-647
    // < config.max_requested_amount[0]
    // < config.max_requested_amount[1]
    dig 5
    >
    // smart_contracts/xgov_registry/contract.py:645-647
    // < config.min_requested_amount
    // < config.max_requested_amount[0]
    // < config.max_requested_amount[1]
    bz config_xgov_registry_bool_false@10
    // smart_contracts/xgov_registry/contract.py:648
    // < config.max_requested_amount[2]
    dig 17
    pushint 16
    extract_uint64
    // smart_contracts/xgov_registry/contract.py:647-648
    // < config.max_requested_amount[1]
    // < config.max_requested_amount[2]
    dig 4
    >
    // smart_contracts/xgov_registry/contract.py:646-648
    // < config.max_requested_amount[0]
    // < config.max_requested_amount[1]
    // < config.max_requested_amount[2]
    bz config_xgov_registry_bool_false@10
    intc_1 // 1

config_xgov_registry_bool_merge@11:
    // smart_contracts/xgov_registry/contract.py:643-649
    // assert (
    //     0
    //     < config.min_requested_amount
    //     < config.max_requested_amount[0]
    //     < config.max_requested_amount[1]
    //     < config.max_requested_amount[2]
    // ), err.INCONSISTENT_REQUESTED_AMOUNT_CONFIG
    assert // Inconsistent requested amount config
    // smart_contracts/xgov_registry/contract.py:652
    // config.open_proposal_fee,
    dig 1
    dup
    pushint 16
    extract_uint64
    dup
    cover 2
    bury 17
    // smart_contracts/xgov_registry/contract.py:653
    // config.daemon_ops_funding_bps,
    dup
    pushint 24
    extract_uint64
    dup
    bury 19
    // smart_contracts/xgov_registry/contract.py:276
    // return amount * fraction_in_bps // BPS
    dig 2
    *
    pushint 10000
    /
    // smart_contracts/xgov_registry/contract.py:320
    // UInt64(MAX_MBR_PER_APP + MAX_MBR_PER_BOX + ACCOUNT_MBR) + daemon_ops_funding
    pushint 16835300
    +
    // smart_contracts/xgov_registry/contract.py:323
    // assert open_proposal_fee > to_substract, err.INVALID_OPEN_PROPOSAL_FEE
    dig 2
    dig 1
    >
    assert // Invalid open proposal fee
    // smart_contracts/xgov_registry/contract.py:325
    // mbr_available_for_committee = open_proposal_fee - to_substract
    uncover 2
    swap
    -
    // smart_contracts/xgov_registry/contract.py:292-294
    // return (
    //     key_prefix_length + key_type_size + value_type_size
    // ) * PER_BYTE_IN_BOX_MBR + PER_BOX_MBR
    pushint 18900
    // smart_contracts/xgov_registry/contract.py:327
    // self.max_committee_size.value = mbr_available_for_committee // voter_mbr
    /
    bytec 48 // 0x6d61785f636f6d6d69747465655f73697a65
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:659
    // < config.discussion_duration[0]
    extract 72 32
    dup
    bury 18
    intc_0 // 0
    extract_uint64
    dup
    bury 4
    // smart_contracts/xgov_registry/contract.py:658-660
    // 0
    // < config.discussion_duration[0]
    // <= config.discussion_duration[1]
    bz config_xgov_registry_bool_false@16
    // smart_contracts/xgov_registry/contract.py:660
    // <= config.discussion_duration[1]
    dig 16
    // smart_contracts/xgov_registry/contract.py:659-660
    // < config.discussion_duration[0]
    // <= config.discussion_duration[1]
    intc_3 // 8
    // smart_contracts/xgov_registry/contract.py:660
    // <= config.discussion_duration[1]
    extract_uint64
    dup
    bury 15
    // smart_contracts/xgov_registry/contract.py:659-660
    // < config.discussion_duration[0]
    // <= config.discussion_duration[1]
    dig 3
    >=
    // smart_contracts/xgov_registry/contract.py:658-660
    // 0
    // < config.discussion_duration[0]
    // <= config.discussion_duration[1]
    bz config_xgov_registry_bool_false@16
    // smart_contracts/xgov_registry/contract.py:661
    // <= config.discussion_duration[2]
    dig 16
    pushint 16
    extract_uint64
    dup
    bury 14
    // smart_contracts/xgov_registry/contract.py:660-661
    // <= config.discussion_duration[1]
    // <= config.discussion_duration[2]
    dig 14
    >=
    // smart_contracts/xgov_registry/contract.py:659-661
    // < config.discussion_duration[0]
    // <= config.discussion_duration[1]
    // <= config.discussion_duration[2]
    bz config_xgov_registry_bool_false@16
    // smart_contracts/xgov_registry/contract.py:662
    // <= config.discussion_duration[3]
    dig 16
    pushint 24
    extract_uint64
    // smart_contracts/xgov_registry/contract.py:661-662
    // <= config.discussion_duration[2]
    // <= config.discussion_duration[3]
    dig 13
    >=
    // smart_contracts/xgov_registry/contract.py:660-662
    // <= config.discussion_duration[1]
    // <= config.discussion_duration[2]
    // <= config.discussion_duration[3]
    bz config_xgov_registry_bool_false@16
    intc_1 // 1

config_xgov_registry_bool_merge@17:
    // smart_contracts/xgov_registry/contract.py:657-663
    // assert (
    //     0
    //     < config.discussion_duration[0]
    //     <= config.discussion_duration[1]
    //     <= config.discussion_duration[2]
    //     <= config.discussion_duration[3]
    // ), err.INCONSISTENT_DISCUSSION_DURATION_CONFIG
    assert // Inconsistent discussion duration config
    // smart_contracts/xgov_registry/contract.py:667
    // < config.voting_duration[0]
    dig 1
    extract 104 32
    dup
    bury 22
    intc_0 // 0
    extract_uint64
    dup
    bury 13
    // smart_contracts/xgov_registry/contract.py:666-668
    // 0
    // < config.voting_duration[0]
    // <= config.voting_duration[1]
    bz config_xgov_registry_bool_false@22
    // smart_contracts/xgov_registry/contract.py:668
    // <= config.voting_duration[1]
    dig 20
    // smart_contracts/xgov_registry/contract.py:667-668
    // < config.voting_duration[0]
    // <= config.voting_duration[1]
    intc_3 // 8
    // smart_contracts/xgov_registry/contract.py:668
    // <= config.voting_duration[1]
    extract_uint64
    dup
    bury 12
    // smart_contracts/xgov_registry/contract.py:667-668
    // < config.voting_duration[0]
    // <= config.voting_duration[1]
    dig 12
    >=
    // smart_contracts/xgov_registry/contract.py:666-668
    // 0
    // < config.voting_duration[0]
    // <= config.voting_duration[1]
    bz config_xgov_registry_bool_false@22
    // smart_contracts/xgov_registry/contract.py:669
    // <= config.voting_duration[2]
    dig 20
    pushint 16
    extract_uint64
    dup
    bury 11
    // smart_contracts/xgov_registry/contract.py:668-669
    // <= config.voting_duration[1]
    // <= config.voting_duration[2]
    dig 11
    >=
    // smart_contracts/xgov_registry/contract.py:667-669
    // < config.voting_duration[0]
    // <= config.voting_duration[1]
    // <= config.voting_duration[2]
    bz config_xgov_registry_bool_false@22
    // smart_contracts/xgov_registry/contract.py:670
    // <= config.voting_duration[3]
    dig 20
    pushint 24
    extract_uint64
    // smart_contracts/xgov_registry/contract.py:669-670
    // <= config.voting_duration[2]
    // <= config.voting_duration[3]
    dig 10
    >=
    // smart_contracts/xgov_registry/contract.py:668-670
    // <= config.voting_duration[1]
    // <= config.voting_duration[2]
    // <= config.voting_duration[3]
    bz config_xgov_registry_bool_false@22
    intc_1 // 1

config_xgov_registry_bool_merge@23:
    // smart_contracts/xgov_registry/contract.py:665-671
    // assert (
    //     0
    //     < config.voting_duration[0]
    //     <= config.voting_duration[1]
    //     <= config.voting_duration[2]
    //     <= config.voting_duration[3]
    // ), err.INCONSISTENT_VOTING_DURATION_CONFIG
    assert // Inconsistent voting duration config
    // smart_contracts/xgov_registry/contract.py:675
    // < config.quorum[0]
    dig 1
    extract 136 24
    dup
    bury 21
    intc_0 // 0
    extract_uint64
    dup
    bury 10
    // smart_contracts/xgov_registry/contract.py:674-675
    // 0
    // < config.quorum[0]
    bz config_xgov_registry_bool_false@26
    // smart_contracts/xgov_registry/contract.py:676-677
    // # Quorum Medium no longer used
    // < config.quorum[2]
    dig 19
    pushint 16
    extract_uint64
    // smart_contracts/xgov_registry/contract.py:675
    // < config.quorum[0]
    dig 9
    >
    // smart_contracts/xgov_registry/contract.py:674-675
    // 0
    // < config.quorum[0]
    bz config_xgov_registry_bool_false@26
    intc_1 // 1

config_xgov_registry_bool_merge@27:
    // smart_contracts/xgov_registry/contract.py:673-678
    // assert (
    //     0
    //     < config.quorum[0]
    //     # Quorum Medium no longer used
    //     < config.quorum[2]
    // ), err.INCONSISTENT_QUORUM_CONFIG
    assert // Inconsistent quorum config
    // smart_contracts/xgov_registry/contract.py:682
    // < config.weighted_quorum[0]
    dig 1
    extract 160 24
    dup
    bury 20
    intc_0 // 0
    extract_uint64
    dup
    bury 9
    // smart_contracts/xgov_registry/contract.py:681-682
    // 0
    // < config.weighted_quorum[0]
    bz config_xgov_registry_bool_false@30
    // smart_contracts/xgov_registry/contract.py:683-684
    // # Weighted Quorum Medium no longer used
    // < config.weighted_quorum[2]
    dig 18
    pushint 16
    extract_uint64
    // smart_contracts/xgov_registry/contract.py:682
    // < config.weighted_quorum[0]
    dig 8
    >
    // smart_contracts/xgov_registry/contract.py:681-682
    // 0
    // < config.weighted_quorum[0]
    bz config_xgov_registry_bool_false@30
    intc_1 // 1

config_xgov_registry_bool_merge@31:
    // smart_contracts/xgov_registry/contract.py:680-685
    // assert (
    //     0
    //     < config.weighted_quorum[0]
    //     # Weighted Quorum Medium no longer used
    //     < config.weighted_quorum[2]
    // ), err.INCONSISTENT_WEIGHTED_QUORUM_CONFIG
    assert // Inconsistent weighted quorum config
    // smart_contracts/xgov_registry/contract.py:687
    // self.xgov_fee.value = config.xgov_fee
    bytec 19 // 0x78676f765f666565
    dig 1
    app_global_put
    // smart_contracts/xgov_registry/contract.py:688
    // self.proposer_fee.value = config.proposer_fee
    bytec 20 // 0x70726f706f7365725f666565
    dig 7
    app_global_put
    // smart_contracts/xgov_registry/contract.py:689
    // self.open_proposal_fee.value = config.open_proposal_fee
    bytec 21 // 0x6f70656e5f70726f706f73616c5f666565
    dig 15
    app_global_put
    // smart_contracts/xgov_registry/contract.py:690
    // self.daemon_ops_funding_bps.value = config.daemon_ops_funding_bps
    bytec 26 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    dig 16
    app_global_put
    // smart_contracts/xgov_registry/contract.py:691
    // self.proposal_commitment_bps.value = config.proposal_commitment_bps
    dig 1
    dup
    intc_2 // 32
    extract_uint64
    bytec 27 // 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:693
    // self.min_requested_amount.value = config.min_requested_amount
    bytec 28 // 0x6d696e5f7265717565737465645f616d6f756e74
    dig 7
    app_global_put
    // smart_contracts/xgov_registry/contract.py:694
    // self.max_requested_amount_small.value = config.max_requested_amount[0]
    dup
    extract 48 24
    dup
    intc_0 // 0
    extract_uint64
    bytec 29 // 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:695
    // self.max_requested_amount_medium.value = config.max_requested_amount[1]
    dup
    // smart_contracts/xgov_registry/contract.py:694-695
    // self.max_requested_amount_small.value = config.max_requested_amount[0]
    // self.max_requested_amount_medium.value = config.max_requested_amount[1]
    intc_3 // 8
    // smart_contracts/xgov_registry/contract.py:695
    // self.max_requested_amount_medium.value = config.max_requested_amount[1]
    extract_uint64
    bytec 30 // 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:696
    // self.max_requested_amount_large.value = config.max_requested_amount[2]
    pushint 16
    extract_uint64
    bytec 31 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:698
    // self.discussion_duration_small.value = config.discussion_duration[0]
    bytec 32 // 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    dig 4
    app_global_put
    // smart_contracts/xgov_registry/contract.py:699
    // self.discussion_duration_medium.value = config.discussion_duration[1]
    dig 17
    dup
    intc_3 // 8
    extract_uint64
    bytec 33 // 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:700
    // self.discussion_duration_large.value = config.discussion_duration[2]
    dup
    pushint 16
    extract_uint64
    bytec 34 // 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:701
    // self.discussion_duration_xlarge.value = config.discussion_duration[3]
    pushint 24
    extract_uint64
    bytec 35 // 0x64697363757373696f6e5f6475726174696f6e5f786c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:703
    // self.voting_duration_small.value = config.voting_duration[0]
    bytec 36 // 0x766f74696e675f6475726174696f6e5f736d616c6c
    dig 13
    app_global_put
    // smart_contracts/xgov_registry/contract.py:704
    // self.voting_duration_medium.value = config.voting_duration[1]
    dig 21
    dup
    intc_3 // 8
    extract_uint64
    bytec 37 // 0x766f74696e675f6475726174696f6e5f6d656469756d
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:705
    // self.voting_duration_large.value = config.voting_duration[2]
    dup
    pushint 16
    extract_uint64
    bytec 38 // 0x766f74696e675f6475726174696f6e5f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:706
    // self.voting_duration_xlarge.value = config.voting_duration[3]
    pushint 24
    extract_uint64
    bytec 39 // 0x766f74696e675f6475726174696f6e5f786c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:708
    // self.quorum_small.value = config.quorum[0]
    bytec 40 // 0x71756f72756d5f736d616c6c
    dig 10
    app_global_put
    // smart_contracts/xgov_registry/contract.py:709
    // self.quorum_medium.value = UInt64(0)  # No longer used
    bytec 41 // 0x71756f72756d5f6d656469756d
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:710
    // self.quorum_large.value = config.quorum[2]
    dig 20
    pushint 16
    extract_uint64
    bytec 42 // 0x71756f72756d5f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:712
    // self.weighted_quorum_small.value = config.weighted_quorum[0]
    bytec 43 // 0x77656967687465645f71756f72756d5f736d616c6c
    dig 9
    app_global_put
    // smart_contracts/xgov_registry/contract.py:713
    // self.weighted_quorum_medium.value = UInt64(0)  # No longer used
    bytec 44 // 0x77656967687465645f71756f72756d5f6d656469756d
    intc_0 // 0
    app_global_put
    // smart_contracts/xgov_registry/contract.py:714
    // self.weighted_quorum_large.value = config.weighted_quorum[2]
    dig 19
    pushint 16
    extract_uint64
    bytec 45 // 0x77656967687465645f71756f72756d5f6c61726765
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:716
    // self.absence_tolerance.value = config.absence_tolerance
    dup
    pushint 184
    extract_uint64
    bytec 22 // 0x616273656e63655f746f6c6572616e6365
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:717
    // self.governance_period.value = config.governance_period
    dup
    pushint 192
    extract_uint64
    bytec 49 // 0x676f7665726e616e63655f706572696f64
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:718
    // self.committee_grace_period.value = config.committee_grace_period
    pushint 200
    extract_uint64
    bytec 50 // 0x636f6d6d69747465655f67726163655f706572696f64
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:597
    // @arc4.abimethod()
    intc_1 // 1
    return

config_xgov_registry_bool_false@30:
    intc_0 // 0
    b config_xgov_registry_bool_merge@31

config_xgov_registry_bool_false@26:
    intc_0 // 0
    b config_xgov_registry_bool_merge@27

config_xgov_registry_bool_false@22:
    intc_0 // 0
    b config_xgov_registry_bool_merge@23

config_xgov_registry_bool_false@16:
    intc_0 // 0
    b config_xgov_registry_bool_merge@17

config_xgov_registry_bool_false@10:
    intc_0 // 0
    b config_xgov_registry_bool_merge@11

config_xgov_registry_bool_false@4:
    intc_0 // 0
    b config_xgov_registry_bool_merge@5


// smart_contracts.xgov_registry.contract.XGovRegistry.update_xgov_registry[routing]() -> void:
update_xgov_registry:
    // smart_contracts/xgov_registry/contract.py:729
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:720
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.subscribe_xgov[routing]() -> void:
subscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:731
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:748
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    // smart_contracts/xgov_registry/contract.py:749
    // assert not self.has_xgov_status(Txn.sender), err.ALREADY_XGOV
    txn Sender
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    concat
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:749
    // assert not self.has_xgov_status(Txn.sender), err.ALREADY_XGOV
    !
    assert // Already an xGov
    // smart_contracts/xgov_registry/contract.py:750
    // assert self.valid_xgov_payment(payment), err.INVALID_PAYMENT
    callsub valid_xgov_payment
    assert // Invalid payment
    // smart_contracts/xgov_registry/contract.py:753
    // xgov_address=Txn.sender, voting_address=voting_address
    txn Sender
    // smart_contracts/xgov_registry/contract.py:752-754
    // self.subscribe_xgov_and_emit(
    //     xgov_address=Txn.sender, voting_address=voting_address
    // )
    swap
    callsub subscribe_xgov_and_emit
    // smart_contracts/xgov_registry/contract.py:731
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.unsubscribe_xgov[routing]() -> void:
unsubscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:766
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    // smart_contracts/xgov_registry/contract.py:767
    // assert self.has_xgov_status(Txn.sender), err.NOT_XGOV
    txn Sender
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    concat
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:767
    // assert self.has_xgov_status(Txn.sender), err.NOT_XGOV
    assert // Not an xGov
    // smart_contracts/xgov_registry/contract.py:769
    // self.unsubscribe_xgov_and_emit(Txn.sender)
    txn Sender
    callsub unsubscribe_xgov_and_emit
    // smart_contracts/xgov_registry/contract.py:756
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.unsubscribe_absentee[routing]() -> void:
unsubscribe_absentee:
    // smart_contracts/xgov_registry/contract.py:771
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:786
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    dig 1
    concat
    dup
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:787
    // assert self.has_xgov_status(xgov_address), err.NOT_XGOV
    assert // Not an xGov
    // smart_contracts/xgov_registry/contract.py:788
    // assert self.xgov_box[xgov_address].tolerated_absences == 0, err.UNAUTHORIZED
    box_get
    pop
    intc_2 // 32
    extract_uint64
    !
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:790
    // self.unsubscribe_xgov_and_emit(xgov_address)
    callsub unsubscribe_xgov_and_emit
    // smart_contracts/xgov_registry/contract.py:771
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.request_subscribe_xgov[routing]() -> void:
request_subscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:792
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:817
    // assert Txn.sender == owner_address, err.UNAUTHORIZED
    txn Sender
    dig 3
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:818
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    dig 4
    concat
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:819
    // assert not self.has_xgov_status(xgov_address), err.ALREADY_XGOV
    !
    assert // Already an xGov
    // smart_contracts/xgov_registry/contract.py:820
    // assert self.valid_xgov_payment(payment), err.INVALID_PAYMENT
    callsub valid_xgov_payment
    assert // Invalid payment
    // smart_contracts/xgov_registry/contract.py:822-823
    // # create request box
    // rid = self.request_id.value
    intc_0 // 0
    bytec 11 // 0x726571756573745f6964
    app_global_get_ex
    assert // check self.request_id exists
    // smart_contracts/xgov_registry/contract.py:824-828
    // self.request_box[rid] = typ.XGovSubscribeRequestBoxValue(
    //     xgov_addr=xgov_address,
    //     owner_addr=owner_address,
    //     relation_type=relation_type,
    // )
    uncover 3
    uncover 3
    concat
    uncover 2
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:824
    // self.request_box[rid] = typ.XGovSubscribeRequestBoxValue(
    dig 1
    itob
    bytec 23 // 0x72
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:824-828
    // self.request_box[rid] = typ.XGovSubscribeRequestBoxValue(
    //     xgov_addr=xgov_address,
    //     owner_addr=owner_address,
    //     relation_type=relation_type,
    // )
    swap
    box_put
    // smart_contracts/xgov_registry/contract.py:830-831
    // # increment request id
    // self.request_id.value += 1
    intc_1 // 1
    +
    bytec 11 // 0x726571756573745f6964
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:792
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.approve_subscribe_xgov[routing]() -> void:
approve_subscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:833
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:846
    // assert self.is_xgov_subscriber(), err.UNAUTHORIZED
    callsub is_xgov_subscriber
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:848
    // xgov_address = self.request_box[request_id].xgov_addr
    itob
    bytec 23 // 0x72
    swap
    concat
    dup
    box_get
    assert // check self.request_box entry exists
    dup
    extract 0 32
    // smart_contracts/xgov_registry/contract.py:849
    // voting_address = self.request_box[request_id].owner_addr
    swap
    extract 32 32
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    dig 2
    concat
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:850
    // assert not self.has_xgov_status(xgov_address), err.ALREADY_XGOV
    !
    assert // Already an xGov
    // smart_contracts/xgov_registry/contract.py:852-854
    // self.subscribe_xgov_and_emit(
    //     xgov_address=xgov_address, voting_address=voting_address
    // )
    callsub subscribe_xgov_and_emit
    // smart_contracts/xgov_registry/contract.py:856-857
    // # delete the request
    // del self.request_box[request_id]
    box_del
    pop
    // smart_contracts/xgov_registry/contract.py:833
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.reject_subscribe_xgov[routing]() -> void:
reject_subscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:859
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:871
    // assert self.is_xgov_subscriber(), err.UNAUTHORIZED
    callsub is_xgov_subscriber
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:873-874
    // # delete the request
    // del self.request_box[request_id]
    itob
    bytec 23 // 0x72
    swap
    concat
    box_del
    pop
    // smart_contracts/xgov_registry/contract.py:859
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.request_unsubscribe_xgov[routing]() -> void:
request_unsubscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:876
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:901
    // assert Txn.sender == owner_address, err.UNAUTHORIZED
    txn Sender
    dig 3
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:902
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    dig 4
    concat
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:903
    // assert self.has_xgov_status(xgov_address), err.NOT_XGOV
    assert // Not an xGov
    // smart_contracts/xgov_registry/contract.py:904
    // assert self.valid_xgov_payment(payment), err.INVALID_PAYMENT
    callsub valid_xgov_payment
    assert // Invalid payment
    // smart_contracts/xgov_registry/contract.py:906-907
    // # create unsubscribe request box
    // ruid = self.request_id.value
    intc_0 // 0
    bytec 11 // 0x726571756573745f6964
    app_global_get_ex
    assert // check self.request_id exists
    // smart_contracts/xgov_registry/contract.py:908-912
    // self.request_unsubscribe_box[ruid] = typ.XGovSubscribeRequestBoxValue(
    //     xgov_addr=xgov_address,
    //     owner_addr=owner_address,
    //     relation_type=relation_type,
    // )
    uncover 3
    uncover 3
    concat
    uncover 2
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:908
    // self.request_unsubscribe_box[ruid] = typ.XGovSubscribeRequestBoxValue(
    dig 1
    itob
    bytec 24 // 0x7275
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:908-912
    // self.request_unsubscribe_box[ruid] = typ.XGovSubscribeRequestBoxValue(
    //     xgov_addr=xgov_address,
    //     owner_addr=owner_address,
    //     relation_type=relation_type,
    // )
    swap
    box_put
    // smart_contracts/xgov_registry/contract.py:914-915
    // # increment request id
    // self.request_id.value += 1
    intc_1 // 1
    +
    bytec 11 // 0x726571756573745f6964
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:876
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.approve_unsubscribe_xgov[routing]() -> void:
approve_unsubscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:917
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:930
    // assert self.is_xgov_subscriber(), err.UNAUTHORIZED
    callsub is_xgov_subscriber
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:932
    // xgov_address = self.request_unsubscribe_box[request_id].xgov_addr
    itob
    bytec 24 // 0x7275
    swap
    concat
    dup
    box_get
    assert // check self.request_unsubscribe_box entry exists
    extract 0 32
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    dig 1
    concat
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:933
    // assert self.has_xgov_status(xgov_address), err.NOT_XGOV
    assert // Not an xGov
    // smart_contracts/xgov_registry/contract.py:935
    // self.unsubscribe_xgov_and_emit(xgov_address)
    callsub unsubscribe_xgov_and_emit
    // smart_contracts/xgov_registry/contract.py:937-938
    // # delete the request
    // del self.request_unsubscribe_box[request_id]
    box_del
    pop
    // smart_contracts/xgov_registry/contract.py:917
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.reject_unsubscribe_xgov[routing]() -> void:
reject_unsubscribe_xgov:
    // smart_contracts/xgov_registry/contract.py:940
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:952
    // assert self.is_xgov_subscriber(), err.UNAUTHORIZED
    callsub is_xgov_subscriber
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:954-955
    // # delete the request
    // del self.request_unsubscribe_box[request_id]
    itob
    bytec 24 // 0x7275
    swap
    concat
    box_del
    pop
    // smart_contracts/xgov_registry/contract.py:940
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_voting_account[routing]() -> void:
set_voting_account:
    // smart_contracts/xgov_registry/contract.py:957
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:974
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    dig 2
    concat
    dup
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:975
    // assert self.has_xgov_status(xgov_address), err.NOT_XGOV
    assert // Not an xGov
    // smart_contracts/xgov_registry/contract.py:976
    // assert self.caller_is_xgov_or_voting_address(xgov_address), err.UNAUTHORIZED
    uncover 2
    callsub caller_is_xgov_or_voting_address
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:978-979
    // # Update the voting account in the xGov box
    // self.xgov_box[xgov_address].voting_address = voting_address
    intc_0 // 0
    uncover 2
    box_replace
    // smart_contracts/xgov_registry/contract.py:957
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.subscribe_proposer[routing]() -> void:
subscribe_proposer:
    // smart_contracts/xgov_registry/contract.py:981
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:995
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:997
    // assert Txn.sender not in self.proposer_box, err.ALREADY_PROPOSER
    bytec_3 // 0x70
    txn Sender
    concat
    box_len
    bury 1
    !
    assert // Already a proposer
    // smart_contracts/xgov_registry/contract.py:1000
    // payment.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/xgov_registry/contract.py:998-1001
    // # check fee
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/xgov_registry/contract.py:1002
    // assert payment.amount == self.proposer_fee.value, err.WRONG_PAYMENT_AMOUNT
    gtxns Amount
    intc_0 // 0
    bytec 20 // 0x70726f706f7365725f666565
    app_global_get_ex
    assert // check self.proposer_fee exists
    ==
    assert // Wrong payment amount
    // smart_contracts/xgov_registry/contract.py:1004
    // self.proposer_box[Txn.sender] = self.make_proposer_box(
    bytec_3 // 0x70
    txn Sender
    concat
    // smart_contracts/xgov_registry/contract.py:389-393
    // return typ.ProposerBoxValue(
    //     active_proposal=active_proposal,
    //     kyc_status=kyc_status,
    //     kyc_expiring=kyc_expiring,
    // )
    bytec 52 // 0x000000000000000000
    // smart_contracts/xgov_registry/contract.py:1004-1006
    // self.proposer_box[Txn.sender] = self.make_proposer_box(
    //     active_proposal=False, kyc_status=False, kyc_expiring=UInt64(0)
    // )
    box_put
    // smart_contracts/xgov_registry/contract.py:1008
    // arc4.emit(typ.ProposerSubscribed(proposer=Txn.sender))
    pushbytes 0xbd792fd1 // method "ProposerSubscribed(address)"
    txn Sender
    concat
    log
    // smart_contracts/xgov_registry/contract.py:981
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.set_proposer_kyc[routing]() -> void:
set_proposer_kyc:
    // smart_contracts/xgov_registry/contract.py:1010
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:1031-1032
    // # check if kyc provider
    // assert Txn.sender == self.kyc_provider.value, err.UNAUTHORIZED
    txn Sender
    intc_0 // 0
    bytec 16 // 0x6b79635f70726f7669646572
    app_global_get_ex
    assert // check self.kyc_provider exists
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1033
    // assert proposer in self.proposer_box, err.PROPOSER_DOES_NOT_EXIST
    bytec_3 // 0x70
    dig 3
    concat
    dup
    box_len
    bury 1
    assert // Proposer does not exist
    // smart_contracts/xgov_registry/contract.py:1035
    // active_proposal = self.proposer_box[proposer].copy().active_proposal
    dup
    box_get
    pop
    intc_0 // 0
    getbit
    // smart_contracts/xgov_registry/contract.py:389-393
    // return typ.ProposerBoxValue(
    //     active_proposal=active_proposal,
    //     kyc_status=kyc_status,
    //     kyc_expiring=kyc_expiring,
    // )
    bytec 7 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_1 // 1
    uncover 4
    setbit
    uncover 2
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:1037-1041
    // self.proposer_box[proposer] = self.make_proposer_box(
    //     active_proposal=active_proposal,
    //     kyc_status=kyc_status,
    //     kyc_expiring=kyc_expiring,
    // )
    box_put
    // smart_contracts/xgov_registry/contract.py:1046
    // valid_kyc=bool(self.valid_kyc(proposer)),
    dup
    callsub valid_kyc
    // smart_contracts/xgov_registry/contract.py:1044-1047
    // typ.ProposerKYC(
    //     proposer=proposer,
    //     valid_kyc=bool(self.valid_kyc(proposer)),
    // )
    bytec 7 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    // smart_contracts/xgov_registry/contract.py:1043-1048
    // arc4.emit(
    //     typ.ProposerKYC(
    //         proposer=proposer,
    //         valid_kyc=bool(self.valid_kyc(proposer)),
    //     )
    // )
    pushbytes 0xcb50fd84 // method "ProposerKYC(address,bool)"
    swap
    concat
    log
    // smart_contracts/xgov_registry/contract.py:1010
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.declare_committee[routing]() -> void:
declare_committee:
    // smart_contracts/xgov_registry/contract.py:1050
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:221
    // return Txn.sender == self.committee_manager.value
    txn Sender
    intc_0 // 0
    bytec 17 // 0x636f6d6d69747465655f6d616e61676572
    app_global_get_ex
    assert // check self.committee_manager exists
    ==
    // smart_contracts/xgov_registry/contract.py:1070
    // assert self.is_xgov_committee_manager(), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1072
    // assert size > 0, err.WRONG_COMMITTEE_MEMBERS
    dig 1
    assert // Wrong Committee Members
    // smart_contracts/xgov_registry/contract.py:1073
    // assert votes > 0, err.WRONG_COMMITTEE_VOTES
    dup
    assert // Wrong Committee Votes
    // smart_contracts/xgov_registry/contract.py:1074
    // assert size <= self.max_committee_size.value, err.COMMITTEE_SIZE_TOO_LARGE
    intc_0 // 0
    bytec 48 // 0x6d61785f636f6d6d69747465655f73697a65
    app_global_get_ex
    assert // check self.max_committee_size exists
    dig 2
    >=
    assert // Committee size is too large
    // smart_contracts/xgov_registry/contract.py:1076
    // self.committee_id.value = committee_id.copy()
    bytec 53 // 0x636f6d6d69747465655f6964
    dig 3
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1077
    // self.committee_members.value = size
    bytec 46 // 0x636f6d6d69747465655f6d656d62657273
    dig 2
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1078
    // self.committee_votes.value = votes
    bytec 47 // 0x636f6d6d69747465655f766f746573
    dig 1
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1079
    // self.committee_last_anchor.value = self.get_committee_anchor()
    callsub get_committee_anchor
    bytec 51 // 0x636f6d6d69747465655f6c6173745f616e63686f72
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1084
    // size=arc4.UInt32(size),
    swap
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/xgov_registry/contract.py:1085
    // votes=arc4.UInt32(votes),
    swap
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/xgov_registry/contract.py:1082-1086
    // typ.NewCommittee(
    //     committee_id=committee_id,
    //     size=arc4.UInt32(size),
    //     votes=arc4.UInt32(votes),
    // )
    cover 2
    concat
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:1081-1087
    // arc4.emit(
    //     typ.NewCommittee(
    //         committee_id=committee_id,
    //         size=arc4.UInt32(size),
    //         votes=arc4.UInt32(votes),
    //     )
    // )
    pushbytes 0x87365866 // method "NewCommittee(byte[32],uint32,uint32)"
    swap
    concat
    log
    // smart_contracts/xgov_registry/contract.py:1050
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.open_proposal[routing]() -> void:
open_proposal:
    // smart_contracts/xgov_registry/contract.py:1089
    // @arc4.abimethod
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:1110
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:1111
    // assert not self.paused_proposals.value, err.PAUSED_PROPOSALS
    intc_0 // 0
    bytec 9 // 0x7061757365645f70726f706f73616c73
    app_global_get_ex
    assert // check self.paused_proposals exists
    !
    assert // Creation of proposals is paused
    // smart_contracts/xgov_registry/contract.py:1113
    // committee_anchor = self.get_committee_anchor()
    callsub get_committee_anchor
    // smart_contracts/xgov_registry/contract.py:1114
    // committee_delay = Global.round - committee_anchor
    global Round
    dig 1
    -
    swap
    // smart_contracts/xgov_registry/contract.py:1116
    // committee_anchor == self.committee_last_anchor.value
    intc_0 // 0
    bytec 51 // 0x636f6d6d69747465655f6c6173745f616e63686f72
    app_global_get_ex
    assert // check self.committee_last_anchor exists
    ==
    // smart_contracts/xgov_registry/contract.py:1116-1117
    // committee_anchor == self.committee_last_anchor.value
    // or committee_delay <= self.committee_grace_period.value
    bnz open_proposal_bool_true@3
    // smart_contracts/xgov_registry/contract.py:1117
    // or committee_delay <= self.committee_grace_period.value
    intc_0 // 0
    bytec 50 // 0x636f6d6d69747465655f67726163655f706572696f64
    app_global_get_ex
    assert // check self.committee_grace_period exists
    dig 1
    >=
    // smart_contracts/xgov_registry/contract.py:1116-1117
    // committee_anchor == self.committee_last_anchor.value
    // or committee_delay <= self.committee_grace_period.value
    bz open_proposal_bool_false@4

open_proposal_bool_true@3:
    intc_1 // 1

open_proposal_bool_merge@5:
    // smart_contracts/xgov_registry/contract.py:1115-1118
    // assert (
    //     committee_anchor == self.committee_last_anchor.value
    //     or committee_delay <= self.committee_grace_period.value
    // ), err.COMMITTEE_STALE
    assert // Committee is stale
    // smart_contracts/xgov_registry/contract.py:1120-1121
    // # Check if the caller is a registered proposer
    // assert Txn.sender in self.proposer_box, err.UNAUTHORIZED
    bytec_3 // 0x70
    txn Sender
    concat
    box_len
    bury 1
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1123-1124
    // # Check if the proposer already has an active proposal
    // assert not self.proposer_box[
    bytec_3 // 0x70
    // smart_contracts/xgov_registry/contract.py:1125
    // Txn.sender
    txn Sender
    // smart_contracts/xgov_registry/contract.py:1123-1126
    // # Check if the proposer already has an active proposal
    // assert not self.proposer_box[
    //     Txn.sender
    // ].active_proposal, err.ALREADY_ACTIVE_PROPOSAL
    concat
    box_get
    assert // check self.proposer_box entry exists
    intc_0 // 0
    getbit
    !
    assert // Proposer already has an active proposal
    // smart_contracts/xgov_registry/contract.py:1127
    // assert self.valid_kyc(Txn.sender), err.INVALID_KYC
    txn Sender
    callsub valid_kyc
    assert // Invalid KYC
    // smart_contracts/xgov_registry/contract.py:1129
    // assert Txn.fee >= (Global.min_txn_fee * 3), err.INSUFFICIENT_FEE
    txn Fee
    global MinTxnFee
    pushint 3
    *
    >=
    assert // Insufficient fee
    // smart_contracts/xgov_registry/contract.py:1133
    // payment.receiver == Global.current_application_address
    dig 1
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/xgov_registry/contract.py:1131-1134
    // # Ensure the transaction has the correct payment
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/xgov_registry/contract.py:1135
    // assert payment.amount == self.open_proposal_fee.value, err.WRONG_PAYMENT_AMOUNT
    gtxns Amount
    intc_0 // 0
    bytec 21 // 0x6f70656e5f70726f706f73616c5f666565
    app_global_get_ex
    assert // check self.open_proposal_fee exists
    swap
    dig 1
    ==
    assert // Wrong payment amount
    // smart_contracts/xgov_registry/contract.py:1137
    // mbr_before = Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/xgov_registry/contract.py:1139
    // assert self.proposal_approval_program, err.MISSING_PROPOSAL_APPROVAL_PROGRAM
    bytec 5 // 0x7061
    box_len
    assert // Missing proposal approval program
    // smart_contracts/xgov_registry/contract.py:1149
    // self.proposal_approval_program.length + compiled_clear_state_1.length
    dup
    pushint 4
    +
    // smart_contracts/xgov_registry/contract.py:1147
    // bytes_per_page = UInt64(BYTES_PER_APP_PAGE)
    intc 4 // 2048
    // smart_contracts/xgov_registry/contract.py:1151
    // total_pages = total_size // bytes_per_page
    /
    // smart_contracts/xgov_registry/contract.py:1153-1156
    // # The following assertion makes sure the loop-unrolling is consistent
    // assert total_pages == UInt64(
    //     PROPOSAL_APPROVAL_PAGES
    // ), err.INVALID_PROPOSAL_APPROVAL_PROGRAM_SIZE
    dup
    pushint 2
    ==
    assert // Invalid proposal approval program size
    // smart_contracts/xgov_registry/contract.py:1158
    // self.proposal_approval_program.length - (total_pages - 1) * bytes_per_page
    dup
    intc_1 // 1
    -
    // smart_contracts/xgov_registry/contract.py:1147
    // bytes_per_page = UInt64(BYTES_PER_APP_PAGE)
    intc 4 // 2048
    // smart_contracts/xgov_registry/contract.py:1158
    // self.proposal_approval_program.length - (total_pages - 1) * bytes_per_page
    *
    uncover 2
    swap
    -
    // smart_contracts/xgov_registry/contract.py:1160
    // page_1 = self.proposal_approval_program.extract(
    bytec 5 // 0x7061
    // smart_contracts/xgov_registry/contract.py:1161
    // 0 * bytes_per_page, bytes_per_page
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:1147
    // bytes_per_page = UInt64(BYTES_PER_APP_PAGE)
    intc 4 // 2048
    // smart_contracts/xgov_registry/contract.py:1160-1162
    // page_1 = self.proposal_approval_program.extract(
    //     0 * bytes_per_page, bytes_per_page
    // )
    box_extract
    // smart_contracts/xgov_registry/contract.py:1163
    // page_2 = self.proposal_approval_program.extract(
    bytec 5 // 0x7061
    // smart_contracts/xgov_registry/contract.py:1147
    // bytes_per_page = UInt64(BYTES_PER_APP_PAGE)
    intc 4 // 2048
    // smart_contracts/xgov_registry/contract.py:1163-1165
    // page_2 = self.proposal_approval_program.extract(
    //     1 * bytes_per_page, bytes_last_page
    // )
    uncover 3
    box_extract
    // smart_contracts/xgov_registry/contract.py:1167-1175
    // tx = arc4.abi_call(
    //     proposal_contract.Proposal.create,
    //     Txn.sender,
    //     approval_program=(page_1, page_2),
    //     clear_state_program=compiled_clear_state_1,
    //     global_num_uint=pcfg.GLOBAL_UINTS,
    //     global_num_bytes=pcfg.GLOBAL_BYTES,
    //     extra_program_pages=total_pages,
    // )
    itxn_begin
    // smart_contracts/xgov_registry/contract.py:1169
    // Txn.sender,
    txn Sender
    uncover 3
    itxn_field ExtraProgramPages
    // smart_contracts/xgov_registry/contract.py:1173
    // global_num_bytes=pcfg.GLOBAL_BYTES,
    pushint 3
    itxn_field GlobalNumByteSlice
    // smart_contracts/xgov_registry/contract.py:1172
    // global_num_uint=pcfg.GLOBAL_UINTS,
    pushint 27
    itxn_field GlobalNumUint
    // smart_contracts/xgov_registry/contract.py:1141-1145
    // # clear_state_program is a tuple of 2 Bytes elements where each is max 4096 bytes
    // # we only use the first element here as we assume the clear state program is small enough
    // compiled_clear_state_1, _compiled_clear_state_2 = compile_contract(
    //     proposal_contract.Proposal
    // ).clear_state_program
    pushbytes base64(CoEBQw==)
    itxn_field ClearStateProgramPages
    uncover 2
    itxn_field ApprovalProgramPages
    swap
    itxn_field ApprovalProgramPages
    // smart_contracts/xgov_registry/contract.py:1167-1175
    // tx = arc4.abi_call(
    //     proposal_contract.Proposal.create,
    //     Txn.sender,
    //     approval_program=(page_1, page_2),
    //     clear_state_program=compiled_clear_state_1,
    //     global_num_uint=pcfg.GLOBAL_UINTS,
    //     global_num_bytes=pcfg.GLOBAL_BYTES,
    //     extra_program_pages=total_pages,
    // )
    pushbytes 0xcc694eaa // method "create(address)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn CreatedApplicationID
    // smart_contracts/xgov_registry/contract.py:1177
    // mbr_after = Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/xgov_registry/contract.py:1179-1184
    // # Transfer funds to the new Proposal App, excluding the MBR needed for the Proposal App
    // itxn.Payment(
    //     receiver=tx.created_app.address,
    //     amount=self.open_proposal_fee.value - (mbr_after - mbr_before),
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/xgov_registry/contract.py:1181
    // receiver=tx.created_app.address,
    dig 1
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/xgov_registry/contract.py:1182
    // amount=self.open_proposal_fee.value - (mbr_after - mbr_before),
    swap
    uncover 3
    -
    uncover 3
    swap
    -
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/xgov_registry/contract.py:1179-1180
    // # Transfer funds to the new Proposal App, excluding the MBR needed for the Proposal App
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/xgov_registry/contract.py:1183
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/xgov_registry/contract.py:1179-1184
    // # Transfer funds to the new Proposal App, excluding the MBR needed for the Proposal App
    // itxn.Payment(
    //     receiver=tx.created_app.address,
    //     amount=self.open_proposal_fee.value - (mbr_after - mbr_before),
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/xgov_registry/contract.py:1186
    // self.increment_pending_proposals(Txn.sender)
    txn Sender
    // smart_contracts/xgov_registry/contract.py:330
    // self.pending_proposals.value += 1
    intc_0 // 0
    bytec 8 // 0x70656e64696e675f70726f706f73616c73
    app_global_get_ex
    assert // check self.pending_proposals exists
    intc_1 // 1
    +
    bytec 8 // 0x70656e64696e675f70726f706f73616c73
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:331
    // self.proposer_box[proposer].active_proposal = True
    bytec_3 // 0x70
    swap
    concat
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    intc_0 // 0
    intc_1 // 1
    setbit
    intc_0 // 0
    swap
    box_replace
    // smart_contracts/xgov_registry/contract.py:1191
    // proposer=Txn.sender,
    txn Sender
    // smart_contracts/xgov_registry/contract.py:1189-1192
    // typ.NewProposal(
    //     proposal_id=tx.created_app.id,
    //     proposer=Txn.sender,
    // )
    swap
    itob
    dup
    uncover 2
    concat
    // smart_contracts/xgov_registry/contract.py:1188-1193
    // arc4.emit(
    //     typ.NewProposal(
    //         proposal_id=tx.created_app.id,
    //         proposer=Txn.sender,
    //     )
    // )
    pushbytes 0xfa79d84b // method "NewProposal(uint64,address)"
    swap
    concat
    log
    // smart_contracts/xgov_registry/contract.py:1089
    // @arc4.abimethod
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

open_proposal_bool_false@4:
    intc_0 // 0
    b open_proposal_bool_merge@5


// smart_contracts.xgov_registry.contract.XGovRegistry.vote_proposal[routing]() -> void:
vote_proposal:
    // smart_contracts/xgov_registry/contract.py:1197
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/xgov_registry/contract.py:1227
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:1229-1230
    // # verify proposal_id id is genuine proposal
    // assert self._is_proposal(proposal_id), err.INVALID_PROPOSAL
    dig 3
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    dig 3
    concat
    dup
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:1231
    // assert self.has_xgov_status(xgov_address), err.NOT_XGOV
    assert // Not an xGov
    // smart_contracts/xgov_registry/contract.py:1232-1234
    // assert self.caller_is_xgov_or_voting_address(
    //     xgov_address
    // ), err.MUST_BE_XGOV_OR_VOTING_ADDRESS
    dig 3
    callsub caller_is_xgov_or_voting_address
    assert // Must be xgov or voting address
    // smart_contracts/xgov_registry/contract.py:1236-1237
    // # Upon vote the absence tolerance is reset
    // self.xgov_box[xgov_address].tolerated_absences = self.absence_tolerance.value
    intc_0 // 0
    bytec 22 // 0x616273656e63655f746f6c6572616e6365
    app_global_get_ex
    assert // check self.absence_tolerance exists
    itob
    dig 1
    intc_2 // 32
    uncover 2
    box_replace
    // smart_contracts/xgov_registry/contract.py:1238
    // self.xgov_box[xgov_address].last_vote_timestamp = Global.latest_timestamp
    global LatestTimestamp
    itob
    pushint 40
    swap
    box_replace
    // smart_contracts/xgov_registry/contract.py:1240-1247
    // # Call the Proposal App to register the vote
    // error, _tx = arc4.abi_call(
    //     proposal_contract.Proposal.vote,
    //     xgov_address,
    //     approval_votes,
    //     rejection_votes,
    //     app_id=proposal_id,
    // )
    itxn_begin
    uncover 3
    itxn_field ApplicationID
    pushbytes 0x1841a0d2 // method "vote(address,uint64,uint64)string"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    dup
    extract 4 0
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for string
    extract 6 0
    dup
    // smart_contracts/xgov_registry/contract.py:1249
    // if error.startswith(err.ARC_65_PREFIX):
    len
    dup
    pushint 4
    <
    bz vote_proposal_ternary_false@4
    intc_0 // 0

vote_proposal_ternary_merge@5:
    // smart_contracts/xgov_registry/contract.py:1249
    // if error.startswith(err.ARC_65_PREFIX):
    bz vote_proposal_else_body@12
    // smart_contracts/xgov_registry/contract.py:1250
    // error_without_prefix = String.from_bytes(error.bytes[4:])
    pushint 4
    dig 1
    dup
    cover 2
    >=
    pushint 4
    dig 2
    uncover 2
    select
    dig 3
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1252
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 12 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1254
    // case err.VOTER_NOT_FOUND:
    bytec 54 // "Voter not found"
    // smart_contracts/xgov_registry/contract.py:1256
    // case err.VOTES_INVALID:
    pushbytess "Votes invalid" "Voting Period Expired"
    // smart_contracts/xgov_registry/contract.py:1251-1261
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         op.err(err.WRONG_PROPOSAL_STATUS)
    //     case err.VOTER_NOT_FOUND:
    //         op.err(err.VOTER_NOT_FOUND)
    //     case err.VOTES_INVALID:
    //         op.err(err.VOTES_INVALID)
    //     case err.VOTING_PERIOD_EXPIRED:
    //         op.err(err.VOTING_PERIOD_EXPIRED)
    //     case _:
    //         op.err("Unknown error")
    uncover 4
    match vote_proposal_switch_case_0@7 vote_proposal_switch_case_1@8 vote_proposal_switch_case_2@9 vote_proposal_switch_case_3@10
    // smart_contracts/xgov_registry/contract.py:1261
    // op.err("Unknown error")
    err // Unknown error

vote_proposal_switch_case_3@10:
    // smart_contracts/xgov_registry/contract.py:1259
    // op.err(err.VOTING_PERIOD_EXPIRED)
    err // Voting Period Expired

vote_proposal_switch_case_2@9:
    // smart_contracts/xgov_registry/contract.py:1257
    // op.err(err.VOTES_INVALID)
    err // Votes invalid

vote_proposal_switch_case_1@8:
    // smart_contracts/xgov_registry/contract.py:1255
    // op.err(err.VOTER_NOT_FOUND)
    err // Voter not found

vote_proposal_switch_case_0@7:
    // smart_contracts/xgov_registry/contract.py:1253
    // op.err(err.WRONG_PROPOSAL_STATUS)
    err // Wrong Proposal Status or finalized

vote_proposal_else_body@12:
    // smart_contracts/xgov_registry/contract.py:1263
    // assert error == "", "Unknown error"
    dig 1
    pushbytes ""
    ==
    assert // Unknown error
    // smart_contracts/xgov_registry/contract.py:1197
    // @arc4.abimethod()
    intc_1 // 1
    return

vote_proposal_ternary_false@4:
    // smart_contracts/xgov_registry/contract.py:1249
    // if error.startswith(err.ARC_65_PREFIX):
    dig 2
    extract 6 4
    bytec 13 // "ERR:"
    ==
    b vote_proposal_ternary_merge@5


// smart_contracts.xgov_registry.contract.XGovRegistry.unassign_absentee_from_proposal[routing]() -> void:
unassign_absentee_from_proposal:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/xgov_registry/contract.py:1265
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    intc_2 // 32
    *
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<account>
    // smart_contracts/xgov_registry/contract.py:1282
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:1284-1285
    // # Verify proposal_id is a genuine proposal created by this registry
    // assert self._is_proposal(proposal_id), err.INVALID_PROPOSAL
    dig 1
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1287-1294
    // # The `Proposal.unassign_absentees` call guarantees that:
    // # - Any absentee in the array is really assigned to the Proposal;
    // # - No absentee is duplicated in the array.
    // error, _tx = arc4.abi_call(
    //     proposal_contract.Proposal.unassign_absentees,
    //     absentees,
    //     app_id=proposal_id,
    // )
    itxn_begin
    swap
    itxn_field ApplicationID
    pushbytes 0x76ff4c70 // method "unassign_absentees(address[])string"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    dup
    extract 4 0
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for string
    extract 6 0
    dup
    // smart_contracts/xgov_registry/contract.py:1296
    // if error.startswith(err.ARC_65_PREFIX):
    len
    dup
    pushint 4
    <
    bz unassign_absentee_from_proposal_ternary_false@4
    intc_0 // 0

unassign_absentee_from_proposal_ternary_merge@5:
    // smart_contracts/xgov_registry/contract.py:1296
    // if error.startswith(err.ARC_65_PREFIX):
    bz unassign_absentee_from_proposal_else_body@10
    // smart_contracts/xgov_registry/contract.py:1297
    // error_without_prefix = String.from_bytes(error.bytes[4:])
    pushint 4
    dig 1
    dup
    cover 2
    >=
    pushint 4
    dig 2
    uncover 2
    select
    dig 3
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1299
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 12 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1301
    // case err.VOTER_NOT_FOUND:
    bytec 54 // "Voter not found"
    // smart_contracts/xgov_registry/contract.py:1298-1304
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         op.err(err.WRONG_PROPOSAL_STATUS)
    //     case err.VOTER_NOT_FOUND:
    //         op.err(err.VOTER_NOT_FOUND)
    //     case _:
    //         op.err("Unknown error")
    uncover 2
    match unassign_absentee_from_proposal_switch_case_0@7 unassign_absentee_from_proposal_switch_case_1@8
    // smart_contracts/xgov_registry/contract.py:1304
    // op.err("Unknown error")
    err // Unknown error

unassign_absentee_from_proposal_switch_case_1@8:
    // smart_contracts/xgov_registry/contract.py:1302
    // op.err(err.VOTER_NOT_FOUND)
    err // Voter not found

unassign_absentee_from_proposal_switch_case_0@7:
    // smart_contracts/xgov_registry/contract.py:1300
    // op.err(err.WRONG_PROPOSAL_STATUS)
    err // Wrong Proposal Status or finalized

unassign_absentee_from_proposal_else_body@10:
    // smart_contracts/xgov_registry/contract.py:1306
    // assert error == "", "Unknown error"
    dig 1
    pushbytes ""
    ==
    assert // Unknown error
    intc_0 // 0
    bury 6

unassign_absentee_from_proposal_for_header@12:
    // smart_contracts/xgov_registry/contract.py:1308-1312
    // #  WARNING: The absentees array:
    // # - MUST have only absentees really/still assigned to the Proposal
    // # - MUST NOT have duplicates
    // # which is guaranteed by the previous ABI call.
    // for absentee in absentees:
    dig 5
    dig 4
    <
    bz unassign_absentee_from_proposal_after_for@20
    dig 4
    extract 2 0
    dig 6
    intc_2 // 32
    *
    intc_2 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 9
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    swap
    concat
    dup
    bury 8
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:1315-1316
    // self.has_xgov_status(absentee)
    // and self.xgov_box[absentee].tolerated_absences > 0
    bz unassign_absentee_from_proposal_after_if_else@18
    // smart_contracts/xgov_registry/contract.py:1316
    // and self.xgov_box[absentee].tolerated_absences > 0
    dig 6
    box_get
    assert // check self.xgov_box entry exists
    intc_2 // 32
    extract_uint64
    // smart_contracts/xgov_registry/contract.py:1315-1316
    // self.has_xgov_status(absentee)
    // and self.xgov_box[absentee].tolerated_absences > 0
    bz unassign_absentee_from_proposal_after_if_else@18
    // smart_contracts/xgov_registry/contract.py:1318
    // self.xgov_box[absentee].tolerated_absences -= 1
    dig 6
    dup
    box_get
    assert // check self.xgov_box entry exists
    intc_2 // 32
    extract_uint64
    intc_1 // 1
    -
    itob
    dig 1
    intc_2 // 32
    uncover 2
    box_replace
    // smart_contracts/xgov_registry/contract.py:1319
    // if self.xgov_box[absentee].tolerated_absences == 0:
    box_get
    pop
    intc_2 // 32
    extract_uint64
    bnz unassign_absentee_from_proposal_after_if_else@18
    // smart_contracts/xgov_registry/contract.py:1320
    // self.unsubscribe_xgov_and_emit(absentee)
    dig 7
    callsub unsubscribe_xgov_and_emit

unassign_absentee_from_proposal_after_if_else@18:
    dig 5
    intc_1 // 1
    +
    bury 6
    b unassign_absentee_from_proposal_for_header@12

unassign_absentee_from_proposal_after_for@20:
    // smart_contracts/xgov_registry/contract.py:1265
    // @arc4.abimethod()
    intc_1 // 1
    return

unassign_absentee_from_proposal_ternary_false@4:
    // smart_contracts/xgov_registry/contract.py:1296
    // if error.startswith(err.ARC_65_PREFIX):
    dig 2
    extract 6 4
    bytec 13 // "ERR:"
    ==
    b unassign_absentee_from_proposal_ternary_merge@5


// smart_contracts.xgov_registry.contract.XGovRegistry.pay_grant_proposal[routing]() -> void:
pay_grant_proposal:
    // smart_contracts/xgov_registry/contract.py:1322
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:1340-1341
    // # Verify the caller is the xGov Payor
    // assert Txn.sender == self.xgov_payor.value, err.UNAUTHORIZED
    txn Sender
    intc_0 // 0
    bytec 15 // 0x78676f765f7061796f72
    app_global_get_ex
    assert // check self.xgov_payor exists
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1343-1344
    // # Verify proposal_id is a genuine proposal created by this registry
    // assert self._is_proposal(proposal_id), err.INVALID_PROPOSAL
    dup
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1346-1347
    // # Read proposal state directly from the Proposal App's global state
    // proposer = self.get_proposal_proposer(proposal_id)
    dup
    callsub get_proposal_proposer
    // smart_contracts/xgov_registry/contract.py:248-250
    // requested_amount, requested_amount_exists = op.AppGlobal.get_ex_uint64(
    //     proposal, pcfg.GS_KEY_REQUESTED_AMOUNT
    // )
    dig 1
    // smart_contracts/xgov_registry/contract.py:249
    // proposal, pcfg.GS_KEY_REQUESTED_AMOUNT
    pushbytes 0x7265717565737465645f616d6f756e74
    // smart_contracts/xgov_registry/contract.py:248-250
    // requested_amount, requested_amount_exists = op.AppGlobal.get_ex_uint64(
    //     proposal, pcfg.GS_KEY_REQUESTED_AMOUNT
    // )
    app_global_get_ex
    // smart_contracts/xgov_registry/contract.py:251
    // assert requested_amount_exists, err.MISSING_KEY
    assert // Missing key in state
    // smart_contracts/xgov_registry/contract.py:1350
    // assert proposer in self.proposer_box, err.WRONG_PROPOSER
    bytec_3 // 0x70
    dig 2
    concat
    box_len
    bury 1
    assert // Wrong proposer
    // smart_contracts/xgov_registry/contract.py:1352
    // assert self.valid_kyc(proposer), err.INVALID_KYC
    dig 1
    callsub valid_kyc
    assert // Invalid KYC
    // smart_contracts/xgov_registry/contract.py:1356
    // self.outstanding_funds.value >= requested_amount
    intc_0 // 0
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    dup
    dig 2
    >=
    // smart_contracts/xgov_registry/contract.py:1354-1357
    // # Verify sufficient funds are available
    // assert (
    //     self.outstanding_funds.value >= requested_amount
    // ), err.INSUFFICIENT_TREASURY_FUNDS
    assert // Insufficient treasury funds
    // smart_contracts/xgov_registry/contract.py:255-256
    // # Transfer the funds to the receiver
    // itxn.Payment(receiver=recipient, amount=amount, fee=0).submit()
    itxn_begin
    dig 1
    itxn_field Amount
    uncover 2
    itxn_field Receiver
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/xgov_registry/contract.py:258-259
    // # Update the outstanding funds
    // self.outstanding_funds.value -= amount
    swap
    -
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1361
    // error, _tx = arc4.abi_call(proposal_contract.Proposal.fund, app_id=proposal_id)
    itxn_begin
    itxn_field ApplicationID
    pushbytes 0x8a5e4c80 // method "fund()string"
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    dup
    extract 4 0
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for string
    extract 6 0
    dup
    // smart_contracts/xgov_registry/contract.py:1363
    // if error.startswith(err.ARC_65_PREFIX):
    len
    dup
    pushint 4
    <
    bz pay_grant_proposal_ternary_false@4
    intc_0 // 0

pay_grant_proposal_ternary_merge@5:
    // smart_contracts/xgov_registry/contract.py:1363
    // if error.startswith(err.ARC_65_PREFIX):
    bz pay_grant_proposal_else_body@9
    // smart_contracts/xgov_registry/contract.py:1364
    // error_without_prefix = String.from_bytes(error.bytes[4:])
    pushint 4
    dig 1
    dup
    cover 2
    >=
    pushint 4
    dig 2
    uncover 2
    select
    dig 3
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1366
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 12 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1365-1369
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         op.err(err.WRONG_PROPOSAL_STATUS)
    //     case _:
    //         op.err("Unknown error")
    swap
    match pay_grant_proposal_switch_case_0@7
    // smart_contracts/xgov_registry/contract.py:1369
    // op.err("Unknown error")
    err // Unknown error

pay_grant_proposal_switch_case_0@7:
    // smart_contracts/xgov_registry/contract.py:1367
    // op.err(err.WRONG_PROPOSAL_STATUS)
    err // Wrong Proposal Status or finalized

pay_grant_proposal_else_body@9:
    // smart_contracts/xgov_registry/contract.py:1371
    // assert error == "", "Unknown error"
    dig 1
    pushbytes ""
    ==
    assert // Unknown error
    // smart_contracts/xgov_registry/contract.py:1322
    // @arc4.abimethod()
    intc_1 // 1
    return

pay_grant_proposal_ternary_false@4:
    // smart_contracts/xgov_registry/contract.py:1363
    // if error.startswith(err.ARC_65_PREFIX):
    dig 2
    extract 6 4
    bytec 13 // "ERR:"
    ==
    b pay_grant_proposal_ternary_merge@5


// smart_contracts.xgov_registry.contract.XGovRegistry.finalize_proposal[routing]() -> void:
finalize_proposal:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/xgov_registry/contract.py:1373
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/xgov_registry/contract.py:236
    // status, status_exists = op.AppGlobal.get_ex_uint64(proposal, pcfg.GS_KEY_STATUS)
    pushbytes 0x737461747573
    app_global_get_ex
    swap
    dup
    uncover 2
    // smart_contracts/xgov_registry/contract.py:237
    // assert status_exists, err.MISSING_KEY
    assert // Missing key in state
    // smart_contracts/xgov_registry/contract.py:1389-1391
    // if proposal_status == UInt64(penm.STATUS_EMPTY) or proposal_status == UInt64(
    //     penm.STATUS_DRAFT
    // ):
    bz finalize_proposal_if_body@3
    dup
    pushint 10
    ==
    bz finalize_proposal_after_if_else@4

finalize_proposal_if_body@3:
    // smart_contracts/xgov_registry/contract.py:1392
    // assert Txn.sender == self.xgov_daemon.value, err.UNAUTHORIZED
    txn Sender
    intc_0 // 0
    bytec 18 // 0x78676f765f6461656d6f6e
    app_global_get_ex
    assert // check self.xgov_daemon exists
    ==
    assert // Unauthorized

finalize_proposal_after_if_else@4:
    // smart_contracts/xgov_registry/contract.py:1394-1395
    // # Verify proposal_id is a genuine proposal created by this registry
    // assert self._is_proposal(proposal_id), err.INVALID_PROPOSAL
    dig 1
    dup
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1397-1399
    // error, _tx = arc4.abi_call(
    //     proposal_contract.Proposal.finalize, app_id=proposal_id
    // )
    itxn_begin
    itxn_field ApplicationID
    pushbytes 0x802069b4 // method "finalize()string"
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    bury 6
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    dup
    extract 4 0
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for string
    extract 6 0
    dup
    bury 5
    // smart_contracts/xgov_registry/contract.py:1401
    // if error.startswith(err.ARC_65_PREFIX):
    len
    dup
    bury 4
    pushint 4
    <
    bz finalize_proposal_ternary_false@7
    intc_0 // 0

finalize_proposal_ternary_merge@8:
    // smart_contracts/xgov_registry/contract.py:1401
    // if error.startswith(err.ARC_65_PREFIX):
    bz finalize_proposal_else_body@13
    // smart_contracts/xgov_registry/contract.py:1402
    // error_without_prefix = String.from_bytes(error.bytes[4:])
    pushint 4
    dig 3
    dup
    cover 2
    >=
    pushint 4
    dig 2
    uncover 2
    select
    dig 5
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1404
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 12 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1406
    // case err.VOTERS_ASSIGNED:
    pushbytes "There are voters assigned to this proposal"
    // smart_contracts/xgov_registry/contract.py:1403-1409
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         op.err(err.WRONG_PROPOSAL_STATUS)
    //     case err.VOTERS_ASSIGNED:
    //         op.err(err.VOTERS_ASSIGNED)
    //     case _:
    //         op.err("Unknown error")
    uncover 2
    match finalize_proposal_switch_case_0@10 finalize_proposal_switch_case_1@11
    // smart_contracts/xgov_registry/contract.py:1409
    // op.err("Unknown error")
    err // Unknown error

finalize_proposal_switch_case_1@11:
    // smart_contracts/xgov_registry/contract.py:1407
    // op.err(err.VOTERS_ASSIGNED)
    err // There are voters assigned to this proposal

finalize_proposal_switch_case_0@10:
    // smart_contracts/xgov_registry/contract.py:1405
    // op.err(err.WRONG_PROPOSAL_STATUS)
    err // Wrong Proposal Status or finalized

finalize_proposal_else_body@13:
    // smart_contracts/xgov_registry/contract.py:1411
    // assert error == "", "Unknown error"
    dig 3
    pushbytes ""
    ==
    assert // Unknown error
    // smart_contracts/xgov_registry/contract.py:1413
    // self.decrement_pending_proposals(proposal_id)
    dig 1
    callsub decrement_pending_proposals
    // smart_contracts/xgov_registry/contract.py:1373
    // @arc4.abimethod()
    intc_1 // 1
    return

finalize_proposal_ternary_false@7:
    // smart_contracts/xgov_registry/contract.py:1401
    // if error.startswith(err.ARC_65_PREFIX):
    dig 4
    extract 6 4
    bytec 13 // "ERR:"
    ==
    b finalize_proposal_ternary_merge@8


// smart_contracts.xgov_registry.contract.XGovRegistry.drop_proposal[routing]() -> void:
drop_proposal:
    // smart_contracts/xgov_registry/contract.py:1415
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/xgov_registry/contract.py:1430
    // assert not self.paused_registry.value, err.PAUSED_REGISTRY
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/xgov_registry/contract.py:1432-1433
    // # Verify proposal_id is a genuine proposal created by this registry
    // assert self._is_proposal(proposal_id), err.INVALID_PROPOSAL
    dup
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1435
    // proposer = self.get_proposal_proposer(proposal_id)
    dup
    callsub get_proposal_proposer
    // smart_contracts/xgov_registry/contract.py:1436
    // assert Txn.sender == proposer, err.UNAUTHORIZED
    txn Sender
    ==
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1438
    // error, _tx = arc4.abi_call(proposal_contract.Proposal.drop, app_id=proposal_id)
    itxn_begin
    itxn_field ApplicationID
    pushbytes 0x7371321a // method "drop()string"
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    dup
    extract 4 0
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for string
    extract 6 0
    dup
    // smart_contracts/xgov_registry/contract.py:1440
    // if error.startswith(err.ARC_65_PREFIX):
    len
    dup
    pushint 4
    <
    bz drop_proposal_ternary_false@4
    intc_0 // 0

drop_proposal_ternary_merge@5:
    // smart_contracts/xgov_registry/contract.py:1440
    // if error.startswith(err.ARC_65_PREFIX):
    bz drop_proposal_else_body@9
    // smart_contracts/xgov_registry/contract.py:1441
    // error_without_prefix = String.from_bytes(error.bytes[4:])
    pushint 4
    dig 1
    dup
    cover 2
    >=
    pushint 4
    dig 2
    uncover 2
    select
    dig 3
    swap
    uncover 2
    substring3
    // smart_contracts/xgov_registry/contract.py:1443
    // case err.WRONG_PROPOSAL_STATUS:
    bytec 12 // "Wrong Proposal Status or finalized"
    // smart_contracts/xgov_registry/contract.py:1442-1446
    // match error_without_prefix:
    //     case err.WRONG_PROPOSAL_STATUS:
    //         op.err(err.WRONG_PROPOSAL_STATUS)
    //     case _:
    //         op.err("Unknown error")
    swap
    match drop_proposal_switch_case_0@7
    // smart_contracts/xgov_registry/contract.py:1446
    // op.err("Unknown error")
    err // Unknown error

drop_proposal_switch_case_0@7:
    // smart_contracts/xgov_registry/contract.py:1444
    // op.err(err.WRONG_PROPOSAL_STATUS)
    err // Wrong Proposal Status or finalized

drop_proposal_else_body@9:
    // smart_contracts/xgov_registry/contract.py:1448
    // assert error == "", "Unknown error"
    dig 1
    pushbytes ""
    ==
    assert // Unknown error
    // smart_contracts/xgov_registry/contract.py:1450
    // self.decrement_pending_proposals(proposal_id)
    dig 3
    callsub decrement_pending_proposals
    // smart_contracts/xgov_registry/contract.py:1415
    // @arc4.abimethod()
    intc_1 // 1
    return

drop_proposal_ternary_false@4:
    // smart_contracts/xgov_registry/contract.py:1440
    // if error.startswith(err.ARC_65_PREFIX):
    dig 2
    extract 6 4
    bytec 13 // "ERR:"
    ==
    b drop_proposal_ternary_merge@5


// smart_contracts.xgov_registry.contract.XGovRegistry.deposit_funds[routing]() -> void:
deposit_funds:
    // smart_contracts/xgov_registry/contract.py:1452
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/xgov_registry/contract.py:1465
    // payment.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/xgov_registry/contract.py:1464-1466
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/xgov_registry/contract.py:1467
    // self.outstanding_funds.value += payment.amount
    intc_0 // 0
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    swap
    gtxns Amount
    +
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1452
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.withdraw_funds[routing]() -> void:
withdraw_funds:
    // smart_contracts/xgov_registry/contract.py:1469
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:1483
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1484
    // assert amount <= self.outstanding_funds.value, err.INSUFFICIENT_FUNDS
    intc_0 // 0
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    dup2
    <=
    assert // Insufficient funds
    // smart_contracts/xgov_registry/contract.py:1485
    // assert Txn.fee >= (Global.min_txn_fee * 2), err.INSUFFICIENT_FEE
    txn Fee
    global MinTxnFee
    pushint 2
    *
    >=
    assert // Insufficient fee
    // smart_contracts/xgov_registry/contract.py:1486
    // self.outstanding_funds.value -= amount
    dig 1
    -
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:1488-1492
    // itxn.Payment(
    //     receiver=self.xgov_manager.value,
    //     amount=amount,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/xgov_registry/contract.py:1489
    // receiver=self.xgov_manager.value,
    intc_0 // 0
    bytec 6 // 0x78676f765f6d616e61676572
    app_global_get_ex
    assert // check self.xgov_manager exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/xgov_registry/contract.py:1488
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/xgov_registry/contract.py:1491
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/xgov_registry/contract.py:1488-1492
    // itxn.Payment(
    //     receiver=self.xgov_manager.value,
    //     amount=amount,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/xgov_registry/contract.py:1469
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.withdraw_balance[routing]() -> void:
withdraw_balance:
    // smart_contracts/xgov_registry/contract.py:1506
    // assert self.is_xgov_manager(), err.UNAUTHORIZED
    callsub is_xgov_manager
    assert // Unauthorized
    // smart_contracts/xgov_registry/contract.py:1507
    // assert Txn.fee >= (Global.min_txn_fee * 2), err.INSUFFICIENT_FEE
    txn Fee
    global MinTxnFee
    pushint 2
    *
    >=
    assert // Insufficient fee
    // smart_contracts/xgov_registry/contract.py:1511
    // Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/xgov_registry/contract.py:1512
    // - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/xgov_registry/contract.py:1511-1512
    // Global.current_application_address.balance
    // - Global.current_application_address.min_balance
    -
    // smart_contracts/xgov_registry/contract.py:1513
    // - self.outstanding_funds.value
    intc_0 // 0
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    // smart_contracts/xgov_registry/contract.py:1511-1513
    // Global.current_application_address.balance
    // - Global.current_application_address.min_balance
    // - self.outstanding_funds.value
    -
    // smart_contracts/xgov_registry/contract.py:1516
    // assert amount > 0, err.INSUFFICIENT_FUNDS
    dup
    assert // Insufficient funds
    // smart_contracts/xgov_registry/contract.py:1517-1521
    // itxn.Payment(
    //     receiver=self.xgov_manager.value,
    //     amount=amount,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/xgov_registry/contract.py:1518
    // receiver=self.xgov_manager.value,
    intc_0 // 0
    bytec 6 // 0x78676f765f6d616e61676572
    app_global_get_ex
    assert // check self.xgov_manager exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/xgov_registry/contract.py:1517
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/xgov_registry/contract.py:1520
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/xgov_registry/contract.py:1517-1521
    // itxn.Payment(
    //     receiver=self.xgov_manager.value,
    //     amount=amount,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/xgov_registry/contract.py:1494
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.get_state[routing]() -> void:
get_state:
    // smart_contracts/xgov_registry/contract.py:1530
    // paused_registry=self.paused_registry.value,
    intc_0 // 0
    bytec_0 // 0x7061757365645f7265676973747279
    app_global_get_ex
    assert // check self.paused_registry exists
    // smart_contracts/xgov_registry/contract.py:1531
    // paused_proposals=self.paused_proposals.value,
    intc_0 // 0
    bytec 9 // 0x7061757365645f70726f706f73616c73
    app_global_get_ex
    assert // check self.paused_proposals exists
    // smart_contracts/xgov_registry/contract.py:1532
    // xgov_manager=self.xgov_manager.value,
    intc_0 // 0
    bytec 6 // 0x78676f765f6d616e61676572
    app_global_get_ex
    assert // check self.xgov_manager exists
    // smart_contracts/xgov_registry/contract.py:1533
    // xgov_payor=self.xgov_payor.value,
    intc_0 // 0
    bytec 15 // 0x78676f765f7061796f72
    app_global_get_ex
    assert // check self.xgov_payor exists
    // smart_contracts/xgov_registry/contract.py:1534
    // xgov_council=self.xgov_council.value,
    intc_0 // 0
    bytec 25 // 0x78676f765f636f756e63696c
    app_global_get_ex
    assert // check self.xgov_council exists
    // smart_contracts/xgov_registry/contract.py:1535
    // xgov_subscriber=self.xgov_subscriber.value,
    intc_0 // 0
    bytec 14 // 0x78676f765f73756273637269626572
    app_global_get_ex
    assert // check self.xgov_subscriber exists
    // smart_contracts/xgov_registry/contract.py:1536
    // kyc_provider=self.kyc_provider.value,
    intc_0 // 0
    bytec 16 // 0x6b79635f70726f7669646572
    app_global_get_ex
    assert // check self.kyc_provider exists
    // smart_contracts/xgov_registry/contract.py:1537
    // committee_manager=self.committee_manager.value,
    intc_0 // 0
    bytec 17 // 0x636f6d6d69747465655f6d616e61676572
    app_global_get_ex
    assert // check self.committee_manager exists
    // smart_contracts/xgov_registry/contract.py:1538
    // xgov_daemon=self.xgov_daemon.value,
    intc_0 // 0
    bytec 18 // 0x78676f765f6461656d6f6e
    app_global_get_ex
    assert // check self.xgov_daemon exists
    // smart_contracts/xgov_registry/contract.py:1539
    // xgov_fee=self.xgov_fee.value,
    intc_0 // 0
    bytec 19 // 0x78676f765f666565
    app_global_get_ex
    assert // check self.xgov_fee exists
    // smart_contracts/xgov_registry/contract.py:1540
    // proposer_fee=self.proposer_fee.value,
    intc_0 // 0
    bytec 20 // 0x70726f706f7365725f666565
    app_global_get_ex
    assert // check self.proposer_fee exists
    // smart_contracts/xgov_registry/contract.py:1541
    // open_proposal_fee=self.open_proposal_fee.value,
    intc_0 // 0
    bytec 21 // 0x6f70656e5f70726f706f73616c5f666565
    app_global_get_ex
    assert // check self.open_proposal_fee exists
    // smart_contracts/xgov_registry/contract.py:1542
    // daemon_ops_funding_bps=self.daemon_ops_funding_bps.value,
    intc_0 // 0
    bytec 26 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    app_global_get_ex
    assert // check self.daemon_ops_funding_bps exists
    // smart_contracts/xgov_registry/contract.py:1543
    // proposal_commitment_bps=self.proposal_commitment_bps.value,
    intc_0 // 0
    bytec 27 // 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    app_global_get_ex
    assert // check self.proposal_commitment_bps exists
    // smart_contracts/xgov_registry/contract.py:1544
    // min_requested_amount=self.min_requested_amount.value,
    intc_0 // 0
    bytec 28 // 0x6d696e5f7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.min_requested_amount exists
    // smart_contracts/xgov_registry/contract.py:1547
    // self.max_requested_amount_small.value,
    intc_0 // 0
    bytec 29 // 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    app_global_get_ex
    assert // check self.max_requested_amount_small exists
    // smart_contracts/xgov_registry/contract.py:1548
    // self.max_requested_amount_medium.value,
    intc_0 // 0
    bytec 30 // 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    app_global_get_ex
    assert // check self.max_requested_amount_medium exists
    // smart_contracts/xgov_registry/contract.py:1549
    // self.max_requested_amount_large.value,
    intc_0 // 0
    bytec 31 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    app_global_get_ex
    assert // check self.max_requested_amount_large exists
    // smart_contracts/xgov_registry/contract.py:1545-1551
    // max_requested_amount=FixedArray(
    //     (
    //         self.max_requested_amount_small.value,
    //         self.max_requested_amount_medium.value,
    //         self.max_requested_amount_large.value,
    //     )
    // ),
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:1554
    // self.discussion_duration_small.value,
    intc_0 // 0
    bytec 32 // 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    app_global_get_ex
    assert // check self.discussion_duration_small exists
    // smart_contracts/xgov_registry/contract.py:1555
    // self.discussion_duration_medium.value,
    intc_0 // 0
    bytec 33 // 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    app_global_get_ex
    assert // check self.discussion_duration_medium exists
    // smart_contracts/xgov_registry/contract.py:1556
    // self.discussion_duration_large.value,
    intc_0 // 0
    bytec 34 // 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    app_global_get_ex
    assert // check self.discussion_duration_large exists
    // smart_contracts/xgov_registry/contract.py:1557
    // self.discussion_duration_xlarge.value,
    intc_0 // 0
    bytec 35 // 0x64697363757373696f6e5f6475726174696f6e5f786c61726765
    app_global_get_ex
    assert // check self.discussion_duration_xlarge exists
    // smart_contracts/xgov_registry/contract.py:1552-1559
    // discussion_duration=FixedArray(
    //     (
    //         self.discussion_duration_small.value,
    //         self.discussion_duration_medium.value,
    //         self.discussion_duration_large.value,
    //         self.discussion_duration_xlarge.value,
    //     )
    // ),
    uncover 3
    itob
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:1562
    // self.voting_duration_small.value,
    intc_0 // 0
    bytec 36 // 0x766f74696e675f6475726174696f6e5f736d616c6c
    app_global_get_ex
    assert // check self.voting_duration_small exists
    // smart_contracts/xgov_registry/contract.py:1563
    // self.voting_duration_medium.value,
    intc_0 // 0
    bytec 37 // 0x766f74696e675f6475726174696f6e5f6d656469756d
    app_global_get_ex
    assert // check self.voting_duration_medium exists
    // smart_contracts/xgov_registry/contract.py:1564
    // self.voting_duration_large.value,
    intc_0 // 0
    bytec 38 // 0x766f74696e675f6475726174696f6e5f6c61726765
    app_global_get_ex
    assert // check self.voting_duration_large exists
    // smart_contracts/xgov_registry/contract.py:1565
    // self.voting_duration_xlarge.value,
    intc_0 // 0
    bytec 39 // 0x766f74696e675f6475726174696f6e5f786c61726765
    app_global_get_ex
    assert // check self.voting_duration_xlarge exists
    // smart_contracts/xgov_registry/contract.py:1560-1567
    // voting_duration=FixedArray(
    //     (
    //         self.voting_duration_small.value,
    //         self.voting_duration_medium.value,
    //         self.voting_duration_large.value,
    //         self.voting_duration_xlarge.value,
    //     )
    // ),
    uncover 3
    itob
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:1570
    // self.quorum_small.value,
    intc_0 // 0
    bytec 40 // 0x71756f72756d5f736d616c6c
    app_global_get_ex
    assert // check self.quorum_small exists
    // smart_contracts/xgov_registry/contract.py:1571
    // self.quorum_medium.value,  # No longer used
    intc_0 // 0
    bytec 41 // 0x71756f72756d5f6d656469756d
    app_global_get_ex
    assert // check self.quorum_medium exists
    // smart_contracts/xgov_registry/contract.py:1572
    // self.quorum_large.value,
    intc_0 // 0
    bytec 42 // 0x71756f72756d5f6c61726765
    app_global_get_ex
    assert // check self.quorum_large exists
    // smart_contracts/xgov_registry/contract.py:1568-1574
    // quorum=FixedArray(
    //     (
    //         self.quorum_small.value,
    //         self.quorum_medium.value,  # No longer used
    //         self.quorum_large.value,
    //     )
    // ),
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:1577
    // self.weighted_quorum_small.value,
    intc_0 // 0
    bytec 43 // 0x77656967687465645f71756f72756d5f736d616c6c
    app_global_get_ex
    assert // check self.weighted_quorum_small exists
    // smart_contracts/xgov_registry/contract.py:1578
    // self.weighted_quorum_medium.value,  # No longer used
    intc_0 // 0
    bytec 44 // 0x77656967687465645f71756f72756d5f6d656469756d
    app_global_get_ex
    assert // check self.weighted_quorum_medium exists
    // smart_contracts/xgov_registry/contract.py:1579
    // self.weighted_quorum_large.value,
    intc_0 // 0
    bytec 45 // 0x77656967687465645f71756f72756d5f6c61726765
    app_global_get_ex
    assert // check self.weighted_quorum_large exists
    // smart_contracts/xgov_registry/contract.py:1575-1581
    // weighted_quorum=FixedArray(
    //     (
    //         self.weighted_quorum_small.value,
    //         self.weighted_quorum_medium.value,  # No longer used
    //         self.weighted_quorum_large.value,
    //     )
    // ),
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:1582
    // outstanding_funds=self.outstanding_funds.value,
    intc_0 // 0
    bytec 4 // 0x6f75747374616e64696e675f66756e6473
    app_global_get_ex
    assert // check self.outstanding_funds exists
    // smart_contracts/xgov_registry/contract.py:1583
    // pending_proposals=self.pending_proposals.value,
    intc_0 // 0
    bytec 8 // 0x70656e64696e675f70726f706f73616c73
    app_global_get_ex
    assert // check self.pending_proposals exists
    // smart_contracts/xgov_registry/contract.py:1584
    // committee_id=self.committee_id.value.copy(),
    intc_0 // 0
    bytec 53 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    // smart_contracts/xgov_registry/contract.py:1585
    // committee_members=self.committee_members.value,
    intc_0 // 0
    bytec 46 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/xgov_registry/contract.py:1586
    // committee_votes=self.committee_votes.value,
    intc_0 // 0
    bytec 47 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/xgov_registry/contract.py:1587
    // absence_tolerance=self.absence_tolerance.value,
    intc_0 // 0
    bytec 22 // 0x616273656e63655f746f6c6572616e6365
    app_global_get_ex
    assert // check self.absence_tolerance exists
    // smart_contracts/xgov_registry/contract.py:1588
    // governance_period=self.governance_period.value,
    intc_0 // 0
    bytec 49 // 0x676f7665726e616e63655f706572696f64
    app_global_get_ex
    assert // check self.governance_period exists
    // smart_contracts/xgov_registry/contract.py:1589
    // committee_grace_period=self.committee_grace_period.value,
    intc_0 // 0
    bytec 50 // 0x636f6d6d69747465655f67726163655f706572696f64
    app_global_get_ex
    assert // check self.committee_grace_period exists
    // smart_contracts/xgov_registry/contract.py:1590
    // committee_last_anchor=self.committee_last_anchor.value,
    intc_0 // 0
    bytec 51 // 0x636f6d6d69747465655f6c6173745f616e63686f72
    app_global_get_ex
    assert // check self.committee_last_anchor exists
    // smart_contracts/xgov_registry/contract.py:1529-1591
    // return typ.TypedGlobalState(
    //     paused_registry=self.paused_registry.value,
    //     paused_proposals=self.paused_proposals.value,
    //     xgov_manager=self.xgov_manager.value,
    //     xgov_payor=self.xgov_payor.value,
    //     xgov_council=self.xgov_council.value,
    //     xgov_subscriber=self.xgov_subscriber.value,
    //     kyc_provider=self.kyc_provider.value,
    //     committee_manager=self.committee_manager.value,
    //     xgov_daemon=self.xgov_daemon.value,
    //     xgov_fee=self.xgov_fee.value,
    //     proposer_fee=self.proposer_fee.value,
    //     open_proposal_fee=self.open_proposal_fee.value,
    //     daemon_ops_funding_bps=self.daemon_ops_funding_bps.value,
    //     proposal_commitment_bps=self.proposal_commitment_bps.value,
    //     min_requested_amount=self.min_requested_amount.value,
    //     max_requested_amount=FixedArray(
    //         (
    //             self.max_requested_amount_small.value,
    //             self.max_requested_amount_medium.value,
    //             self.max_requested_amount_large.value,
    //         )
    //     ),
    //     discussion_duration=FixedArray(
    //         (
    //             self.discussion_duration_small.value,
    //             self.discussion_duration_medium.value,
    //             self.discussion_duration_large.value,
    //             self.discussion_duration_xlarge.value,
    //         )
    //     ),
    //     voting_duration=FixedArray(
    //         (
    //             self.voting_duration_small.value,
    //             self.voting_duration_medium.value,
    //             self.voting_duration_large.value,
    //             self.voting_duration_xlarge.value,
    //         )
    //     ),
    //     quorum=FixedArray(
    //         (
    //             self.quorum_small.value,
    //             self.quorum_medium.value,  # No longer used
    //             self.quorum_large.value,
    //         )
    //     ),
    //     weighted_quorum=FixedArray(
    //         (
    //             self.weighted_quorum_small.value,
    //             self.weighted_quorum_medium.value,  # No longer used
    //             self.weighted_quorum_large.value,
    //         )
    //     ),
    //     outstanding_funds=self.outstanding_funds.value,
    //     pending_proposals=self.pending_proposals.value,
    //     committee_id=self.committee_id.value.copy(),
    //     committee_members=self.committee_members.value,
    //     committee_votes=self.committee_votes.value,
    //     absence_tolerance=self.absence_tolerance.value,
    //     governance_period=self.governance_period.value,
    //     committee_grace_period=self.committee_grace_period.value,
    //     committee_last_anchor=self.committee_last_anchor.value,
    // )
    bytec 7 // 0x00
    intc_0 // 0
    uncover 30
    setbit
    intc_1 // 1
    uncover 29
    setbit
    uncover 27
    concat
    uncover 26
    concat
    uncover 25
    concat
    uncover 24
    concat
    uncover 23
    concat
    uncover 22
    concat
    uncover 21
    concat
    uncover 20
    itob
    concat
    uncover 19
    itob
    concat
    uncover 18
    itob
    concat
    uncover 17
    itob
    concat
    uncover 16
    itob
    concat
    uncover 15
    itob
    concat
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    itob
    concat
    uncover 8
    itob
    concat
    uncover 7
    concat
    uncover 6
    itob
    concat
    uncover 5
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:1523
    // @arc4.abimethod(readonly=True)
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.get_xgov_box[routing]() -> void:
get_xgov_box:
    // smart_contracts/xgov_registry/contract.py:1593
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    swap
    concat
    dup
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/xgov_registry/contract.py:1606
    // if exists:
    bz get_xgov_box_else_body@3
    // smart_contracts/xgov_registry/contract.py:1607
    // val = self.xgov_box[xgov_address].copy()
    dig 1
    box_get
    assert // check self.xgov_box entry exists

get_xgov_box_after_if_else@4:
    // smart_contracts/xgov_registry/contract.py:1593
    // @arc4.abimethod(readonly=True)
    bytec 7 // 0x00
    intc_0 // 0
    dig 3
    setbit
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_xgov_box_else_body@3:
    // smart_contracts/xgov_registry/contract.py:1609-1614
    // val = typ.XGovBoxValue(
    //     voting_address=Account(),
    //     tolerated_absences=UInt64(0),
    //     last_vote_timestamp=UInt64(0),
    //     subscription_round=UInt64(0),
    // )
    pushbytes base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    b get_xgov_box_after_if_else@4


// smart_contracts.xgov_registry.contract.XGovRegistry.get_proposer_box[routing]() -> void:
get_proposer_box:
    // smart_contracts/xgov_registry/contract.py:1618
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/xgov_registry/contract.py:1634
    // exists = proposer_address in self.proposer_box
    bytec_3 // 0x70
    swap
    concat
    dup
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/xgov_registry/contract.py:1635
    // if exists:
    bz get_proposer_box_else_body@3
    // smart_contracts/xgov_registry/contract.py:1636
    // val = self.proposer_box[proposer_address].copy()
    dig 1
    box_get
    assert // check self.proposer_box entry exists

get_proposer_box_after_if_else@4:
    // smart_contracts/xgov_registry/contract.py:1618
    // @arc4.abimethod(readonly=True)
    bytec 7 // 0x00
    intc_0 // 0
    dig 3
    setbit
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_proposer_box_else_body@3:
    // smart_contracts/xgov_registry/contract.py:1638-1642
    // val = typ.ProposerBoxValue(
    //     active_proposal=False,
    //     kyc_status=False,
    //     kyc_expiring=UInt64(0),
    // )
    bytec 52 // 0x000000000000000000
    b get_proposer_box_after_if_else@4


// smart_contracts.xgov_registry.contract.XGovRegistry.get_request_box[routing]() -> void:
get_request_box:
    // smart_contracts/xgov_registry/contract.py:1646
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:1662
    // exists = request_id in self.request_box
    itob
    bytec 23 // 0x72
    swap
    concat
    dup
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/xgov_registry/contract.py:1663
    // if exists:
    bz get_request_box_else_body@3
    // smart_contracts/xgov_registry/contract.py:1664
    // val = self.request_box[request_id].copy()
    dig 1
    box_get
    assert // check self.request_box entry exists

get_request_box_after_if_else@4:
    // smart_contracts/xgov_registry/contract.py:1646
    // @arc4.abimethod(readonly=True)
    bytec 7 // 0x00
    intc_0 // 0
    dig 3
    setbit
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_request_box_else_body@3:
    // smart_contracts/xgov_registry/contract.py:1666-1670
    // val = typ.XGovSubscribeRequestBoxValue(
    //     xgov_addr=Account(),
    //     owner_addr=Account(),
    //     relation_type=UInt64(0),
    // )
    bytec 55 // base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    b get_request_box_after_if_else@4


// smart_contracts.xgov_registry.contract.XGovRegistry.get_request_unsubscribe_box[routing]() -> void:
get_request_unsubscribe_box:
    // smart_contracts/xgov_registry/contract.py:1674
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:1688
    // exists = request_id in self.request_unsubscribe_box
    itob
    bytec 24 // 0x7275
    swap
    concat
    dup
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/xgov_registry/contract.py:1689
    // if exists:
    bz get_request_unsubscribe_box_else_body@3
    // smart_contracts/xgov_registry/contract.py:1690
    // val = self.request_unsubscribe_box[request_id].copy()
    dig 1
    box_get
    assert // check self.request_unsubscribe_box entry exists

get_request_unsubscribe_box_after_if_else@4:
    // smart_contracts/xgov_registry/contract.py:1674
    // @arc4.abimethod(readonly=True)
    bytec 7 // 0x00
    intc_0 // 0
    dig 3
    setbit
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_request_unsubscribe_box_else_body@3:
    // smart_contracts/xgov_registry/contract.py:1692-1696
    // val = typ.XGovSubscribeRequestBoxValue(
    //     xgov_addr=Account(),
    //     owner_addr=Account(),
    //     relation_type=UInt64(0),
    // )
    bytec 55 // base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    b get_request_unsubscribe_box_after_if_else@4


// smart_contracts.xgov_registry.contract.XGovRegistry.is_proposal[routing]() -> void:
is_proposal:
    // smart_contracts/xgov_registry/contract.py:1700
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/xgov_registry/contract.py:1702
    // assert self._is_proposal(proposal_id), err.INVALID_PROPOSAL
    callsub _is_proposal
    assert // Invalid proposal
    // smart_contracts/xgov_registry/contract.py:1700
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.xgov_registry.contract.XGovRegistry.is_xgov_manager() -> uint64:
is_xgov_manager:
    // smart_contracts/xgov_registry/contract.py:215
    // return Txn.sender == self.xgov_manager.value
    txn Sender
    intc_0 // 0
    bytec 6 // 0x78676f765f6d616e61676572
    app_global_get_ex
    assert // check self.xgov_manager exists
    ==
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.is_xgov_subscriber() -> uint64:
is_xgov_subscriber:
    // smart_contracts/xgov_registry/contract.py:218
    // return Txn.sender == self.xgov_subscriber.value
    txn Sender
    intc_0 // 0
    bytec 14 // 0x78676f765f73756273637269626572
    app_global_get_ex
    assert // check self.xgov_subscriber exists
    ==
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.caller_is_xgov_or_voting_address(xgov_address: bytes) -> uint64:
caller_is_xgov_or_voting_address:
    // smart_contracts/xgov_registry/contract.py:226
    // def caller_is_xgov_or_voting_address(self, xgov_address: Account) -> bool:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:228
    // Txn.sender == xgov_address
    txn Sender
    frame_dig -1
    ==
    // smart_contracts/xgov_registry/contract.py:228-229
    // Txn.sender == xgov_address
    // or Txn.sender == self.xgov_box[xgov_address].voting_address
    bnz caller_is_xgov_or_voting_address_bool_true@2
    // smart_contracts/xgov_registry/contract.py:229
    // or Txn.sender == self.xgov_box[xgov_address].voting_address
    txn Sender
    bytec_1 // 0x78
    frame_dig -1
    concat
    box_get
    assert // check self.xgov_box entry exists
    extract 0 32
    ==
    // smart_contracts/xgov_registry/contract.py:228-229
    // Txn.sender == xgov_address
    // or Txn.sender == self.xgov_box[xgov_address].voting_address
    bz caller_is_xgov_or_voting_address_bool_false@3

caller_is_xgov_or_voting_address_bool_true@2:
    intc_1 // 1
    // smart_contracts/xgov_registry/contract.py:227-230
    // return (
    //     Txn.sender == xgov_address
    //     or Txn.sender == self.xgov_box[xgov_address].voting_address
    // )
    retsub

caller_is_xgov_or_voting_address_bool_false@3:
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:227-230
    // return (
    //     Txn.sender == xgov_address
    //     or Txn.sender == self.xgov_box[xgov_address].voting_address
    // )
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry._is_proposal(proposal: uint64) -> uint64:
_is_proposal:
    // smart_contracts/xgov_registry/contract.py:232
    // def _is_proposal(self, proposal: Application) -> bool:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:233
    // return proposal.creator == Global.current_application_address
    frame_dig -1
    app_params_get AppCreator
    assert // application exists
    global CurrentApplicationAddress
    ==
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.get_proposal_proposer(proposal: uint64) -> bytes:
get_proposal_proposer:
    // smart_contracts/xgov_registry/contract.py:240
    // def get_proposal_proposer(self, proposal: Application) -> Account:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:241-243
    // proposer_bytes, proposer_exists = op.AppGlobal.get_ex_bytes(
    //     proposal, pcfg.GS_KEY_PROPOSER
    // )
    frame_dig -1
    // smart_contracts/xgov_registry/contract.py:242
    // proposal, pcfg.GS_KEY_PROPOSER
    pushbytes 0x70726f706f736572
    // smart_contracts/xgov_registry/contract.py:241-243
    // proposer_bytes, proposer_exists = op.AppGlobal.get_ex_bytes(
    //     proposal, pcfg.GS_KEY_PROPOSER
    // )
    app_global_get_ex
    // smart_contracts/xgov_registry/contract.py:244
    // assert proposer_exists, err.MISSING_KEY
    assert // Missing key in state
    // smart_contracts/xgov_registry/contract.py:245
    // return Account(proposer_bytes)
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.valid_xgov_payment(payment: uint64) -> uint64:
valid_xgov_payment:
    // smart_contracts/xgov_registry/contract.py:261
    // def valid_xgov_payment(self, payment: gtxn.PaymentTransaction) -> bool:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:263
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/xgov_registry/contract.py:263-264
    // payment.receiver == Global.current_application_address
    // and payment.amount == self.xgov_fee.value
    bz valid_xgov_payment_bool_false@3
    // smart_contracts/xgov_registry/contract.py:264
    // and payment.amount == self.xgov_fee.value
    frame_dig -1
    gtxns Amount
    intc_0 // 0
    bytec 19 // 0x78676f765f666565
    app_global_get_ex
    assert // check self.xgov_fee exists
    ==
    // smart_contracts/xgov_registry/contract.py:263-264
    // payment.receiver == Global.current_application_address
    // and payment.amount == self.xgov_fee.value
    bz valid_xgov_payment_bool_false@3
    intc_1 // 1
    // smart_contracts/xgov_registry/contract.py:262-265
    // return (
    //     payment.receiver == Global.current_application_address
    //     and payment.amount == self.xgov_fee.value
    // )
    retsub

valid_xgov_payment_bool_false@3:
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:262-265
    // return (
    //     payment.receiver == Global.current_application_address
    //     and payment.amount == self.xgov_fee.value
    // )
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.valid_kyc(address: bytes) -> uint64:
valid_kyc:
    // smart_contracts/xgov_registry/contract.py:267
    // def valid_kyc(self, address: Account) -> bool:
    proto 1 1
    // smart_contracts/xgov_registry/contract.py:269
    // self.proposer_box[address].kyc_status
    bytec_3 // 0x70
    frame_dig -1
    concat
    dup
    box_get
    assert // check self.proposer_box entry exists
    intc_1 // 1
    getbit
    // smart_contracts/xgov_registry/contract.py:269-270
    // self.proposer_box[address].kyc_status
    // and self.proposer_box[address].kyc_expiring > Global.latest_timestamp
    bz valid_kyc_bool_false@3
    // smart_contracts/xgov_registry/contract.py:270
    // and self.proposer_box[address].kyc_expiring > Global.latest_timestamp
    frame_dig 0
    box_get
    assert // check self.proposer_box entry exists
    intc_1 // 1
    extract_uint64
    global LatestTimestamp
    >
    // smart_contracts/xgov_registry/contract.py:269-270
    // self.proposer_box[address].kyc_status
    // and self.proposer_box[address].kyc_expiring > Global.latest_timestamp
    bz valid_kyc_bool_false@3
    intc_1 // 1

valid_kyc_bool_merge@4:
    // smart_contracts/xgov_registry/contract.py:268-271
    // return (
    //     self.proposer_box[address].kyc_status
    //     and self.proposer_box[address].kyc_expiring > Global.latest_timestamp
    // )
    swap
    retsub

valid_kyc_bool_false@3:
    intc_0 // 0
    b valid_kyc_bool_merge@4


// smart_contracts.xgov_registry.contract.XGovRegistry.get_committee_anchor() -> uint64:
get_committee_anchor:
    // smart_contracts/xgov_registry/contract.py:297
    // r = Global.round
    global Round
    // smart_contracts/xgov_registry/contract.py:298
    // return r - (r % self.governance_period.value)
    intc_0 // 0
    bytec 49 // 0x676f7665726e616e63655f706572696f64
    app_global_get_ex
    assert // check self.governance_period exists
    dig 1
    swap
    %
    -
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.decrement_pending_proposals(proposal: uint64) -> void:
decrement_pending_proposals:
    // smart_contracts/xgov_registry/contract.py:333
    // def decrement_pending_proposals(self, proposal: Application) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:334
    // self.pending_proposals.value -= 1
    intc_0 // 0
    bytec 8 // 0x70656e64696e675f70726f706f73616c73
    app_global_get_ex
    assert // check self.pending_proposals exists
    intc_1 // 1
    -
    bytec 8 // 0x70656e64696e675f70726f706f73616c73
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:335
    // proposer = self.get_proposal_proposer(proposal)
    frame_dig -1
    callsub get_proposal_proposer
    // smart_contracts/xgov_registry/contract.py:336
    // self.proposer_box[proposer].active_proposal = False
    bytec_3 // 0x70
    swap
    concat
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    intc_0 // 0
    dup
    setbit
    intc_0 // 0
    swap
    box_replace
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.subscribe_xgov_and_emit(xgov_address: bytes, voting_address: bytes) -> void:
subscribe_xgov_and_emit:
    // smart_contracts/xgov_registry/contract.py:355-357
    // def subscribe_xgov_and_emit(
    //     self, *, xgov_address: Account, voting_address: Account
    // ) -> None:
    proto 2 0
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:358-359
    // # The following assertion may be redundant in some invocations.
    // assert not self.has_xgov_status(xgov_address), err.ALREADY_XGOV
    !
    assert // Already an xGov
    // smart_contracts/xgov_registry/contract.py:350
    // tolerated_absences=self.absence_tolerance.value,
    intc_0 // 0
    bytec 22 // 0x616273656e63655f746f6c6572616e6365
    app_global_get_ex
    assert // check self.absence_tolerance exists
    // smart_contracts/xgov_registry/contract.py:352
    // subscription_round=Global.round,
    global Round
    // smart_contracts/xgov_registry/contract.py:348-353
    // return typ.XGovBoxValue(
    //     voting_address=voting_address,
    //     tolerated_absences=self.absence_tolerance.value,
    //     last_vote_timestamp=UInt64(0),
    //     subscription_round=Global.round,
    // )
    swap
    itob
    frame_dig -1
    swap
    concat
    // smart_contracts/xgov_registry/contract.py:351
    // last_vote_timestamp=UInt64(0),
    intc_0 // 0
    // smart_contracts/xgov_registry/contract.py:348-353
    // return typ.XGovBoxValue(
    //     voting_address=voting_address,
    //     tolerated_absences=self.absence_tolerance.value,
    //     last_vote_timestamp=UInt64(0),
    //     subscription_round=Global.round,
    // )
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/xgov_registry/contract.py:360
    // self.xgov_box[xgov_address] = self.make_xgov_box(voting_address)
    box_put
    // smart_contracts/xgov_registry/contract.py:361
    // self.xgovs.value += 1
    intc_0 // 0
    bytec 10 // 0x78676f7673
    app_global_get_ex
    assert // check self.xgovs exists
    intc_1 // 1
    +
    bytec 10 // 0x78676f7673
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:362
    // arc4.emit(typ.XGovSubscribed(xgov=xgov_address, delegate=voting_address))
    frame_dig -2
    frame_dig -1
    concat
    pushbytes 0xb1324860 // method "XGovSubscribed(address,address)"
    swap
    concat
    log
    retsub


// smart_contracts.xgov_registry.contract.XGovRegistry.unsubscribe_xgov_and_emit(xgov_address: bytes) -> void:
unsubscribe_xgov_and_emit:
    // smart_contracts/xgov_registry/contract.py:364
    // def unsubscribe_xgov_and_emit(self, xgov_address: Account) -> None:
    proto 1 0
    // smart_contracts/xgov_registry/contract.py:224
    // return a in self.xgov_box
    bytec_1 // 0x78
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    // smart_contracts/xgov_registry/contract.py:365-366
    // # The following assertion may be redundant in some invocations.
    // assert self.has_xgov_status(xgov_address), err.NOT_XGOV
    assert // Not an xGov
    // smart_contracts/xgov_registry/contract.py:367
    // del self.xgov_box[xgov_address]
    box_del
    pop
    // smart_contracts/xgov_registry/contract.py:368
    // self.xgovs.value -= 1
    intc_0 // 0
    bytec 10 // 0x78676f7673
    app_global_get_ex
    assert // check self.xgovs exists
    intc_1 // 1
    -
    bytec 10 // 0x78676f7673
    swap
    app_global_put
    // smart_contracts/xgov_registry/contract.py:369
    // arc4.emit(typ.XGovUnsubscribed(xgov=xgov_address))
    pushbytes 0x51099ab0 // method "XGovUnsubscribed(address)"
    frame_dig -1
    concat
    log
    retsub
