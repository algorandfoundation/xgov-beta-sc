# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": []}, "methods": [{"actions": {"call": [], "create": ["NoOp"]}, "args": [{"type": "address", "desc": "Address of the proposer", "name": "proposer"}], "name": "create", "returns": {"type": "string"}, "desc": "Create a new proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "pay", "desc": "Commitment payment transaction from the proposer to the contract", "name": "payment"}, {"type": "string", "desc": "Proposal title, max TITLE_MAX_BYTES bytes", "name": "title"}, {"type": "uint64", "desc": "Funding type (Proactive / Retroactive)", "name": "funding_type"}, {"type": "uint64", "desc": "Requested amount in microAlgos", "name": "requested_amount"}, {"type": "uint8", "desc": "Proposal focus area", "name": "focus"}], "name": "open", "returns": {"type": "void"}, "desc": "Open the first draft of the proposal.", "events": [{"args": [{"type": "uint8", "name": "funding_type"}, {"type": "uint64", "name": "requested_amount"}, {"type": "uint8", "name": "category"}], "name": "Opened", "desc": "The Proposal has been opened"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[]", "desc": "Metadata payload", "name": "payload"}, {"type": "bool", "desc": "True if this is the first upload call in a group transaction", "name": "is_first_in_group"}], "name": "upload_metadata", "returns": {"type": "void"}, "desc": "Upload the proposal metadata.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "drop", "returns": {"type": "string"}, "desc": "Drop the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "submit", "returns": {"type": "void"}, "desc": "submit the proposal.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "(address,uint64)[]", "desc": "List of voter addresses with their voting power", "name": "voters"}], "name": "assign_voters", "returns": {"type": "void"}, "desc": "Assign multiple voters to the proposal.", "events": [{"args": [{"type": "uint64", "name": "vote_opening"}, {"type": "uint64", "name": "vote_closing"}, {"type": "uint32", "name": "quorum_votes"}, {"type": "uint32", "name": "weighted_quorum_votes"}], "name": "Submitted", "desc": "The Proposal has been submitted for voting"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "address", "desc": "Voter address", "name": "voter"}, {"type": "uint64", "desc": "Number of approvals", "name": "approvals"}, {"type": "uint64", "desc": "Number of rejections", "name": "rejections"}], "name": "vote", "returns": {"type": "string"}, "desc": "Vote on the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.", "events": [{"args": [{"type": "address", "name": "xgov"}, {"type": "uint32", "name": "total_voters"}, {"type": "uint32", "name": "total_approvals"}, {"type": "uint32", "name": "total_rejections"}, {"type": "uint32", "name": "total_nulls"}], "name": "Vote", "desc": "A vote has been cast on the Proposal"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "scrutiny", "returns": {"type": "void"}, "desc": "Scrutinize the proposal.", "events": [{"args": [{"type": "bool", "name": "approved"}, {"type": "bool", "name": "plebiscite"}], "name": "Scrutiny", "desc": "The vote has been scrutinized"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "bool", "desc": "Whether to block the proposal or not", "name": "block"}], "name": "review", "returns": {"type": "void"}, "desc": "Review the proposal.", "events": [{"args": [{"type": "bool", "name": "veto"}], "name": "Review", "desc": "The xGov Council has reviewed the Proposal"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "fund", "returns": {"type": "string"}, "desc": "Fund the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "address[]", "desc": "List of voters to be unassigned", "name": "voters"}], "name": "unassign_voters", "returns": {"type": "void"}, "desc": "Unassign voters from the proposal.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "finalize", "returns": {"type": "string"}, "desc": "Finalize the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["DeleteApplication"], "create": []}, "args": [], "name": "delete", "returns": {"type": "void"}, "desc": "Delete the proposal.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "get_state", "returns": {"type": "(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)", "desc": "The proposal state", "struct": "ProposalTypedGlobalState"}, "desc": "Get the proposal state.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "address", "desc": "The address of the Voter", "name": "voter_address"}], "name": "get_voter_box", "returns": {"type": "(uint64,bool)", "desc": "The voter's votes bool: `True` if voter's box exists, else `False`"}, "desc": "Returns the Voter box for the given address.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "op_up", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}], "name": "Proposal", "state": {"keys": {"box": {"metadata": {"key": "TQ==", "keyType": "AVMString", "valueType": "AVMBytes"}}, "global": {"proposer": {"key": "cHJvcG9zZXI=", "keyType": "AVMBytes", "valueType": "address"}, "registry_app_id": {"key": "cmVnaXN0cnlfYXBwX2lk", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "title": {"key": "dGl0bGU=", "keyType": "AVMBytes", "valueType": "AVMString"}, "open_ts": {"key": "b3Blbl90aW1lc3RhbXA=", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "submission_ts": {"key": "c3VibWlzc2lvbl90aW1lc3RhbXA=", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "vote_open_ts": {"key": "dm90ZV9vcGVuaW5nX3RpbWVzdGFtcA==", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "status": {"key": "c3RhdHVz", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "finalized": {"key": "ZmluYWxpemVk", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "funding_category": {"key": "ZnVuZGluZ19jYXRlZ29yeQ==", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "focus": {"key": "Zm9jdXM=", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "funding_type": {"key": "ZnVuZGluZ190eXBl", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "requested_amount": {"key": "cmVxdWVzdGVkX2Ftb3VudA==", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "locked_amount": {"key": "bG9ja2VkX2Ftb3VudA==", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "committee_id": {"key": "Y29tbWl0dGVlX2lk", "keyType": "AVMBytes", "valueType": "byte[32]"}, "committee_members": {"key": "Y29tbWl0dGVlX21lbWJlcnM=", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "committee_votes": {"key": "Y29tbWl0dGVlX3ZvdGVz", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "voted_members": {"key": "dm90ZWRfbWVtYmVycw==", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "approvals": {"key": "YXBwcm92YWxz", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "rejections": {"key": "cmVqZWN0aW9ucw==", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "nulls": {"key": "bnVsbHM=", "keyType": "AVMBytes", "valueType": "AVMUint64"}, "voters_count": {"key": "dm90ZXJzX2NvdW50", "keyType": "AVMString", "valueType": "AVMUint64"}, "assigned_votes": {"key": "YXNzaWduZWRfdm90ZXM=", "keyType": "AVMString", "valueType": "AVMUint64"}, "metadata_uploaded": {"key": "bWV0YWRhdGFfdXBsb2FkZWQ=", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {}}, "maps": {"box": {"voters": {"keyType": "address", "valueType": "uint64", "prefix": "Vg=="}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 3, "ints": 20}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"ProposalTypedGlobalState": [{"name": "proposer", "type": "address"}, {"name": "registry_app_id", "type": "uint64"}, {"name": "title", "type": "string"}, {"name": "open_ts", "type": "uint64"}, {"name": "submission_ts", "type": "uint64"}, {"name": "vote_open_ts", "type": "uint64"}, {"name": "status", "type": "uint64"}, {"name": "finalized", "type": "bool"}, {"name": "funding_category", "type": "uint64"}, {"name": "focus", "type": "uint8"}, {"name": "funding_type", "type": "uint64"}, {"name": "requested_amount", "type": "uint64"}, {"name": "locked_amount", "type": "uint64"}, {"name": "committee_id", "type": "byte[32]"}, {"name": "committee_members", "type": "uint64"}, {"name": "committee_votes", "type": "uint64"}, {"name": "voted_members", "type": "uint64"}, {"name": "approvals", "type": "uint64"}, {"name": "rejections", "type": "uint64"}, {"name": "nulls", "type": "uint64"}]}, "byteCode": {"approval": "CiAFAAEgCpBOJh4CAAAGc3RhdHVzEGZ1bmRpbmdfY2F0ZWdvcnkJZmluYWxpemVkCHByb3Bvc2VyD3JlZ2lzdHJ5X2FwcF9pZAx2b3RlcnNfY291bnQBTRFjb21taXR0ZWVfbWVtYmVycw12b3RlZF9tZW1iZXJzCWFwcHJvdmFscwpyZWplY3Rpb25zBBUffHUPY29tbWl0dGVlX3ZvdGVzBW51bGxzDmFzc2lnbmVkX3ZvdGVzFnZvdGVfb3BlbmluZ190aW1lc3RhbXANbG9ja2VkX2Ftb3VudAEAAVYOb3Blbl90aW1lc3RhbXAMZnVuZGluZ190eXBlEHJlcXVlc3RlZF9hbW91bnQMY29tbWl0dGVlX2lkKAAmRVJSOldyb25nIFByb3Bvc2FsIFN0YXR1cyBvciBmaW5hbGl6ZWQFdGl0bGUUc3VibWlzc2lvbl90aW1lc3RhbXAFZm9jdXMRbWV0YWRhdGFfdXBsb2FkZWQLeGdvdl9kYWVtb24xGEAAcDE1gQMSRDE0gRQSRDE3FEQxNhREJwQyA2cnBSJnJxmAAGcnFCJnJxoiZycQImcpImcrImcqImcnGyJnJxUiZycWImcnESJnJxeAAGcnCCJnJw0iZycJImcnCiJnJwsiZycOImcnBiJnJw8iZyccImeABCQ3jTw2GgCOAQCDMRkURDEYQQBsgg4E7a65ygRxQ5lPBHNxMhoENOYTygQNmrDXBBhBoNIEc02+zAQhLZ8HBIpeTIAEKsGbBQSAIGm0BKjG+AoEJGFfkATb2D3ZNhoAjg4A9gKfAvUDOgQuBS0GywcmB4cHuwhqCUsKGAABACNDgAQhax4HNhoAjgEADQAxGYEFEjEYEERCCQ8iSYAASTYaAUkVJBJEMg1EJwRMZycFMg1nJxeICxlJgAASQQAhgBgAFkVSUjpFbXB0eSBDb21taXR0ZWUgSUQnDExQsCNDJwiICrtJTgJFBkUEKEUGKBNBAAVLA0L/4EsCIg5BACKAHQAbRVJSOldyb25nIENvbW1pdHRlZSBNZW1iZXJzQv+3Jw2ICnlJTgJFBkUDKBNBAAVLA0L/oUsBIg5BACCAGwAZRVJSOldyb25nIENvbW1pdHRlZSBWb3Rlc0L/eicXSwFnJwhLA2cnDUsCZ0sEQv9mIoAARwIxFiMJSTgQIxJENhoBRwIiWYECCEwVEkQ2GgJJFYEIEkQ2GgNJFYEIEkQ2GgRJFSMSRIgKMYgKSEQiKWVEQAFgIitlREABWSNESwNXAgBJRQpLAxdJTgJFCksDF0UISRWBew5EgAATRCUSQAAISweBFBJBAScjRIAUbWluX3JlcXVlc3RlZF9hbW91bnSICZgoEkSAGm1heF9yZXF1ZXN0ZWRfYW1vdW50X2xhcmdliAl2KBJESwdJTwMPRElPAg5ESYgJOksGSTgAIicEZUQSREk4BzIKEkQ4CBJEJxlLCmeAGm1heF9yZXF1ZXN0ZWRfYW1vdW50X3NtYWxsiAkoKBJEgBttYXhfcmVxdWVzdGVkX2Ftb3VudF9tZWRpdW2ICQVMRQooEkQOQQBZKiVnJxVLCGcnFksGSU4CZ0sBFycbTGeICLgnEUxnJxQyB2cpJWciJxVlRBZJk4EIDkRXBwEiJxZlRBYiKmVEFkmTgQgORFcHAU4CUExQgAQ3EkP1TFCwI0NLBUsHDkEAByqBFGdC/5sqgR5nQv+UIkL+1iJC/qQ2GgFHAiJZSU4DSYECCE8CFRJENhoCSRUjEkSICKSICB9MRCccI2cnEhNBABEnB7xIVwIAJwe8SCcHTL8jQycHvURJSwMIJwdM00xXAgAnB04Cu0L/5iJJiAiYRCIpZUQlE0AAByIrZURBACknGEUBKEUCSSgTQQAISScMTFCwI0MiJwRlRIgIhycHvEgrI2dLAUL/5ShFAUL/1SKICCOIB54yByInFGVECSIqZUxJTwJEJRJBAIqAGWRpc2N1c3Npb25fZHVyYXRpb25fc21hbGyIB69FBEsDKBJESwIORCmBFGcnGjIHZ4ARb3Blbl9wcm9wb3NhbF9mZWWIB4UoEkQiJxxlRESAHGRhZW1vbl9vcGVyYXRpb25fZnVuZGluZ19icHOIB1soEkQnHYgHhEkVJBJETgILIQQKiAe9I0NJgRQSQQAkgBpkaXNjdXNzaW9uX2R1cmF0aW9uX21lZGl1bYgHHUUEQv9rgBlkaXNjdXNzaW9uX2R1cmF0aW9uX2xhcmdliAb6RQRC/0iAAEk2GgFHAiJZSU4CgSgLgQIITBUSRIgHPEQiKWVEgRQSRDEWQADQMgRFAyNFBEsDSwMMQQANSwNJiAdXIwhFBEL/6yJFBEsDSwEMQQBFSwFXAgBLBElOAoEoC4EoWElXACBMJFsnE08CUEm9RQEUREsBREsBFr8iJwZlRCMIJwZMZyInD2VECCcPTGcjCEUEQv+zIicGZUQiJwhlRBJBAFQiJw9lRCInDWVEEkQpgRlnJxAyB2ciKmVEiAWPSCInEGVESRZMTwIIFogG3BZJkyQORFcEBIgHOhZJkyQORFcEBE8DTwNQTwJQTFCABJgP1d5MULAjQyKIBphC/0UiRwOAAEcCNhoBSRUkEkQ2GgJJFYEIEkQ2GgNJFYEIEkSIBkFEIillRIEZE0EBLycYRQcoRQlLBigTQQAJSwYnDExQsCNDSwEXRQZJF0UEJxNLA1BJRQm9RQFAANGAFQATRVJSOlZvdGVyIG5vdCBmb3VuZEUHSwYoE0EABUsGQv+9SwdJvkQXIicJZUQjCCcJTGdJSwhJTgIJSwdJTgMJIicKZURPAggnCkxnIicLZURPAggnC0xnIicOZUQIJw5MZ0sETIgHFUkVI0sBDyNLAk8CTUxSSRUkEkQiJwllRBZJkyQORFcEBCInCmVEFkmTJA5EVwQEIicLZUQWSZMkDkRXBAQiJw5lRBZJkyQORFcEBE8ETwRQTwNQTwJQTFCABBV39udMULBLCEL/EUsHvkQXSwZLBQgMQQAbgBQAEkVSUjpWb3RlcyBleGNlZWRlZEUHQv8fSwhFB0L/GIgDt0lOAkUJRQYoRQsoE0D+w0sEQAAigBsAGUVSUjpWb3RpbmcgUGVyaW9kIEV4cGlyZWRFB0L+nEsJRQdC/pWIBJMiKWVEgRkSRIgDbCgSREEABogDjUEAPSNEiAXdQQAmKYEeZ4gF0ycSIk8CVIgDcicSIk8CVCJTI0xUgAQr2ZrkTFCwI0MpgShnIicEZUSIBJBC/88iQv/ANhoBRwIVIxJEIlMxAIAMeGdvdl9jb3VuY2lsiAQQSRUkEkQSRCIpZUSBHhJEIicGZUQUREEAGymBPGciJwVlRHIIRIgEQ4AE2ZOWREsBULAjQymBLWciJwRlRIgEK0L/5SJJiAQGRCIpZUSBLRNBAB4nGEUBKEUCSSgTQQAISScMTFCwI0MpgTJnSwFC//AoRQFC/+AiSYAARwI2GgFHAiJZSU4CJAuBAghMFRJEIillRIEUEkEAaIgDo0QxFkAAWDIERQMjRQVLBEsDDEEADUsESYgDxiMIRQVC/+siRQRLA0sBDEEAL0sBVwIASwQkCyRYSUUHJxNMUElFCL1FAUEAC0sGvkQXSwZMiATWSwMjCEUEQv/JI0MiiAN/Qv+9IillRIEeEkAACiIpZUSBKBJBAAwiK2VEQAAFI0RC/3wiQv/4IkmIAyNEIitlREAALiIpZURBAKgiKWVEJRNBAJ8iKWVEgTITQQCVIillRIE8E0EAiyIpZUSBKBNBAIEnGEUBKEUCSSgTQQAISScMTFCwI0MiJwZlREEANYAwAC5FUlI6VGhlcmUgYXJlIHZvdGVycyBhc3NpZ25lZCB0byB0aGlzIHByb3Bvc2FsQv+8IillRCUSQQAIIicEZUSIAqciJwVlRHIIRDIKcwBEMgpzAUQJiAJ9KyNnSwFC/40oRQFC/32IAlVEIitlREQnB7xIIicFZURyCEQyCnMARIgCUiNDIicEZUQiJwVlRBYiJxllREkVFlcGAkxQIicUZUQWIicaZUQWIicQZUQWIillRBYiK2VEJxIiTwJUIiplRBYiJxtlRBZJk4EIDkRXBwEiJxVlRBYiJxZlRBYiJxFlRBYiJxdlRCInCGVEFiInDWVEFiInCWVEFiInCmVEFiInC2VEFiInDmVEFk8TTxNQgAIAvFBPEVBPEFBPD1BPDlBPDVBPDFBPC1BPClBPCVBPCFBPB1BPBlBPBVBPBFBPA1BPAlBMUExQJwxMULAjQzYaAUkVJBJEJxNMUEm9SU8CSEEAFEsBvkQXFicSIksDVFAnDExQsCNDIkL/7YoAAjIHIicQZUQJIiplRIgAJElPAkwoE0EABCKMAImLAIsCDiiMAYwAiSInCWVEIicIZUQSiYoBAov/JRJBABuAFXZvdGluZ19kdXJhdGlvbl9zbWFsbIgAhImL/4EUEkEAHIAWdm90aW5nX2R1cmF0aW9uX21lZGl1bYgAYImAFXZvdGluZ19kdXJhdGlvbl9sYXJnZYgARYmIAJlEIillRCUSQQAKIitlREAAAyNEiSJC//qKAQGAF3Byb3Bvc2FsX2NvbW1pdG1lbnRfYnBziAAKKBJEi/8LIQQKiYoBAiInBWVEi/9lKExAABiAFAASRVJSOk1pc3NpbmcgQ29uZmlnjAGLAIsBTwNPA4mKAQEiJwVlRIv/ZUSJgA9wYXVzZWRfcmVnaXN0cnmI/64oEkQURIkxACInBGVEEokxACcdiP/JSRUkEkQSiTINIicFZUQSiYoCALGL/7IIi/6yByOyECKyAbOJigEAIicRZUSL/0yI/94nESJniYoBAIv/OBgyCBJEi/85GgA2GgASRImKAAEiSSplTElPAkQlEkEAJIAMcXVvcnVtX3NtYWxsiP8pjACLACgSRCInCGVECyEECowAiYsBgRQSQQAXgA1xdW9ydW1fbWVkaXVtiP78jABC/9CADHF1b3J1bV9sYXJnZYj+5owAQv+6igABIkkqZUxJTwJEJRJBAC2AFXdlaWdodGVkX3F1b3J1bV9zbWFsbIj+towAiwAoEkQiJw1lRAshBAqMAImLAYEUEkEAIIAWd2VpZ2h0ZWRfcXVvcnVtX21lZGl1bYj+gIwAQv/HgBV3ZWlnaHRlZF9xdW9ydW1fbGFyZ2WI/mGMAEL/qIoAAYj/C4j/ckwiJwplRCInC2VECCInDmVECEwiJwllRA5BABqLAYsAD0EAEiInCmVEIicLZUQNQQAEI4wAiSJC//mKAgAiJwZlRCMJJwZMZyInD2VEi/8JJw9MZycTi/5QvEiJ", "clear": "CoEBQw=="}, "events": [{"args": [{"type": "uint8", "name": "funding_type"}, {"type": "uint64", "name": "requested_amount"}, {"type": "uint8", "name": "category"}], "name": "Opened", "desc": "The Proposal has been opened"}, {"args": [{"type": "uint64", "name": "vote_opening"}, {"type": "uint64", "name": "vote_closing"}, {"type": "uint32", "name": "quorum_votes"}, {"type": "uint32", "name": "weighted_quorum_votes"}], "name": "Submitted", "desc": "The Proposal has been submitted for voting"}, {"args": [{"type": "address", "name": "xgov"}, {"type": "uint32", "name": "total_voters"}, {"type": "uint32", "name": "total_approvals"}, {"type": "uint32", "name": "total_rejections"}, {"type": "uint32", "name": "total_nulls"}], "name": "Vote", "desc": "A vote has been cast on the Proposal"}, {"args": [{"type": "bool", "name": "approved"}, {"type": "bool", "name": "plebiscite"}], "name": "Scrutiny", "desc": "The vote has been scrutinized"}, {"args": [{"type": "bool", "name": "veto"}], "name": "Review", "desc": "The xGov Council has reviewed the Proposal"}], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMzIgMTAgMTAwMDAKICAgIGJ5dGVjYmxvY2sgMHgwMDAwIDB4NzM3NDYxNzQ3NTczIDB4NjY3NTZlNjQ2OTZlNjc1ZjYzNjE3NDY1Njc2ZjcyNzkgMHg2NjY5NmU2MTZjNjk3YTY1NjQgMHg3MDcyNmY3MDZmNzM2NTcyIDB4NzI2NTY3Njk3Mzc0NzI3OTVmNjE3MDcwNWY2OTY0ICJ2b3RlcnNfY291bnQiICJNIiAweDYzNmY2ZDZkNjk3NDc0NjU2NTVmNmQ2NTZkNjI2NTcyNzMgMHg3NjZmNzQ2NTY0NWY2ZDY1NmQ2MjY1NzI3MyAweDYxNzA3MDcyNmY3NjYxNmM3MyAweDcyNjU2YTY1NjM3NDY5NmY2ZTczIDB4MTUxZjdjNzUgMHg2MzZmNmQ2ZDY5NzQ3NDY1NjU1Zjc2NmY3NDY1NzMgMHg2ZTc1NmM2YzczICJhc3NpZ25lZF92b3RlcyIgMHg3NjZmNzQ2NTVmNmY3MDY1NmU2OTZlNjc1Zjc0Njk2ZDY1NzM3NDYxNmQ3MCAweDZjNmY2MzZiNjU2NDVmNjE2ZDZmNzU2ZTc0IDB4MDAgIlYiIDB4NmY3MDY1NmU1Zjc0Njk2ZDY1NzM3NDYxNmQ3MCAweDY2NzU2ZTY0Njk2ZTY3NWY3NDc5NzA2NSAweDcyNjU3MTc1NjU3Mzc0NjU2NDVmNjE2ZDZmNzU2ZTc0IDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY2OTY0IDB4MDAyNjQ1NTI1MjNhNTc3MjZmNmU2NzIwNTA3MjZmNzA2ZjczNjE2YzIwNTM3NDYxNzQ3NTczMjA2ZjcyMjA2NjY5NmU2MTZjNjk3YTY1NjQgMHg3NDY5NzQ2YzY1IDB4NzM3NTYyNmQ2OTczNzM2OTZmNmU1Zjc0Njk2ZDY1NzM3NDYxNmQ3MCAweDY2NmY2Mzc1NzMgIm1ldGFkYXRhX3VwbG9hZGVkIiAweDc4Njc2Zjc2NWY2NDYxNjU2ZDZmNmUKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0NgogICAgLy8gVHhuLmdsb2JhbF9udW1fYnl0ZV9zbGljZSA9PSBwcm9wX2NmZy5HTE9CQUxfQllURVMKICAgIHR4biBHbG9iYWxOdW1CeXRlU2xpY2UKICAgIHB1c2hpbnQgMyAvLyAzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ0LTQ3CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgVHhuLmdsb2JhbF9udW1fYnl0ZV9zbGljZSA9PSBwcm9wX2NmZy5HTE9CQUxfQllURVMKICAgIC8vICksIGVyci5XUk9OR19HTE9CQUxfQllURVMKICAgIGFzc2VydCAvLyBXcm9uZyBHbG9iYWwgQnl0ZXMgYWxsb2NhdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ4CiAgICAvLyBhc3NlcnQgVHhuLmdsb2JhbF9udW1fdWludCA9PSBwcm9wX2NmZy5HTE9CQUxfVUlOVFMsIGVyci5XUk9OR19HTE9CQUxfVUlOVFMKICAgIHR4biBHbG9iYWxOdW1VaW50CiAgICBwdXNoaW50IDIwIC8vIDIwCiAgICA9PQogICAgYXNzZXJ0IC8vIFdyb25nIEdsb2JhbCBVSW50cyBhbGxvY2F0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDkKICAgIC8vIGFzc2VydCBUeG4ubG9jYWxfbnVtX2J5dGVfc2xpY2UgPT0gcHJvcF9jZmcuTE9DQUxfQllURVMsIGVyci5XUk9OR19MT0NBTF9CWVRFUwogICAgdHhuIExvY2FsTnVtQnl0ZVNsaWNlCiAgICAhCiAgICBhc3NlcnQgLy8gV3JvbmcgTG9jYWwgQnl0ZXMgYWxsb2NhdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUwCiAgICAvLyBhc3NlcnQgVHhuLmxvY2FsX251bV91aW50ID09IHByb3BfY2ZnLkxPQ0FMX1VJTlRTLCBlcnIuV1JPTkdfTE9DQUxfVUlOVFMKICAgIHR4biBMb2NhbE51bVVpbnQKICAgICEKICAgIGFzc2VydCAvLyBXcm9uZyBMb2NhbCBVSW50cyBhbGxvY2F0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTUKICAgIC8vIGtleT1wcm9wX2NmZy5HU19LRVlfUFJPUE9TRVIsCiAgICBieXRlYyA0IC8vIDB4NzA3MjZmNzA2ZjczNjU3MgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU0CiAgICAvLyBBY2NvdW50KCksCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1Mi01NgogICAgLy8gIyBHbG9iYWwgVmFyaWFibGVzCiAgICAvLyBzZWxmLnByb3Bvc2VyID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgQWNjb3VudCgpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfUFJPUE9TRVIsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU5CiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX1JFR0lTVFJZX0FQUF9JRCwKICAgIGJ5dGVjIDUgLy8gMHg3MjY1Njc2OTczNzQ3Mjc5NWY2MTcwNzA1ZjY5NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1OAogICAgLy8gVUludDY0KCksCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU3LTYwCiAgICAvLyBzZWxmLnJlZ2lzdHJ5X2FwcF9pZCA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFVJbnQ2NCgpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfUkVHSVNUUllfQVBQX0lELAogICAgLy8gKQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2MwogICAgLy8ga2V5PXByb3BfY2ZnLkdTX0tFWV9USVRMRSwKICAgIGJ5dGVjIDI1IC8vIDB4NzQ2OTc0NmM2NQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjYyCiAgICAvLyBTdHJpbmcoKSwKICAgIHB1c2hieXRlcyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjYxLTY0CiAgICAvLyBzZWxmLnRpdGxlID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgU3RyaW5nKCksCiAgICAvLyAgICAga2V5PXByb3BfY2ZnLkdTX0tFWV9USVRMRSwKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjcKICAgIC8vIGtleT1wcm9wX2NmZy5HU19LRVlfT1BFTl9UUywKICAgIGJ5dGVjIDIwIC8vIDB4NmY3MDY1NmU1Zjc0Njk2ZDY1NzM3NDYxNmQ3MAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY2CiAgICAvLyBVSW50NjQoKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjUtNjgKICAgIC8vIHNlbGYub3Blbl90cyA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFVJbnQ2NCgpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfT1BFTl9UUywKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzEKICAgIC8vIGtleT1wcm9wX2NmZy5HU19LRVlfU1VCTUlTU0lPTl9UUywKICAgIGJ5dGVjIDI2IC8vIDB4NzM3NTYyNmQ2OTczNzM2OTZmNmU1Zjc0Njk2ZDY1NzM3NDYxNmQ3MAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjcwCiAgICAvLyBVSW50NjQoKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjktNzIKICAgIC8vIHNlbGYuc3VibWlzc2lvbl90cyA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFVJbnQ2NCgpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfU1VCTUlTU0lPTl9UUywKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzUKICAgIC8vIGtleT1wcm9wX2NmZy5HU19LRVlfVk9URV9PUEVOX1RTLAogICAgYnl0ZWMgMTYgLy8gMHg3NjZmNzQ2NTVmNmY3MDY1NmU2OTZlNjc1Zjc0Njk2ZDY1NzM3NDYxNmQ3MAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc0CiAgICAvLyBVSW50NjQoKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzMtNzYKICAgIC8vIHNlbGYudm90ZV9vcGVuX3RzID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgVUludDY0KCksCiAgICAvLyAgICAga2V5PXByb3BfY2ZnLkdTX0tFWV9WT1RFX09QRU5fVFMsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc5CiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX1NUQVRVUywKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo3OAogICAgLy8gVUludDY0KGVubS5TVEFUVVNfRU1QVFkpLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo3Ny04MAogICAgLy8gc2VsZi5zdGF0dXMgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBVSW50NjQoZW5tLlNUQVRVU19FTVBUWSksCiAgICAvLyAgICAga2V5PXByb3BfY2ZnLkdTX0tFWV9TVEFUVVMsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgzCiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX0ZJTkFMSVpFRCwKICAgIGJ5dGVjXzMgLy8gMHg2NjY5NmU2MTZjNjk3YTY1NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MgogICAgLy8gRmFsc2UsICAjIG5vcWE6IEZCVDAwMwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MS04NAogICAgLy8gc2VsZi5maW5hbGl6ZWQgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBGYWxzZSwgICMgbm9xYTogRkJUMDAzCiAgICAvLyAgICAga2V5PXByb3BfY2ZnLkdTX0tFWV9GSU5BTElaRUQsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojg3CiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX0ZVTkRJTkdfQ0FURUdPUlksCiAgICBieXRlY18yIC8vIDB4NjY3NTZlNjQ2OTZlNjc1ZjYzNjE3NDY1Njc2ZjcyNzkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4NgogICAgLy8gVUludDY0KGVubS5GVU5ESU5HX0NBVEVHT1JZX05VTEwpLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4NS04OAogICAgLy8gc2VsZi5mdW5kaW5nX2NhdGVnb3J5ID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgVUludDY0KGVubS5GVU5ESU5HX0NBVEVHT1JZX05VTEwpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfRlVORElOR19DQVRFR09SWSwKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTEKICAgIC8vIGtleT1wcm9wX2NmZy5HU19LRVlfRk9DVVMsCiAgICBieXRlYyAyNyAvLyAweDY2NmY2Mzc1NzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5MAogICAgLy8gVUludDY0KGVubS5GT0NVU19OVUxMKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODktOTIKICAgIC8vIHNlbGYuZm9jdXMgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBVSW50NjQoZW5tLkZPQ1VTX05VTEwpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfRk9DVVMsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk1CiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX0ZVTkRJTkdfVFlQRSwKICAgIGJ5dGVjIDIxIC8vIDB4NjY3NTZlNjQ2OTZlNjc1Zjc0Nzk3MDY1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTQKICAgIC8vIFVJbnQ2NChlbm0uRlVORElOR19OVUxMKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTMtOTYKICAgIC8vIHNlbGYuZnVuZGluZ190eXBlID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgVUludDY0KGVubS5GVU5ESU5HX05VTEwpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfRlVORElOR19UWVBFLAogICAgLy8gKQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5OQogICAgLy8ga2V5PXByb3BfY2ZnLkdTX0tFWV9SRVFVRVNURURfQU1PVU5ULAogICAgYnl0ZWMgMjIgLy8gMHg3MjY1NzE3NTY1NzM3NDY1NjQ1ZjYxNmQ2Zjc1NmU3NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk4CiAgICAvLyBVSW50NjQoKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyBzZWxmLnJlcXVlc3RlZF9hbW91bnQgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBVSW50NjQoKSwKICAgIC8vICAgICBrZXk9cHJvcF9jZmcuR1NfS0VZX1JFUVVFU1RFRF9BTU9VTlQsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwMwogICAgLy8ga2V5PXByb3BfY2ZnLkdTX0tFWV9MT0NLRURfQU1PVU5ULAogICAgYnl0ZWMgMTcgLy8gMHg2YzZmNjM2YjY1NjQ1ZjYxNmQ2Zjc1NmU3NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwMgogICAgLy8gVUludDY0KCksCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwMS0xMDQKICAgIC8vIHNlbGYubG9ja2VkX2Ftb3VudCA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFVJbnQ2NCgpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfTE9DS0VEX0FNT1VOVCwKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA3CiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX0NPTU1JVFRFRV9JRCwKICAgIGJ5dGVjIDIzIC8vIDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY2OTY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA2CiAgICAvLyB0eXAuQnl0ZXMzMi5mcm9tX2J5dGVzKGIiIiksCiAgICBwdXNoYnl0ZXMgMHgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDUtMTA4CiAgICAvLyBzZWxmLmNvbW1pdHRlZV9pZCA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIHR5cC5CeXRlczMyLmZyb21fYnl0ZXMoYiIiKSwKICAgIC8vICAgICBrZXk9cHJvcF9jZmcuR1NfS0VZX0NPTU1JVFRFRV9JRCwKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTExCiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX0NPTU1JVFRFRV9NRU1CRVJTLAogICAgYnl0ZWMgOCAvLyAweDYzNmY2ZDZkNjk3NDc0NjU2NTVmNmQ2NTZkNjI2NTcyNzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMTAKICAgIC8vIFVJbnQ2NCgpLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDktMTEyCiAgICAvLyBzZWxmLmNvbW1pdHRlZV9tZW1iZXJzID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgVUludDY0KCksCiAgICAvLyAgICAga2V5PXByb3BfY2ZnLkdTX0tFWV9DT01NSVRURUVfTUVNQkVSUywKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTE1CiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX0NPTU1JVFRFRV9WT1RFUywKICAgIGJ5dGVjIDEzIC8vIDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY3NjZmNzQ2NTczCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTE0CiAgICAvLyBVSW50NjQoKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTEzLTExNgogICAgLy8gc2VsZi5jb21taXR0ZWVfdm90ZXMgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBVSW50NjQoKSwKICAgIC8vICAgICBrZXk9cHJvcF9jZmcuR1NfS0VZX0NPTU1JVFRFRV9WT1RFUywKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTE5CiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX1ZPVEVEX01FTUJFUlMsCiAgICBieXRlYyA5IC8vIDB4NzY2Zjc0NjU2NDVmNmQ2NTZkNjI2NTcyNzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMTgKICAgIC8vIFVJbnQ2NCgpLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMTctMTIwCiAgICAvLyBzZWxmLnZvdGVkX21lbWJlcnMgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBVSW50NjQoKSwKICAgIC8vICAgICBrZXk9cHJvcF9jZmcuR1NfS0VZX1ZPVEVEX01FTUJFUlMsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEyMwogICAgLy8ga2V5PXByb3BfY2ZnLkdTX0tFWV9BUFBST1ZBTFMsCiAgICBieXRlYyAxMCAvLyAweDYxNzA3MDcyNmY3NjYxNmM3MwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEyMgogICAgLy8gVUludDY0KCksCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEyMS0xMjQKICAgIC8vIHNlbGYuYXBwcm92YWxzID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgVUludDY0KCksCiAgICAvLyAgICAga2V5PXByb3BfY2ZnLkdTX0tFWV9BUFBST1ZBTFMsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEyNwogICAgLy8ga2V5PXByb3BfY2ZnLkdTX0tFWV9SRUpFQ1RJT05TLAogICAgYnl0ZWMgMTEgLy8gMHg3MjY1NmE2NTYzNzQ2OTZmNmU3MwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEyNgogICAgLy8gVUludDY0KCksCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEyNS0xMjgKICAgIC8vIHNlbGYucmVqZWN0aW9ucyA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFVJbnQ2NCgpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfUkVKRUNUSU9OUywKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTMxCiAgICAvLyBrZXk9cHJvcF9jZmcuR1NfS0VZX05VTExTLAogICAgYnl0ZWMgMTQgLy8gMHg2ZTc1NmM2YzczCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTMwCiAgICAvLyBVSW50NjQoKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTI5LTEzMgogICAgLy8gc2VsZi5udWxscyA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFVJbnQ2NCgpLAogICAgLy8gICAgIGtleT1wcm9wX2NmZy5HU19LRVlfTlVMTFMsCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEzMwogICAgLy8gc2VsZi52b3RlcnNfY291bnQgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDYgLy8gInZvdGVyc19jb3VudCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEzNAogICAgLy8gc2VsZi5hc3NpZ25lZF92b3RlcyA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTUgLy8gImFzc2lnbmVkX3ZvdGVzIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTM1CiAgICAvLyBzZWxmLm1ldGFkYXRhX3VwbG9hZGVkID0gRmFsc2UKICAgIGJ5dGVjIDI4IC8vICJtZXRhZGF0YV91cGxvYWRlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAoKbWFpbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzQtNDIKICAgIC8vIGNsYXNzIFByb3Bvc2FsKAogICAgLy8gICAgIEFSQzRDb250cmFjdCwKICAgIC8vICAgICBzdGF0ZV90b3RhbHM9U3RhdGVUb3RhbHMoCiAgICAvLyAgICAgICAgIGdsb2JhbF9ieXRlcz1wcm9wX2NmZy5HTE9CQUxfQllURVMsCiAgICAvLyAgICAgICAgIGdsb2JhbF91aW50cz1wcm9wX2NmZy5HTE9CQUxfVUlOVFMsCiAgICAvLyAgICAgICAgIGxvY2FsX2J5dGVzPXByb3BfY2ZnLkxPQ0FMX0JZVEVTLAogICAgLy8gICAgICAgICBsb2NhbF91aW50cz1wcm9wX2NmZy5MT0NBTF9VSU5UUywKICAgIC8vICAgICApLAogICAgLy8gKToKICAgIHB1c2hieXRlcyAweDI0Mzc4ZDNjIC8vIG1ldGhvZCAiZGVsZXRlKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWFpbl9kZWxldGVfcm91dGVANAoKbWFpbl9zd2l0Y2hfY2FzZV9uZXh0QDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzQtNDIKICAgIC8vIGNsYXNzIFByb3Bvc2FsKAogICAgLy8gICAgIEFSQzRDb250cmFjdCwKICAgIC8vICAgICBzdGF0ZV90b3RhbHM9U3RhdGVUb3RhbHMoCiAgICAvLyAgICAgICAgIGdsb2JhbF9ieXRlcz1wcm9wX2NmZy5HTE9CQUxfQllURVMsCiAgICAvLyAgICAgICAgIGdsb2JhbF91aW50cz1wcm9wX2NmZy5HTE9CQUxfVUlOVFMsCiAgICAvLyAgICAgICAgIGxvY2FsX2J5dGVzPXByb3BfY2ZnLkxPQ0FMX0JZVEVTLAogICAgLy8gICAgICAgICBsb2NhbF91aW50cz1wcm9wX2NmZy5MT0NBTF9VSU5UUywKICAgIC8vICAgICApLAogICAgLy8gKToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYnogbWFpbl9jcmVhdGVfTm9PcEAyMgogICAgcHVzaGJ5dGVzcyAweGVkYWViOWNhIDB4NzE0Mzk5NGYgMHg3MzcxMzIxYSAweDM0ZTYxM2NhIDB4MGQ5YWIwZDcgMHgxODQxYTBkMiAweDczNGRiZWNjIDB4MjEyZDlmMDcgMHg4YTVlNGM4MCAweDJhYzE5YjA1IDB4ODAyMDY5YjQgMHhhOGM2ZjgwYSAweDI0NjE1ZjkwIDB4ZGJkODNkZDkgLy8gbWV0aG9kICJvcGVuKHBheSxzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50OCl2b2lkIiwgbWV0aG9kICJ1cGxvYWRfbWV0YWRhdGEoYnl0ZVtdLGJvb2wpdm9pZCIsIG1ldGhvZCAiZHJvcCgpc3RyaW5nIiwgbWV0aG9kICJzdWJtaXQoKXZvaWQiLCBtZXRob2QgImFzc2lnbl92b3RlcnMoKGFkZHJlc3MsdWludDY0KVtdKXZvaWQiLCBtZXRob2QgInZvdGUoYWRkcmVzcyx1aW50NjQsdWludDY0KXN0cmluZyIsIG1ldGhvZCAic2NydXRpbnkoKXZvaWQiLCBtZXRob2QgInJldmlldyhib29sKXZvaWQiLCBtZXRob2QgImZ1bmQoKXN0cmluZyIsIG1ldGhvZCAidW5hc3NpZ25fdm90ZXJzKGFkZHJlc3NbXSl2b2lkIiwgbWV0aG9kICJmaW5hbGl6ZSgpc3RyaW5nIiwgbWV0aG9kICJnZXRfc3RhdGUoKShhZGRyZXNzLHVpbnQ2NCxzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LGJvb2wsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LGJ5dGVbMzJdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiZ2V0X3ZvdGVyX2JveChhZGRyZXNzKSh1aW50NjQsYm9vbCkiLCBtZXRob2QgIm9wX3VwKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggb3BlbiB1cGxvYWRfbWV0YWRhdGEgZHJvcCBzdWJtaXQgYXNzaWduX3ZvdGVycyB2b3RlIHNjcnV0aW55IHJldmlldyBmdW5kIHVuYXNzaWduX3ZvdGVycyBmaW5hbGl6ZSBnZXRfc3RhdGUgZ2V0X3ZvdGVyX2JveCBtYWluX29wX3VwX3JvdXRlQDIwCiAgICBlcnIKCm1haW5fb3BfdXBfcm91dGVAMjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTExOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX05vT3BAMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzQtNDIKICAgIC8vIGNsYXNzIFByb3Bvc2FsKAogICAgLy8gICAgIEFSQzRDb250cmFjdCwKICAgIC8vICAgICBzdGF0ZV90b3RhbHM9U3RhdGVUb3RhbHMoCiAgICAvLyAgICAgICAgIGdsb2JhbF9ieXRlcz1wcm9wX2NmZy5HTE9CQUxfQllURVMsCiAgICAvLyAgICAgICAgIGdsb2JhbF91aW50cz1wcm9wX2NmZy5HTE9CQUxfVUlOVFMsCiAgICAvLyAgICAgICAgIGxvY2FsX2J5dGVzPXByb3BfY2ZnLkxPQ0FMX0JZVEVTLAogICAgLy8gICAgICAgICBsb2NhbF91aW50cz1wcm9wX2NmZy5MT0NBTF9VSU5UUywKICAgIC8vICAgICApLAogICAgLy8gKToKICAgIHB1c2hieXRlcyAweDIxNmIxZTA3IC8vIG1ldGhvZCAiY3JlYXRlKGFkZHJlc3Mpc3RyaW5nIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggY3JlYXRlCiAgICBlcnIKCm1haW5fZGVsZXRlX3JvdXRlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA0NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9KCJEZWxldGVBcHBsaWNhdGlvbiIsKSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNSAvLyBEZWxldGVBcHBsaWNhdGlvbgogICAgPT0KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAmJgogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIERlbGV0ZUFwcGxpY2F0aW9uICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGIgZGVsZXRlCgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIGludGNfMCAvLyAwCiAgICBkdXAKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTgzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoY3JlYXRlPSJyZXF1aXJlIikKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU5OAogICAgLy8gR2xvYmFsLmNhbGxlcl9hcHBsaWNhdGlvbl9pZCAhPSAwCiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU5Ny01OTkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgR2xvYmFsLmNhbGxlcl9hcHBsaWNhdGlvbl9pZCAhPSAwCiAgICAvLyApLCBlcnIuVU5BVVRIT1JJWkVEICAjIE9ubHkgY2FsbGFibGUgYnkgYW5vdGhlciBjb250cmFjdAogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjYwMQogICAgLy8gc2VsZi5wcm9wb3Nlci52YWx1ZSA9IHByb3Bvc2VyLm5hdGl2ZQogICAgYnl0ZWMgNCAvLyAweDcwNzI2ZjcwNmY3MzY1NzIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjAyCiAgICAvLyBzZWxmLnJlZ2lzdHJ5X2FwcF9pZC52YWx1ZSA9IEdsb2JhbC5jYWxsZXJfYXBwbGljYXRpb25faWQKICAgIGJ5dGVjIDUgLy8gMHg3MjY1Njc2OTczNzQ3Mjc5NWY2MTcwNzA1ZjY5NjQKICAgIGdsb2JhbCBDYWxsZXJBcHBsaWNhdGlvbklECiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjMzMAogICAgLy8gc2VsZi5nZXRfYnl0ZXNfZnJvbV9yZWdpc3RyeV9jb25maWcoQnl0ZXMocmVnX2NmZy5HU19LRVlfQ09NTUlUVEVFX0lEKSkKICAgIGJ5dGVjIDIzIC8vIDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY2OTY0CiAgICBjYWxsc3ViIGdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjMyOS0zMzEKICAgIC8vIGNvbW1pdHRlZV9pZCA9IHR5cC5CeXRlczMyLmZyb21fYnl0ZXMoCiAgICAvLyAgICAgc2VsZi5nZXRfYnl0ZXNfZnJvbV9yZWdpc3RyeV9jb25maWcoQnl0ZXMocmVnX2NmZy5HU19LRVlfQ09NTUlUVEVFX0lEKSkKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjMzMgogICAgLy8gaWYgY29tbWl0dGVlX2lkID09IHR5cC5CeXRlczMyLmZyb21fYnl0ZXMoYiIiKToKICAgIHB1c2hieXRlcyAweAogICAgPT0KICAgIGJ6IGNyZWF0ZV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMzMKICAgIC8vIHJldHVybiB0eXAuRXJyb3IoZXJyLkFSQ182NV9QUkVGSVggKyBlcnIuRU1QVFlfQ09NTUlUVEVFX0lEKQogICAgcHVzaGJ5dGVzIDB4MDAxNjQ1NTI1MjNhNDU2ZDcwNzQ3OTIwNDM2ZjZkNmQ2OTc0NzQ2NTY1MjA0OTQ0CgpjcmVhdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudmVyaWZ5X2FuZF9zZXRfY29tbWl0dGVlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICBieXRlYyAxMiAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKY3JlYXRlX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMzYKICAgIC8vIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX0NPTU1JVFRFRV9NRU1CRVJTKQogICAgYnl0ZWMgOCAvLyAweDYzNmY2ZDZkNjk3NDc0NjU2NTVmNmQ2NTZkNjI2NTcyNzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMzUtMzM3CiAgICAvLyBjb21taXR0ZWVfbWVtYmVycywgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX0NPTU1JVFRFRV9NRU1CRVJTKQogICAgLy8gKQogICAgY2FsbHN1YiBnZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDYKICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjMzOAogICAgLy8gaWYgZXJyb3IgIT0gdHlwLkVycm9yKCIiKToKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICBidXJ5IDYKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAhPQogICAgYnogY3JlYXRlX2FmdGVyX2lmX2Vsc2VANQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2MDQKICAgIC8vIHJldHVybiBzZWxmLnZlcmlmeV9hbmRfc2V0X2NvbW1pdHRlZSgpCiAgICBiIGNyZWF0ZV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC52ZXJpZnlfYW5kX3NldF9jb21taXR0ZWVAMTIKCmNyZWF0ZV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzQwCiAgICAvLyBpZiBjb21taXR0ZWVfbWVtYmVycyA8PSBVSW50NjQoMCk6CiAgICBkaWcgMgogICAgaW50Y18wIC8vIDAKICAgIDw9CiAgICBieiBjcmVhdGVfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzQxCiAgICAvLyByZXR1cm4gdHlwLkVycm9yKGVyci5BUkNfNjVfUFJFRklYICsgZXJyLldST05HX0NPTU1JVFRFRV9NRU1CRVJTKQogICAgcHVzaGJ5dGVzIDB4MDAxYjQ1NTI1MjNhNTc3MjZmNmU2NzIwNDM2ZjZkNmQ2OTc0NzQ2NTY1MjA0ZDY1NmQ2MjY1NzI3MwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjYwNAogICAgLy8gcmV0dXJuIHNlbGYudmVyaWZ5X2FuZF9zZXRfY29tbWl0dGVlKCkKICAgIGIgY3JlYXRlX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLnZlcmlmeV9hbmRfc2V0X2NvbW1pdHRlZUAxMgoKY3JlYXRlX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNDQKICAgIC8vIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX0NPTU1JVFRFRV9WT1RFUykKICAgIGJ5dGVjIDEzIC8vIDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY3NjZmNzQ2NTczCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzQzLTM0NQogICAgLy8gY29tbWl0dGVlX3ZvdGVzLCBlcnJvciA9IHNlbGYuZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcoCiAgICAvLyAgICAgQnl0ZXMocmVnX2NmZy5HU19LRVlfQ09NTUlUVEVFX1ZPVEVTKQogICAgLy8gKQogICAgY2FsbHN1YiBnZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDYKICAgIGJ1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjMzOAogICAgLy8gaWYgZXJyb3IgIT0gdHlwLkVycm9yKCIiKToKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzQ2CiAgICAvLyBpZiBlcnJvciAhPSB0eXAuRXJyb3IoIiIpOgogICAgIT0KICAgIGJ6IGNyZWF0ZV9hZnRlcl9pZl9lbHNlQDkKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjA0CiAgICAvLyByZXR1cm4gc2VsZi52ZXJpZnlfYW5kX3NldF9jb21taXR0ZWUoKQogICAgYiBjcmVhdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudmVyaWZ5X2FuZF9zZXRfY29tbWl0dGVlQDEyCgpjcmVhdGVfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjM0OAogICAgLy8gaWYgY29tbWl0dGVlX3ZvdGVzIDw9IFVJbnQ2NCgwKToKICAgIGRpZyAxCiAgICBpbnRjXzAgLy8gMAogICAgPD0KICAgIGJ6IGNyZWF0ZV9hZnRlcl9pZl9lbHNlQDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzQ5CiAgICAvLyByZXR1cm4gdHlwLkVycm9yKGVyci5BUkNfNjVfUFJFRklYICsgZXJyLldST05HX0NPTU1JVFRFRV9WT1RFUykKICAgIHB1c2hieXRlcyAweDAwMTk0NTUyNTIzYTU3NzI2ZjZlNjcyMDQzNmY2ZDZkNjk3NDc0NjU2NTIwNTY2Zjc0NjU3MwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjYwNAogICAgLy8gcmV0dXJuIHNlbGYudmVyaWZ5X2FuZF9zZXRfY29tbWl0dGVlKCkKICAgIGIgY3JlYXRlX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLnZlcmlmeV9hbmRfc2V0X2NvbW1pdHRlZUAxMgoKY3JlYXRlX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzUxCiAgICAvLyBzZWxmLmNvbW1pdHRlZV9pZC52YWx1ZSA9IGNvbW1pdHRlZV9pZC5jb3B5KCkKICAgIGJ5dGVjIDIzIC8vIDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY2OTY0CiAgICBkaWcgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNTIKICAgIC8vIHNlbGYuY29tbWl0dGVlX21lbWJlcnMudmFsdWUgPSBjb21taXR0ZWVfbWVtYmVycwogICAgYnl0ZWMgOCAvLyAweDYzNmY2ZDZkNjk3NDc0NjU2NTVmNmQ2NTZkNjI2NTcyNzMKICAgIGRpZyAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjM1MwogICAgLy8gc2VsZi5jb21taXR0ZWVfdm90ZXMudmFsdWUgPSBjb21taXR0ZWVfdm90ZXMKICAgIGJ5dGVjIDEzIC8vIDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY3NjZmNzQ2NTczCiAgICBkaWcgMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIGRpZyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjA0CiAgICAvLyByZXR1cm4gc2VsZi52ZXJpZnlfYW5kX3NldF9jb21taXR0ZWUoKQogICAgYiBjcmVhdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudmVyaWZ5X2FuZF9zZXRfY29tbWl0dGVlQDEyCgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLm9wZW5bcm91dGluZ10oKSAtPiB2b2lkOgpvcGVuOgogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjA2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXBuIDIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjYzOQogICAgLy8gc2VsZi5jaGVja19yZWdpc3RyeV9ub3RfcGF1c2VkKCkKICAgIGNhbGxzdWIgY2hlY2tfcmVnaXN0cnlfbm90X3BhdXNlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjM5MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfcHJvcG9zZXIoKSwgZXJyLlVOQVVUSE9SSVpFRAogICAgY2FsbHN1YiBpc19wcm9wb3NlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjM5NQogICAgLy8gc2VsZi5zdGF0dXMudmFsdWUgPT0gZW5tLlNUQVRVU19FTVBUWSBhbmQgbm90IHNlbGYuZmluYWxpemVkLnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXR1cyBleGlzdHMKICAgIGJueiBvcGVuX2Jvb2xfZmFsc2VANAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gMHg2NjY5NmU2MTZjNjk3YTY1NjQKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5maW5hbGl6ZWQgZXhpc3RzCiAgICBibnogb3Blbl9ib29sX2ZhbHNlQDQKICAgIGludGNfMSAvLyAxCgpvcGVuX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozOTQtMzk2CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuc3RhdHVzLnZhbHVlID09IGVubS5TVEFUVVNfRU1QVFkgYW5kIG5vdCBzZWxmLmZpbmFsaXplZC52YWx1ZQogICAgLy8gKSwgZXJyLldST05HX1BST1BPU0FMX1NUQVRVUwogICAgYXNzZXJ0IC8vIFdyb25nIFByb3Bvc2FsIFN0YXR1cyBvciBmaW5hbGl6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2NDQKICAgIC8vIHRpdGxlLm5hdGl2ZSwgZnVuZGluZ190eXBlLmFzX3VpbnQ2NCgpLCByZXF1ZXN0ZWRfYW1vdW50LmFzX3VpbnQ2NCgpCiAgICBkaWcgMwogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgYnVyeSAxMAogICAgZGlnIDMKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAxMAogICAgZGlnIDMKICAgIGJ0b2kKICAgIGJ1cnkgOAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQwNgogICAgLy8gYXNzZXJ0IHRpdGxlLmJ5dGVzLmxlbmd0aCA8PSBjb25zdC5USVRMRV9NQVhfQllURVMsIGVyci5XUk9OR19USVRMRV9MRU5HVEgKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDEyMyAvLyAxMjMKICAgIDw9CiAgICBhc3NlcnQgLy8gV3JvbmcgVGl0bGUgbGVuZ3RoCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDA3CiAgICAvLyBhc3NlcnQgdGl0bGUgIT0gIiIsIGVyci5XUk9OR19USVRMRV9MRU5HVEgKICAgIHB1c2hieXRlcyAiIgogICAgIT0KICAgIGFzc2VydCAvLyBXcm9uZyBUaXRsZSBsZW5ndGgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0MTAKICAgIC8vIGZ1bmRpbmdfdHlwZSA9PSBlbm0uRlVORElOR19QUk9BQ1RJVkUKICAgIGludGNfMyAvLyAxMAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0MTAtNDExCiAgICAvLyBmdW5kaW5nX3R5cGUgPT0gZW5tLkZVTkRJTkdfUFJPQUNUSVZFCiAgICAvLyBvciBmdW5kaW5nX3R5cGUgPT0gZW5tLkZVTkRJTkdfUkVUUk9BQ1RJVkUKICAgIGJueiBvcGVuX2Jvb2xfdHJ1ZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDExCiAgICAvLyBvciBmdW5kaW5nX3R5cGUgPT0gZW5tLkZVTkRJTkdfUkVUUk9BQ1RJVkUKICAgIGRpZyA3CiAgICBwdXNoaW50IDIwIC8vIDIwCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQxMC00MTEKICAgIC8vIGZ1bmRpbmdfdHlwZSA9PSBlbm0uRlVORElOR19QUk9BQ1RJVkUKICAgIC8vIG9yIGZ1bmRpbmdfdHlwZSA9PSBlbm0uRlVORElOR19SRVRST0FDVElWRQogICAgYnogb3Blbl9ib29sX2ZhbHNlQDEwCgpvcGVuX2Jvb2xfdHJ1ZUA5OgogICAgaW50Y18xIC8vIDEKCm9wZW5fYm9vbF9tZXJnZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0MDktNDEyCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIGZ1bmRpbmdfdHlwZSA9PSBlbm0uRlVORElOR19QUk9BQ1RJVkUKICAgIC8vICAgICBvciBmdW5kaW5nX3R5cGUgPT0gZW5tLkZVTkRJTkdfUkVUUk9BQ1RJVkUKICAgIC8vICksIGVyci5XUk9OR19GVU5ESU5HX1RZUEUKICAgIGFzc2VydCAvLyBXcm9uZyBGdW5kaW5nIFR5cGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0MTUKICAgIC8vIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX01JTl9SRVFVRVNURURfQU1PVU5UKQogICAgcHVzaGJ5dGVzIDB4NmQ2OTZlNWY3MjY1NzE3NTY1NzM3NDY1NjQ1ZjYxNmQ2Zjc1NmU3NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQxNC00MTYKICAgIC8vIG1pbl9yZXF1ZXN0ZWRfYW1vdW50LCBlcnJvciA9IHNlbGYuZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcoCiAgICAvLyAgICAgQnl0ZXMocmVnX2NmZy5HU19LRVlfTUlOX1JFUVVFU1RFRF9BTU9VTlQpCiAgICAvLyApCiAgICBjYWxsc3ViIGdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDE3CiAgICAvLyBhc3NlcnQgZXJyb3IgPT0gdHlwLkVycm9yKCIiKSwgZXJyLk1JU1NJTkdfQ09ORklHCiAgICBieXRlY18wIC8vIDB4MDAwMAogICAgPT0KICAgIGFzc2VydCAvLyBNaXNzaW5nIENvbmZpZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQyMAogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfTUFYX1JFUVVFU1RFRF9BTU9VTlRfTEFSR0UpCiAgICBwdXNoYnl0ZXMgMHg2ZDYxNzg1ZjcyNjU3MTc1NjU3Mzc0NjU2NDVmNjE2ZDZmNzU2ZTc0NWY2YzYxNzI2NzY1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDE5LTQyMQogICAgLy8gbWF4X3JlcXVlc3RlZF9hbW91bnRfbGFyZ2UsIGVycm9yID0gc2VsZi5nZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZygKICAgIC8vICAgICBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9NQVhfUkVRVUVTVEVEX0FNT1VOVF9MQVJHRSkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0MTcKICAgIC8vIGFzc2VydCBlcnJvciA9PSB0eXAuRXJyb3IoIiIpLCBlcnIuTUlTU0lOR19DT05GSUcKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDIyCiAgICAvLyBhc3NlcnQgZXJyb3IgPT0gdHlwLkVycm9yKCIiKSwgZXJyLk1JU1NJTkdfQ09ORklHCiAgICA9PQogICAgYXNzZXJ0IC8vIE1pc3NpbmcgQ29uZmlnCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDI0CiAgICAvLyBhc3NlcnQgcmVxdWVzdGVkX2Ftb3VudCA+PSBtaW5fcmVxdWVzdGVkX2Ftb3VudCwgZXJyLldST05HX01JTl9SRVFVRVNURURfQU1PVU5UCiAgICBkaWcgNwogICAgZHVwCiAgICB1bmNvdmVyIDMKICAgID49CiAgICBhc3NlcnQgLy8gUmVxdWVzdGVkIGFtb3VudCBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gcmVxdWVzdGVkIGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQyNgogICAgLy8gcmVxdWVzdGVkX2Ftb3VudCA8PSBtYXhfcmVxdWVzdGVkX2Ftb3VudF9sYXJnZQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDI1LTQyNwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICByZXF1ZXN0ZWRfYW1vdW50IDw9IG1heF9yZXF1ZXN0ZWRfYW1vdW50X2xhcmdlCiAgICAvLyApLCBlcnIuV1JPTkdfTUFYX1JFUVVFU1RFRF9BTU9VTlQKICAgIGFzc2VydCAvLyBSZXF1ZXN0ZWQgYW1vdW50IGlzIG1vcmUgdGhhbiB0aGUgbWF4aW11bSByZXF1ZXN0ZWQgYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDUwCiAgICAvLyBleHBlY3RlZF9sb2NrX2Ftb3VudCA9IHNlbGYuZ2V0X2V4cGVjdGVkX2xvY2tlZF9hbW91bnQocmVxdWVzdGVkX2Ftb3VudCkKICAgIGR1cAogICAgY2FsbHN1YiBnZXRfZXhwZWN0ZWRfbG9ja2VkX2Ftb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ1MgogICAgLy8gYXNzZXJ0IHBheW1lbnQuc2VuZGVyID09IHNlbGYucHJvcG9zZXIudmFsdWUsIGVyci5XUk9OR19TRU5ERVIKICAgIGRpZyA2CiAgICBkdXAKICAgIGd0eG5zIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gMHg3MDcyNmY3MDZmNzM2NTcyCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucHJvcG9zZXIgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIFdyb25nIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ1NAogICAgLy8gcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBkdXAKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0NTMtNDU1CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHBheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgLy8gKSwgZXJyLldST05HX1JFQ0VJVkVSCiAgICBhc3NlcnQgLy8gV3JvbmcgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0NTYKICAgIC8vIGFzc2VydCBwYXltZW50LmFtb3VudCA9PSBleHBlY3RlZF9sb2NrX2Ftb3VudCwgZXJyLldST05HX0xPQ0tFRF9BTU9VTlQKICAgIGd0eG5zIEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBMb2NrZWQgYW1vdW50IGlzIGluY29ycmVjdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY0OAogICAgLy8gc2VsZi50aXRsZS52YWx1ZSA9IHRpdGxlLm5hdGl2ZQogICAgYnl0ZWMgMjUgLy8gMHg3NDY5NzQ2YzY1CiAgICBkaWcgMTAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDYxCiAgICAvLyBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9NQVhfUkVRVUVTVEVEX0FNT1VOVF9TTUFMTCkKICAgIHB1c2hieXRlcyAweDZkNjE3ODVmNzI2NTcxNzU2NTczNzQ2NTY0NWY2MTZkNmY3NTZlNzQ1ZjczNmQ2MTZjNmMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0NjAtNDYyCiAgICAvLyBtYXhfcmVxdWVzdGVkX2Ftb3VudF9zbWFsbCwgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX01BWF9SRVFVRVNURURfQU1PVU5UX1NNQUxMKQogICAgLy8gKQogICAgY2FsbHN1YiBnZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQxNwogICAgLy8gYXNzZXJ0IGVycm9yID09IHR5cC5FcnJvcigiIiksIGVyci5NSVNTSU5HX0NPTkZJRwogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0NjMKICAgIC8vIGFzc2VydCBlcnJvciA9PSB0eXAuRXJyb3IoIiIpLCBlcnIuTUlTU0lOR19DT05GSUcKICAgID09CiAgICBhc3NlcnQgLy8gTWlzc2luZyBDb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0NjYKICAgIC8vIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX01BWF9SRVFVRVNURURfQU1PVU5UX01FRElVTSkKICAgIHB1c2hieXRlcyAweDZkNjE3ODVmNzI2NTcxNzU2NTczNzQ2NTY0NWY2MTZkNmY3NTZlNzQ1ZjZkNjU2NDY5NzU2ZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ2NS00NjcKICAgIC8vIG1heF9yZXF1ZXN0ZWRfYW1vdW50X21lZGl1bSwgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX01BWF9SRVFVRVNURURfQU1PVU5UX01FRElVTSkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIHN3YXAKICAgIGJ1cnkgMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0MTcKICAgIC8vIGFzc2VydCBlcnJvciA9PSB0eXAuRXJyb3IoIiIpLCBlcnIuTUlTU0lOR19DT05GSUcKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDY4CiAgICAvLyBhc3NlcnQgZXJyb3IgPT0gdHlwLkVycm9yKCIiKSwgZXJyLk1JU1NJTkdfQ09ORklHCiAgICA9PQogICAgYXNzZXJ0IC8vIE1pc3NpbmcgQ29uZmlnCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDcwCiAgICAvLyBpZiByZXF1ZXN0ZWRfYW1vdW50IDw9IG1heF9yZXF1ZXN0ZWRfYW1vdW50X3NtYWxsOgogICAgPD0KICAgIGJ6IG9wZW5fZWxzZV9ib2R5QDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDcxCiAgICAvLyBzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkudmFsdWUgPSBVSW50NjQoZW5tLkZVTkRJTkdfQ0FURUdPUllfU01BTEwpCiAgICBieXRlY18yIC8vIDB4NjY3NTZlNjQ2OTZlNjc1ZjYzNjE3NDY1Njc2ZjcyNzkKICAgIGludGNfMyAvLyAxMAogICAgYXBwX2dsb2JhbF9wdXQKCm9wZW5fYWZ0ZXJfaWZfZWxzZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2NTAKICAgIC8vIHNlbGYuZnVuZGluZ190eXBlLnZhbHVlID0gZnVuZGluZ190eXBlLmFzX3VpbnQ2NCgpCiAgICBieXRlYyAyMSAvLyAweDY2NzU2ZTY0Njk2ZTY3NWY3NDc5NzA2NQogICAgZGlnIDgKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjUxCiAgICAvLyBzZWxmLnJlcXVlc3RlZF9hbW91bnQudmFsdWUgPSByZXF1ZXN0ZWRfYW1vdW50LmFzX3VpbnQ2NCgpCiAgICBieXRlYyAyMiAvLyAweDcyNjU3MTc1NjU3Mzc0NjU2NDVmNjE2ZDZmNzU2ZTc0CiAgICBkaWcgNgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY1MgogICAgLy8gc2VsZi5mb2N1cy52YWx1ZSA9IGZvY3VzLmFzX3VpbnQ2NCgpCiAgICBkaWcgMQogICAgYnRvaQogICAgYnl0ZWMgMjcgLy8gMHg2NjZmNjM3NTczCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY1My02NTUKICAgIC8vIHNlbGYubG9ja2VkX2Ftb3VudC52YWx1ZSA9IHNlbGYuZ2V0X2V4cGVjdGVkX2xvY2tlZF9hbW91bnQoCiAgICAvLyAgICAgcmVxdWVzdGVkX2Ftb3VudC5hc191aW50NjQoKQogICAgLy8gKQogICAgY2FsbHN1YiBnZXRfZXhwZWN0ZWRfbG9ja2VkX2Ftb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY1MwogICAgLy8gc2VsZi5sb2NrZWRfYW1vdW50LnZhbHVlID0gc2VsZi5nZXRfZXhwZWN0ZWRfbG9ja2VkX2Ftb3VudCgKICAgIGJ5dGVjIDE3IC8vIDB4NmM2ZjYzNmI2NTY0NWY2MTZkNmY3NTZlNzQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2NTMtNjU1CiAgICAvLyBzZWxmLmxvY2tlZF9hbW91bnQudmFsdWUgPSBzZWxmLmdldF9leHBlY3RlZF9sb2NrZWRfYW1vdW50KAogICAgLy8gICAgIHJlcXVlc3RlZF9hbW91bnQuYXNfdWludDY0KCkKICAgIC8vICkKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjU2CiAgICAvLyBzZWxmLm9wZW5fdHMudmFsdWUgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgYnl0ZWMgMjAgLy8gMHg2ZjcwNjU2ZTVmNzQ2OTZkNjU3Mzc0NjE2ZDcwCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY1NwogICAgLy8gc2VsZi5zdGF0dXMudmFsdWUgPSBVSW50NjQoZW5tLlNUQVRVU19EUkFGVCkKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIGludGNfMyAvLyAxMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2NjEKICAgIC8vIGZ1bmRpbmdfdHlwZT1hcmM0LlVJbnQ4KHNlbGYuZnVuZGluZ190eXBlLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMSAvLyAweDY2NzU2ZTY0Njk2ZTY3NWY3NDc5NzA2NQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZ1bmRpbmdfdHlwZSBleGlzdHMKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2NjIKICAgIC8vIHJlcXVlc3RlZF9hbW91bnQ9YXJjNC5VSW50NjQoc2VsZi5yZXF1ZXN0ZWRfYW1vdW50LnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMiAvLyAweDcyNjU3MTc1NjU3Mzc0NjU2NDVmNjE2ZDZmNzU2ZTc0CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucmVxdWVzdGVkX2Ftb3VudCBleGlzdHMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2NjMKICAgIC8vIGNhdGVnb3J5PWFyYzQuVUludDgoc2VsZi5mdW5kaW5nX2NhdGVnb3J5LnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vIDB4NjY3NTZlNjQ2OTZlNjc1ZjYzNjE3NDY1Njc2ZjcyNzkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5mdW5kaW5nX2NhdGVnb3J5IGV4aXN0cwogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY2MC02NjQKICAgIC8vIHR5cC5PcGVuZWQoCiAgICAvLyAgICAgZnVuZGluZ190eXBlPWFyYzQuVUludDgoc2VsZi5mdW5kaW5nX3R5cGUudmFsdWUpLAogICAgLy8gICAgIHJlcXVlc3RlZF9hbW91bnQ9YXJjNC5VSW50NjQoc2VsZi5yZXF1ZXN0ZWRfYW1vdW50LnZhbHVlKSwKICAgIC8vICAgICBjYXRlZ29yeT1hcmM0LlVJbnQ4KHNlbGYuZnVuZGluZ19jYXRlZ29yeS52YWx1ZSksCiAgICAvLyApCiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY1OS02NjUKICAgIC8vIGFyYzQuZW1pdCgKICAgIC8vICAgICB0eXAuT3BlbmVkKAogICAgLy8gICAgICAgICBmdW5kaW5nX3R5cGU9YXJjNC5VSW50OChzZWxmLmZ1bmRpbmdfdHlwZS52YWx1ZSksCiAgICAvLyAgICAgICAgIHJlcXVlc3RlZF9hbW91bnQ9YXJjNC5VSW50NjQoc2VsZi5yZXF1ZXN0ZWRfYW1vdW50LnZhbHVlKSwKICAgIC8vICAgICAgICAgY2F0ZWdvcnk9YXJjNC5VSW50OChzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkudmFsdWUpLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIHB1c2hieXRlcyAweDM3MTI0M2Y1IC8vIG1ldGhvZCAiT3BlbmVkKHVpbnQ4LHVpbnQ2NCx1aW50OCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjYwNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm9wZW5fZWxzZV9ib2R5QDE3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ3MgogICAgLy8gZWxpZiByZXF1ZXN0ZWRfYW1vdW50IDw9IG1heF9yZXF1ZXN0ZWRfYW1vdW50X21lZGl1bToKICAgIGRpZyA1CiAgICBkaWcgNwogICAgPD0KICAgIGJ6IG9wZW5fZWxzZV9ib2R5QDE5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDczCiAgICAvLyBzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkudmFsdWUgPSBVSW50NjQoZW5tLkZVTkRJTkdfQ0FURUdPUllfTUVESVVNKQogICAgYnl0ZWNfMiAvLyAweDY2NzU2ZTY0Njk2ZTY3NWY2MzYxNzQ2NTY3NmY3Mjc5CiAgICBwdXNoaW50IDIwIC8vIDIwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYiBvcGVuX2FmdGVyX2lmX2Vsc2VAMjAKCm9wZW5fZWxzZV9ib2R5QDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ3NQogICAgLy8gc2VsZi5mdW5kaW5nX2NhdGVnb3J5LnZhbHVlID0gVUludDY0KGVubS5GVU5ESU5HX0NBVEVHT1JZX0xBUkdFKQogICAgYnl0ZWNfMiAvLyAweDY2NzU2ZTY0Njk2ZTY3NWY2MzYxNzQ2NTY3NmY3Mjc5CiAgICBwdXNoaW50IDMwIC8vIDMwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYiBvcGVuX2FmdGVyX2lmX2Vsc2VAMjAKCm9wZW5fYm9vbF9mYWxzZUAxMDoKICAgIGludGNfMCAvLyAwCiAgICBiIG9wZW5fYm9vbF9tZXJnZUAxMQoKb3Blbl9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAogICAgYiBvcGVuX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC51cGxvYWRfbWV0YWRhdGFbcm91dGluZ10oKSAtPiB2b2lkOgp1cGxvYWRfbWV0YWRhdGE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjY3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwbiAyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICB1bmNvdmVyIDIKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuYm9vbAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY4NAogICAgLy8gc2VsZi5jaGVja19yZWdpc3RyeV9ub3RfcGF1c2VkKCkKICAgIGNhbGxzdWIgY2hlY2tfcmVnaXN0cnlfbm90X3BhdXNlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjM4NQogICAgLy8gc2VsZi5hc3NlcnRfZHJhZnRfYW5kX3Byb3Bvc2VyKCkKICAgIGNhbGxzdWIgYXNzZXJ0X2RyYWZ0X2FuZF9wcm9wb3NlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjM4OQogICAgLy8gYXNzZXJ0IHBheWxvYWQubGVuZ3RoID4gMCwgZXJyLkVNUFRZX1BBWUxPQUQKICAgIHN3YXAKICAgIGFzc2VydCAvLyBFbXB0eSBwYXlsb2FkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Njg5CiAgICAvLyBzZWxmLm1ldGFkYXRhX3VwbG9hZGVkID0gVHJ1ZQogICAgYnl0ZWMgMjggLy8gIm1ldGFkYXRhX3VwbG9hZGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NjkxCiAgICAvLyBpZiBpc19maXJzdF9pbl9ncm91cDoKICAgIGJ5dGVjIDE4IC8vIDB4MDAKICAgICE9CiAgICBieiB1cGxvYWRfbWV0YWRhdGFfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2OTItNjkzCiAgICAvLyAjIGNsZWFyIGFuZCB3cml0ZSB0aGUgbWV0YWRhdGEgdG8gdGhlIGJveAogICAgLy8gZGVsIHNlbGYubWV0YWRhdGEudmFsdWUKICAgIGJ5dGVjIDcgLy8gIk0iCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2OTQKICAgIC8vIHNlbGYubWV0YWRhdGEudmFsdWUgPSBwYXlsb2FkLm5hdGl2ZQogICAgZXh0cmFjdCAyIDAKICAgIGJ5dGVjIDcgLy8gIk0iCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJ5dGVjIDcgLy8gIk0iCiAgICBzd2FwCiAgICBib3hfcHV0Cgp1cGxvYWRfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY2NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnVwbG9hZF9tZXRhZGF0YV9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo2OTYtNjk3CiAgICAvLyAjIGFwcGVuZCB0aGUgbWV0YWRhdGEgdG8gdGhlIGJveAogICAgLy8gb2xkX3NpemUgPSBzZWxmLm1ldGFkYXRhLmxlbmd0aAogICAgYnl0ZWMgNyAvLyAiTSIKICAgIGJveF9sZW4KICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm1ldGFkYXRhIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjY5OAogICAgLy8gc2VsZi5tZXRhZGF0YS5yZXNpemUoc2VsZi5tZXRhZGF0YS5sZW5ndGggKyBwYXlsb2FkLmxlbmd0aCkKICAgIGR1cAogICAgZGlnIDMKICAgICsKICAgIGJ5dGVjIDcgLy8gIk0iCiAgICBzd2FwCiAgICBib3hfcmVzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Njk5CiAgICAvLyBzZWxmLm1ldGFkYXRhLnJlcGxhY2Uob2xkX3NpemUsIHBheWxvYWQubmF0aXZlKQogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGJ5dGVjIDcgLy8gIk0iCiAgICBjb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgYiB1cGxvYWRfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmRyb3Bbcm91dGluZ10oKSAtPiB2b2lkOgpkcm9wOgogICAgaW50Y18wIC8vIDAKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjM3OAogICAgLy8gYXNzZXJ0IHNlbGYuaXNfcmVnaXN0cnlfY2FsbCgpLCBlcnIuVU5BVVRIT1JJWkVECiAgICBjYWxsc3ViIGlzX3JlZ2lzdHJ5X2NhbGwKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNzkKICAgIC8vIGlmIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfRFJBRlQgb3Igc2VsZi5maW5hbGl6ZWQudmFsdWU6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXR1cyBleGlzdHMKICAgIGludGNfMyAvLyAxMAogICAgIT0KICAgIGJueiBkcm9wX2lmX2JvZHlANwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gMHg2NjY5NmU2MTZjNjk3YTY1NjQKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5maW5hbGl6ZWQgZXhpc3RzCiAgICBieiBkcm9wX2FmdGVyX2lmX2Vsc2VAOAoKZHJvcF9pZl9ib2R5QDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzgwCiAgICAvLyByZXR1cm4gdHlwLkVycm9yKGVyci5BUkNfNjVfUFJFRklYICsgZXJyLldST05HX1BST1BPU0FMX1NUQVRVUykKICAgIGJ5dGVjIDI0IC8vIDB4MDAyNjQ1NTI1MjNhNTc3MjZmNmU2NzIwNTA3MjZmNzA2ZjczNjE2YzIwNTM3NDYxNzQ3NTczMjA2ZjcyMjA2NjY5NmU2MTZjNjk3YTY1NjQKICAgIGJ1cnkgMQoKZHJvcF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5kcm9wX2NoZWNrX2F1dGhvcml6YXRpb25AOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo3MTIKICAgIC8vIGlmIGVycm9yICE9IHR5cC5FcnJvcigiIik6CiAgICBieXRlY18wIC8vIDB4MDAwMAogICAgYnVyeSAyCiAgICBkdXAKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAhPQogICAgYnogZHJvcF9hZnRlcl9pZl9lbHNlQDMKICAgIGR1cAoKZHJvcF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5kcm9wQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzAxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgYnl0ZWMgMTIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmRyb3BfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjcxNgogICAgLy8gcmVjZWl2ZXI9c2VsZi5wcm9wb3Nlci52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vIDB4NzA3MjZmNzA2ZjczNjU3MgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnByb3Bvc2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjcxNS03MTcKICAgIC8vIHNlbGYudHJhbnNmZXJfbG9ja2VkX2Ftb3VudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLnByb3Bvc2VyLnZhbHVlLAogICAgLy8gKQogICAgY2FsbHN1YiB0cmFuc2Zlcl9sb2NrZWRfYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzE5CiAgICAvLyBkZWwgc2VsZi5tZXRhZGF0YS52YWx1ZQogICAgYnl0ZWMgNyAvLyAiTSIKICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjcyMAogICAgLy8gc2VsZi5maW5hbGl6ZWQudmFsdWUgPSBUcnVlCiAgICBieXRlY18zIC8vIDB4NjY2OTZlNjE2YzY5N2E2NTY0CiAgICBpbnRjXzEgLy8gMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzAxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgYiBkcm9wX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmRyb3BANAoKZHJvcF9hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzgxCiAgICAvLyByZXR1cm4gdHlwLkVycm9yKCIiKQogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjcxMQogICAgLy8gZXJyb3IgPSBzZWxmLmRyb3BfY2hlY2tfYXV0aG9yaXphdGlvbigpCiAgICBiIGRyb3BfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuZHJvcF9jaGVja19hdXRob3JpemF0aW9uQDkKCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuc3VibWl0W3JvdXRpbmddKCkgLT4gdm9pZDoKc3VibWl0OgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo3MzYKICAgIC8vIHNlbGYuY2hlY2tfcmVnaXN0cnlfbm90X3BhdXNlZCgpCiAgICBjYWxsc3ViIGNoZWNrX3JlZ2lzdHJ5X25vdF9wYXVzZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNjcKICAgIC8vIHNlbGYuYXNzZXJ0X2RyYWZ0X2FuZF9wcm9wb3NlcigpCiAgICBjYWxsc3ViIGFzc2VydF9kcmFmdF9hbmRfcHJvcG9zZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNjkKICAgIC8vIGRpc2N1c3Npb25fZHVyYXRpb24gPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCAtIHNlbGYub3Blbl90cy52YWx1ZQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDIwIC8vIDB4NmY3MDY1NmU1Zjc0Njk2ZDY1NzM3NDYxNmQ3MAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm9wZW5fdHMgZXhpc3RzCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzcxCiAgICAvLyBzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vIDB4NjY3NTZlNjQ2OTZlNjc1ZjYzNjE3NDY1Njc2ZjcyNzkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZnVuZGluZ19jYXRlZ29yeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNjIKICAgIC8vIGlmIGNhdGVnb3J5ID09IGVubS5GVU5ESU5HX0NBVEVHT1JZX1NNQUxMOgogICAgaW50Y18zIC8vIDEwCiAgICA9PQogICAgYnogc3VibWl0X2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MjY0CiAgICAvLyBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9ESVNDVVNTSU9OX0RVUkFUSU9OX1NNQUxMKQogICAgcHVzaGJ5dGVzIDB4NjQ2OTczNjM3NTczNzM2OTZmNmU1ZjY0NzU3MjYxNzQ2OTZmNmU1ZjczNmQ2MTZjNmMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNjMtMjY1CiAgICAvLyB2YWx1ZSwgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX0RJU0NVU1NJT05fRFVSQVRJT05fU01BTEwpCiAgICAvLyApCiAgICBjYWxsc3ViIGdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnCiAgICBidXJ5IDQKCnN1Ym1pdF9hZnRlcl9pZl9lbHNlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Mjc0CiAgICAvLyBhc3NlcnQgZXJyb3IgPT0gdHlwLkVycm9yKCIiKSwgZXJyLk1JU1NJTkdfQ09ORklHCiAgICBkaWcgMwogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgID09CiAgICBhc3NlcnQgLy8gTWlzc2luZyBDb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNzQKICAgIC8vIGFzc2VydCBkaXNjdXNzaW9uX2R1cmF0aW9uID49IG1pbmltdW1fZGlzY3Vzc2lvbl9kdXJhdGlvbiwgZXJyLlRPT19FQVJMWQogICAgZGlnIDIKICAgIDw9CiAgICBhc3NlcnQgLy8gVG9vIGVhcmx5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzQwCiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSA9IFVJbnQ2NChlbm0uU1RBVFVTX1NVQk1JVFRFRCkKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIHB1c2hpbnQgMjAgLy8gMjAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzQxCiAgICAvLyBzZWxmLnN1Ym1pc3Npb25fdHMudmFsdWUgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgYnl0ZWMgMjYgLy8gMHg3Mzc1NjI2ZDY5NzM3MzY5NmY2ZTVmNzQ2OTZkNjU3Mzc0NjE2ZDcwCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc0NAogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfT1BFTl9QUk9QT1NBTF9GRUUpCiAgICBwdXNoYnl0ZXMgMHg2ZjcwNjU2ZTVmNzA3MjZmNzA2ZjczNjE2YzVmNjY2NTY1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzQzLTc0NQogICAgLy8gb3Blbl9wcm9wb3NhbF9mZWUsIGVycm9yID0gc2VsZi5nZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZygKICAgIC8vICAgICBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9PUEVOX1BST1BPU0FMX0ZFRSkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNzQKICAgIC8vIGFzc2VydCBlcnJvciA9PSB0eXAuRXJyb3IoIiIpLCBlcnIuTUlTU0lOR19DT05GSUcKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzQ2CiAgICAvLyBhc3NlcnQgZXJyb3IgPT0gdHlwLkVycm9yKCIiKSwgZXJyLk1JU1NJTkdfQ09ORklHCiAgICA9PQogICAgYXNzZXJ0IC8vIE1pc3NpbmcgQ29uZmlnCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzQ4CiAgICAvLyBhc3NlcnQgc2VsZi5tZXRhZGF0YV91cGxvYWRlZCwgZXJyLk1JU1NJTkdfTUVUQURBVEEKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyOCAvLyAibWV0YWRhdGFfdXBsb2FkZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubWV0YWRhdGFfdXBsb2FkZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gTWlzc2luZyBNZXRhZGF0YQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc1MQogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfREFFTU9OX09QU19GVU5ESU5HX0JQUykKICAgIHB1c2hieXRlcyAweDY0NjE2NTZkNmY2ZTVmNmY3MDY1NzI2MTc0Njk2ZjZlNWY2Njc1NmU2NDY5NmU2NzVmNjI3MDczCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzUwLTc1MgogICAgLy8gZGFlbW9uX29wc19mdW5kaW5nX2JwcywgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX0RBRU1PTl9PUFNfRlVORElOR19CUFMpCiAgICAvLyApCiAgICBjYWxsc3ViIGdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Mjc0CiAgICAvLyBhc3NlcnQgZXJyb3IgPT0gdHlwLkVycm9yKCIiKSwgZXJyLk1JU1NJTkdfQ09ORklHCiAgICBieXRlY18wIC8vIDB4MDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc1MwogICAgLy8gYXNzZXJ0IGVycm9yID09IHR5cC5FcnJvcigiIiksIGVyci5NSVNTSU5HX0NPTkZJRwogICAgPT0KICAgIGFzc2VydCAvLyBNaXNzaW5nIENvbmZpZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc1NwogICAgLy8gc2VsZi5nZXRfYnl0ZXNfZnJvbV9yZWdpc3RyeV9jb25maWcoQnl0ZXMocmVnX2NmZy5HU19LRVlfWEdPVl9EQUVNT04pKQogICAgYnl0ZWMgMjkgLy8gMHg3ODY3NmY3NjVmNjQ2MTY1NmQ2ZjZlCiAgICBjYWxsc3ViIGdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc1Ni03NTgKICAgIC8vIHJlY2VpdmVyPUFjY291bnQoCiAgICAvLyAgICAgc2VsZi5nZXRfYnl0ZXNfZnJvbV9yZWdpc3RyeV9jb25maWcoQnl0ZXMocmVnX2NmZy5HU19LRVlfWEdPVl9EQUVNT04pKQogICAgLy8gKSwKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gQWRkcmVzcyBsZW5ndGggaXMgMzIgYnl0ZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0MzMKICAgIC8vIHJldHVybiBhbW91bnQgKiBmcmFjdGlvbl9pbl9icHMgLy8gY29uc3QuQlBTCiAgICBjb3ZlciAyCiAgICAqCiAgICBpbnRjIDQgLy8gMTAwMDAKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo3NTUtNzYyCiAgICAvLyBzZWxmLnBheSgKICAgIC8vICAgICByZWNlaXZlcj1BY2NvdW50KAogICAgLy8gICAgICAgICBzZWxmLmdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZyhCeXRlcyhyZWdfY2ZnLkdTX0tFWV9YR09WX0RBRU1PTikpCiAgICAvLyAgICAgKSwKICAgIC8vICAgICBhbW91bnQ9c2VsZi5yZWxhdGl2ZV90b19hYnNvbHV0ZV9hbW91bnQoCiAgICAvLyAgICAgICAgIG9wZW5fcHJvcG9zYWxfZmVlLCBkYWVtb25fb3BzX2Z1bmRpbmdfYnBzCiAgICAvLyAgICAgKSwKICAgIC8vICkKICAgIGNhbGxzdWIgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzI0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKc3VibWl0X2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI2NgogICAgLy8gZWxpZiBjYXRlZ29yeSA9PSBlbm0uRlVORElOR19DQVRFR09SWV9NRURJVU06CiAgICBkdXAKICAgIHB1c2hpbnQgMjAgLy8gMjAKICAgID09CiAgICBieiBzdWJtaXRfZWxzZV9ib2R5QDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNjgKICAgIC8vIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX0RJU0NVU1NJT05fRFVSQVRJT05fTUVESVVNKQogICAgcHVzaGJ5dGVzIDB4NjQ2OTczNjM3NTczNzM2OTZmNmU1ZjY0NzU3MjYxNzQ2OTZmNmU1ZjZkNjU2NDY5NzU2ZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI2Ny0yNjkKICAgIC8vIHZhbHVlLCBlcnJvciA9IHNlbGYuZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcoCiAgICAvLyAgICAgQnl0ZXMocmVnX2NmZy5HU19LRVlfRElTQ1VTU0lPTl9EVVJBVElPTl9NRURJVU0pCiAgICAvLyApCiAgICBjYWxsc3ViIGdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnCiAgICBidXJ5IDQKICAgIGIgc3VibWl0X2FmdGVyX2lmX2Vsc2VANwoKc3VibWl0X2Vsc2VfYm9keUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI3MgogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfRElTQ1VTU0lPTl9EVVJBVElPTl9MQVJHRSkKICAgIHB1c2hieXRlcyAweDY0Njk3MzYzNzU3MzczNjk2ZjZlNWY2NDc1NzI2MTc0Njk2ZjZlNWY2YzYxNzI2NzY1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MjcxLTI3MwogICAgLy8gdmFsdWUsIGVycm9yID0gc2VsZi5nZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZygKICAgIC8vICAgICBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9ESVNDVVNTSU9OX0RVUkFUSU9OX0xBUkdFKQogICAgLy8gKQogICAgY2FsbHN1YiBnZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgYnVyeSA0CiAgICBiIHN1Ym1pdF9hZnRlcl9pZl9lbHNlQDcKCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuYXNzaWduX3ZvdGVyc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmFzc2lnbl92b3RlcnM6CiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc3OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cG4gMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGR1cAogICAgY292ZXIgMgogICAgcHVzaGludCA0MCAvLyA0MAogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PHNtYXJ0X2NvbnRyYWN0cy5jb21tb24uYWJpX3R5cGVzLkNvbW1pdHRlZU1lbWJlcj4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNTAKICAgIC8vIGFzc2VydCBzZWxmLmlzX3hnb3ZfZGFlbW9uKCksIGVyci5VTkFVVEhPUklaRUQKICAgIGNhbGxzdWIgaXNfeGdvdl9kYWVtb24KICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNTEKICAgIC8vIGFzc2VydCBzZWxmLnN0YXR1cy52YWx1ZSA9PSBlbm0uU1RBVFVTX1NVQk1JVFRFRCwgZXJyLldST05HX1BST1BPU0FMX1NUQVRVUwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0dXMgZXhpc3RzCiAgICBwdXNoaW50IDIwIC8vIDIwCiAgICA9PQogICAgYXNzZXJ0IC8vIFdyb25nIFByb3Bvc2FsIFN0YXR1cyBvciBmaW5hbGl6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MDIKICAgIC8vIGlmIFR4bi5ncm91cF9pbmRleCA9PSAwOgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGJueiBhc3NpZ25fdm90ZXJzX2Vsc2VfYm9keUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODAzLTgwNAogICAgLy8gIyBDaGVjayB0aGF0IHRoZSBlbnRpcmUgZ3JvdXAgY2FsbHMgdGhlIHNhbWUgYXBwIGFuZCBtZXRob2QKICAgIC8vIGZvciBpIGluIHVyYW5nZSgxLCBHbG9iYWwuZ3JvdXBfc2l6ZSk6CiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBidXJ5IDMKICAgIGludGNfMSAvLyAxCiAgICBidXJ5IDQKCmFzc2lnbl92b3RlcnNfZm9yX2hlYWRlckAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgwMy04MDQKICAgIC8vICMgQ2hlY2sgdGhhdCB0aGUgZW50aXJlIGdyb3VwIGNhbGxzIHRoZSBzYW1lIGFwcCBhbmQgbWV0aG9kCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoMSwgR2xvYmFsLmdyb3VwX3NpemUpOgogICAgZGlnIDMKICAgIGRpZyAzCiAgICA8CiAgICBieiBhc3NpZ25fdm90ZXJzX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgwNQogICAgLy8gc2VsZi5hc3NlcnRfc2FtZV9hcHBfYW5kX21ldGhvZChpKQogICAgZGlnIDMKICAgIGR1cAogICAgY2FsbHN1YiBhc3NlcnRfc2FtZV9hcHBfYW5kX21ldGhvZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgwMy04MDQKICAgIC8vICMgQ2hlY2sgdGhhdCB0aGUgZW50aXJlIGdyb3VwIGNhbGxzIHRoZSBzYW1lIGFwcCBhbmQgbWV0aG9kCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoMSwgR2xvYmFsLmdyb3VwX3NpemUpOgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgNAogICAgYiBhc3NpZ25fdm90ZXJzX2Zvcl9oZWFkZXJAMwoKYXNzaWduX3ZvdGVyc19hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODEwCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2Uodm90ZXJzLmxlbmd0aCk6CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA0Cgphc3NpZ25fdm90ZXJzX2Zvcl9oZWFkZXJAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MTAKICAgIC8vIGZvciBpIGluIHVyYW5nZSh2b3RlcnMubGVuZ3RoKToKICAgIGRpZyAzCiAgICBkaWcgMQogICAgPAogICAgYnogYXNzaWduX3ZvdGVyc19hZnRlcl9mb3JAMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MTIKICAgIC8vIHZvdGVyc1tpXS5hZGRyZXNzLm5hdGl2ZSwgdm90ZXJzW2ldLnZvdGluZ19wb3dlci5hc191aW50NjQoKQogICAgZGlnIDEKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgNAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICAqCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyCiAgICBzd2FwCiAgICBpbnRjXzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MjU3CiAgICAvLyBhc3NlcnQgdm90ZXIgbm90IGluIHNlbGYudm90ZXJzLCBlcnIuVk9URVJfQUxSRUFEWV9BU1NJR05FRAogICAgYnl0ZWMgMTkgLy8gIlYiCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgICEKICAgIGFzc2VydCAvLyBWb3RlciBBbHJlYWR5IEFzc2lnbmVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MjU4CiAgICAvLyBhc3NlcnQgdm90aW5nX3Bvd2VyID4gMCwgZXJyLklOVkFMSURfVk9USU5HX1BPV0VSCiAgICBkaWcgMQogICAgYXNzZXJ0IC8vIEludmFsaWQgVm90aW5nIFBvd2VyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzY4CiAgICAvLyBzZWxmLnZvdGVyc1t2b3Rlcl0gPSB2b3RpbmdfcG93ZXIKICAgIGRpZyAxCiAgICBpdG9iCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NzY5CiAgICAvLyBzZWxmLnZvdGVyc19jb3VudCArPSAxCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNiAvLyAidm90ZXJzX2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZvdGVyc19jb3VudCBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBieXRlYyA2IC8vICJ2b3RlcnNfY291bnQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc3MAogICAgLy8gc2VsZi5hc3NpZ25lZF92b3RlcyArPSB2b3RpbmdfcG93ZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNSAvLyAiYXNzaWduZWRfdm90ZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNzaWduZWRfdm90ZXMgZXhpc3RzCiAgICArCiAgICBieXRlYyAxNSAvLyAiYXNzaWduZWRfdm90ZXMiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgxMAogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHZvdGVycy5sZW5ndGgpOgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgNAogICAgYiBhc3NpZ25fdm90ZXJzX2Zvcl9oZWFkZXJAOQoKYXNzaWduX3ZvdGVyc19hZnRlcl9mb3JAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODE1CiAgICAvLyBpZiBzZWxmLnZvdGVyc19jb3VudCA9PSBzZWxmLmNvbW1pdHRlZV9tZW1iZXJzLnZhbHVlOgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gInZvdGVyc19jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52b3RlcnNfY291bnQgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOCAvLyAweDYzNmY2ZDZkNjk3NDc0NjU2NTVmNmQ2NTZkNjI2NTcyNzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb21taXR0ZWVfbWVtYmVycyBleGlzdHMKICAgID09CiAgICBieiBhc3NpZ25fdm90ZXJzX2FmdGVyX2lmX2Vsc2VAMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MTcKICAgIC8vIHNlbGYuYXNzaWduZWRfdm90ZXMgPT0gc2VsZi5jb21taXR0ZWVfdm90ZXMudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNSAvLyAiYXNzaWduZWRfdm90ZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNzaWduZWRfdm90ZXMgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTMgLy8gMHg2MzZmNmQ2ZDY5NzQ3NDY1NjU1Zjc2NmY3NDY1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb21taXR0ZWVfdm90ZXMgZXhpc3RzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgxNi04MTgKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5hc3NpZ25lZF92b3RlcyA9PSBzZWxmLmNvbW1pdHRlZV92b3Rlcy52YWx1ZQogICAgLy8gKSwgZXJyLlZPVElOR19QT1dFUl9NSVNNQVRDSAogICAgYXNzZXJ0IC8vIFZvdGluZyBQb3dlciBNaXNtYXRjaAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgxOQogICAgLy8gc2VsZi5zdGF0dXMudmFsdWUgPSBVSW50NjQoZW5tLlNUQVRVU19WT1RJTkcpCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNzQ3NTczCiAgICBwdXNoaW50IDI1IC8vIDI1CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgyMAogICAgLy8gc2VsZi52b3RlX29wZW5fdHMudmFsdWUgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgYnl0ZWMgMTYgLy8gMHg3NjZmNzQ2NTVmNmY3MDY1NmU2OTZlNjc1Zjc0Njk2ZDY1NzM3NDYxNmQ3MAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MjMKICAgIC8vIHNlbGYuZnVuZGluZ19jYXRlZ29yeS52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gMHg2Njc1NmU2NDY5NmU2NzVmNjM2MTc0NjU2NzZmNzI3OQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODIyLTgyNAogICAgLy8gbWF4aW11bV92b3RpbmdfZHVyYXRpb24sIF9lcnJvciA9IHNlbGYuZ2V0X3ZvdGluZ19kdXJhdGlvbigKICAgIC8vICAgICBzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkudmFsdWUKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3ZvdGluZ19kdXJhdGlvbgogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODI4CiAgICAvLyB2b3RlX29wZW5pbmc9YXJjNC5VSW50NjQoc2VsZi52b3RlX29wZW5fdHMudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE2IC8vIDB4NzY2Zjc0NjU1ZjZmNzA2NTZlNjk2ZTY3NWY3NDY5NmQ2NTczNzQ2MTZkNzAKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52b3RlX29wZW5fdHMgZXhpc3RzCiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MzAKICAgIC8vIHNlbGYudm90ZV9vcGVuX3RzLnZhbHVlICsgbWF4aW11bV92b3RpbmdfZHVyYXRpb24KICAgIHN3YXAKICAgIHVuY292ZXIgMgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgyOS04MzEKICAgIC8vIHZvdGVfY2xvc2luZz1hcmM0LlVJbnQ2NCgKICAgIC8vICAgICBzZWxmLnZvdGVfb3Blbl90cy52YWx1ZSArIG1heGltdW1fdm90aW5nX2R1cmF0aW9uCiAgICAvLyApLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgzMgogICAgLy8gcXVvcnVtX3ZvdGVzPWFyYzQuVUludDMyKHNlbGYucXVvcnVtX3ZvdGVyc190aHJlc2hvbGQoKSksCiAgICBjYWxsc3ViIHF1b3J1bV92b3RlcnNfdGhyZXNob2xkCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDQgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgzNAogICAgLy8gc2VsZi53ZWlnaHRlZF9xdW9ydW1fdm90ZXNfdGhyZXNob2xkKCkKICAgIGNhbGxzdWIgd2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzX3RocmVzaG9sZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgzMy04MzUKICAgIC8vIHdlaWdodGVkX3F1b3J1bV92b3Rlcz1hcmM0LlVJbnQzMigKICAgIC8vICAgICBzZWxmLndlaWdodGVkX3F1b3J1bV92b3Rlc190aHJlc2hvbGQoKQogICAgLy8gKSwKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gMzIKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNCA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODI3LTgzNgogICAgLy8gdHlwLlN1Ym1pdHRlZCgKICAgIC8vICAgICB2b3RlX29wZW5pbmc9YXJjNC5VSW50NjQoc2VsZi52b3RlX29wZW5fdHMudmFsdWUpLAogICAgLy8gICAgIHZvdGVfY2xvc2luZz1hcmM0LlVJbnQ2NCgKICAgIC8vICAgICAgICAgc2VsZi52b3RlX29wZW5fdHMudmFsdWUgKyBtYXhpbXVtX3ZvdGluZ19kdXJhdGlvbgogICAgLy8gICAgICksCiAgICAvLyAgICAgcXVvcnVtX3ZvdGVzPWFyYzQuVUludDMyKHNlbGYucXVvcnVtX3ZvdGVyc190aHJlc2hvbGQoKSksCiAgICAvLyAgICAgd2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzPWFyYzQuVUludDMyKAogICAgLy8gICAgICAgICBzZWxmLndlaWdodGVkX3F1b3J1bV92b3Rlc190aHJlc2hvbGQoKQogICAgLy8gICAgICksCiAgICAvLyApCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODI2LTgzNwogICAgLy8gYXJjNC5lbWl0KAogICAgLy8gICAgIHR5cC5TdWJtaXR0ZWQoCiAgICAvLyAgICAgICAgIHZvdGVfb3BlbmluZz1hcmM0LlVJbnQ2NChzZWxmLnZvdGVfb3Blbl90cy52YWx1ZSksCiAgICAvLyAgICAgICAgIHZvdGVfY2xvc2luZz1hcmM0LlVJbnQ2NCgKICAgIC8vICAgICAgICAgICAgIHNlbGYudm90ZV9vcGVuX3RzLnZhbHVlICsgbWF4aW11bV92b3RpbmdfZHVyYXRpb24KICAgIC8vICAgICAgICAgKSwKICAgIC8vICAgICAgICAgcXVvcnVtX3ZvdGVzPWFyYzQuVUludDMyKHNlbGYucXVvcnVtX3ZvdGVyc190aHJlc2hvbGQoKSksCiAgICAvLyAgICAgICAgIHdlaWdodGVkX3F1b3J1bV92b3Rlcz1hcmM0LlVJbnQzMigKICAgIC8vICAgICAgICAgICAgIHNlbGYud2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzX3RocmVzaG9sZCgpCiAgICAvLyAgICAgICAgICksCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4OTgwZmQ1ZGUgLy8gbWV0aG9kICJTdWJtaXR0ZWQodWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyKSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCgphc3NpZ25fdm90ZXJzX2FmdGVyX2lmX2Vsc2VAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Nzc4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKYXNzaWduX3ZvdGVyc19lbHNlX2JvZHlANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MDctODA4CiAgICAvLyAjIENoZWNrIHRoYXQgdGhlIGZpcnN0IHRyYW5zYWN0aW9uIGluIHRoZSBncm91cCBjYWxscyB0aGUgc2FtZSBhcHAgYW5kIG1ldGhvZAogICAgLy8gc2VsZi5hc3NlcnRfc2FtZV9hcHBfYW5kX21ldGhvZChVSW50NjQoMCkpCiAgICBpbnRjXzAgLy8gMAogICAgY2FsbHN1YiBhc3NlcnRfc2FtZV9hcHBfYW5kX21ldGhvZAogICAgYiBhc3NpZ25fdm90ZXJzX2FmdGVyX2lmX2Vsc2VAOAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC52b3RlW3JvdXRpbmddKCkgLT4gdm9pZDoKdm90ZToKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDMKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODM5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4IC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4IC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MjA0CiAgICAvLyBhc3NlcnQgc2VsZi5pc19yZWdpc3RyeV9jYWxsKCksIGVyci5VTkFVVEhPUklaRUQKICAgIGNhbGxzdWIgaXNfcmVnaXN0cnlfY2FsbAogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjIwNgogICAgLy8gaWYgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19WT1RJTkc6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXR1cyBleGlzdHMKICAgIHB1c2hpbnQgMjUgLy8gMjUKICAgICE9CiAgICBieiB2b3RlX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyMDcKICAgIC8vIHJldHVybiB0eXAuRXJyb3IoZXJyLkFSQ182NV9QUkVGSVggKyBlcnIuV1JPTkdfUFJPUE9TQUxfU1RBVFVTKQogICAgYnl0ZWMgMjQgLy8gMHgwMDI2NDU1MjUyM2E1NzcyNmY2ZTY3MjA1MDcyNmY3MDZmNzM2MTZjMjA1Mzc0NjE3NDc1NzMyMDZmNzIyMDY2Njk2ZTYxNmM2OTdhNjU2NAogICAgYnVyeSA3Cgp2b3RlX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLnZvdGVfY2hlY2tfYXV0aG9yaXphdGlvbkAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4NjIKICAgIC8vIGlmIGVycm9yICE9IHR5cC5FcnJvcigiIik6CiAgICBieXRlY18wIC8vIDB4MDAwMAogICAgYnVyeSA5CiAgICBkaWcgNgogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgICE9CiAgICBieiB2b3RlX2FmdGVyX2lmX2Vsc2VAMwogICAgZGlnIDYKCnZvdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudm90ZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjgzOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGJ5dGVjIDEyIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgp2b3RlX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4NjYKICAgIC8vIHZvdGVyLm5hdGl2ZSwgYXBwcm92YWxzLmFzX3VpbnQ2NCgpLCByZWplY3Rpb25zLmFzX3VpbnQ2NCgpCiAgICBkaWcgMQogICAgYnRvaQogICAgYnVyeSA2CiAgICBkdXAKICAgIGJ0b2kKICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjIyMgogICAgLy8gaWYgdm90ZXIgbm90IGluIHNlbGYudm90ZXJzOgogICAgYnl0ZWMgMTkgLy8gIlYiCiAgICBkaWcgMwogICAgY29uY2F0CiAgICBkdXAKICAgIGJ1cnkgOQogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBibnogdm90ZV9hZnRlcl9pZl9lbHNlQDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyMjMKICAgIC8vIHJldHVybiB0eXAuRXJyb3IoZXJyLkFSQ182NV9QUkVGSVggKyBlcnIuVk9URVJfTk9UX0ZPVU5EKQogICAgcHVzaGJ5dGVzIDB4MDAxMzQ1NTI1MjNhNTY2Zjc0NjU3MjIwNmU2Zjc0MjA2NjZmNzU2ZTY0CiAgICBidXJ5IDcKCnZvdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudm90ZV9pbnB1dF92YWxpZGF0aW9uQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojg2OAogICAgLy8gaWYgZXJyb3IgIT0gdHlwLkVycm9yKCIiKToKICAgIGRpZyA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODYyCiAgICAvLyBpZiBlcnJvciAhPSB0eXAuRXJyb3IoIiIpOgogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4NjgKICAgIC8vIGlmIGVycm9yICE9IHR5cC5FcnJvcigiIik6CiAgICAhPQogICAgYnogdm90ZV9hZnRlcl9pZl9lbHNlQDUKICAgIGRpZyA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODM5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgYiB2b3RlX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLnZvdGVANgoKdm90ZV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODcxCiAgICAvLyB2b3RlcyA9IHNlbGYudm90ZXJzW3ZvdGVyLm5hdGl2ZV0KICAgIGRpZyA3CiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZvdGVycyBlbnRyeSBleGlzdHMKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4NzMKICAgIC8vIHNlbGYudm90ZWRfbWVtYmVycy52YWx1ZSArPSAxCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAweDc2NmY3NDY1NjQ1ZjZkNjU2ZDYyNjU3MjczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudm90ZWRfbWVtYmVycyBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBieXRlYyA5IC8vIDB4NzY2Zjc0NjU2NDVmNmQ2NTZkNjI2NTcyNzMKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODc1CiAgICAvLyBudWxscyA9IHZvdGVzIC0gYXBwcm92YWxzLmFzX3VpbnQ2NCgpIC0gcmVqZWN0aW9ucy5hc191aW50NjQoKQogICAgZHVwCiAgICBkaWcgOAogICAgZHVwCiAgICBjb3ZlciAyCiAgICAtCiAgICBkaWcgNwogICAgZHVwCiAgICBjb3ZlciAzCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODc3CiAgICAvLyBzZWxmLmFwcHJvdmFscy52YWx1ZSArPSBhcHByb3ZhbHMuYXNfdWludDY0KCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAweDYxNzA3MDcyNmY3NjYxNmM3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFwcHJvdmFscyBleGlzdHMKICAgIHVuY292ZXIgMgogICAgKwogICAgYnl0ZWMgMTAgLy8gMHg2MTcwNzA3MjZmNzY2MTZjNzMKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODc4CiAgICAvLyBzZWxmLnJlamVjdGlvbnMudmFsdWUgKz0gcmVqZWN0aW9ucy5hc191aW50NjQoKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDExIC8vIDB4NzI2NTZhNjU2Mzc0Njk2ZjZlNzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yZWplY3Rpb25zIGV4aXN0cwogICAgdW5jb3ZlciAyCiAgICArCiAgICBieXRlYyAxMSAvLyAweDcyNjU2YTY1NjM3NDY5NmY2ZTczCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojg3OQogICAgLy8gc2VsZi5udWxscy52YWx1ZSArPSBudWxscwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE0IC8vIDB4NmU3NTZjNmM3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm51bGxzIGV4aXN0cwogICAgKwogICAgYnl0ZWMgMTQgLy8gMHg2ZTc1NmM2YzczCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojg4MQogICAgLy8gc2VsZi5fdW5hc3NpZ25fdm90ZXIodm90ZXIubmF0aXZlLCB2b3RlcykKICAgIGRpZyA0CiAgICBzd2FwCiAgICBjYWxsc3ViIF91bmFzc2lnbl92b3RlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojg4NQogICAgLy8geGdvdj1hcmM0LkFkZHJlc3Moc2VsZi52b3RlcnMuYm94KHZvdGVyLm5hdGl2ZSkua2V5WzE6XSksCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgIGRpZyAxCiAgICA+PQogICAgaW50Y18xIC8vIDEKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgc3dhcAogICAgc3Vic3RyaW5nMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojg4NgogICAgLy8gdG90YWxfdm90ZXJzPWFyYzQuVUludDMyKHNlbGYudm90ZWRfbWVtYmVycy52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAweDc2NmY3NDY1NjQ1ZjZkNjU2ZDYyNjU3MjczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudm90ZWRfbWVtYmVycyBleGlzdHMKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gMzIKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNCA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODg3CiAgICAvLyB0b3RhbF9hcHByb3ZhbHM9YXJjNC5VSW50MzIoc2VsZi5hcHByb3ZhbHMudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vIDB4NjE3MDcwNzI2Zjc2NjE2YzczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXBwcm92YWxzIGV4aXN0cwogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMiAvLyAzMgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA0IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4ODgKICAgIC8vIHRvdGFsX3JlamVjdGlvbnM9YXJjNC5VSW50MzIoc2VsZi5yZWplY3Rpb25zLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAweDcyNjU2YTY1NjM3NDY5NmY2ZTczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucmVqZWN0aW9ucyBleGlzdHMKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gMzIKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNCA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODg5CiAgICAvLyB0b3RhbF9udWxscz1hcmM0LlVJbnQzMihzZWxmLm51bGxzLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNCAvLyAweDZlNzU2YzZjNzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5udWxscyBleGlzdHMKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gMzIKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNCA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODg0LTg5MAogICAgLy8gdHlwLlZvdGUoCiAgICAvLyAgICAgeGdvdj1hcmM0LkFkZHJlc3Moc2VsZi52b3RlcnMuYm94KHZvdGVyLm5hdGl2ZSkua2V5WzE6XSksCiAgICAvLyAgICAgdG90YWxfdm90ZXJzPWFyYzQuVUludDMyKHNlbGYudm90ZWRfbWVtYmVycy52YWx1ZSksCiAgICAvLyAgICAgdG90YWxfYXBwcm92YWxzPWFyYzQuVUludDMyKHNlbGYuYXBwcm92YWxzLnZhbHVlKSwKICAgIC8vICAgICB0b3RhbF9yZWplY3Rpb25zPWFyYzQuVUludDMyKHNlbGYucmVqZWN0aW9ucy52YWx1ZSksCiAgICAvLyAgICAgdG90YWxfbnVsbHM9YXJjNC5VSW50MzIoc2VsZi5udWxscy52YWx1ZSksCiAgICAvLyApCiAgICB1bmNvdmVyIDQKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojg4My04OTEKICAgIC8vIGFyYzQuZW1pdCgKICAgIC8vICAgICB0eXAuVm90ZSgKICAgIC8vICAgICAgICAgeGdvdj1hcmM0LkFkZHJlc3Moc2VsZi52b3RlcnMuYm94KHZvdGVyLm5hdGl2ZSkua2V5WzE6XSksCiAgICAvLyAgICAgICAgIHRvdGFsX3ZvdGVycz1hcmM0LlVJbnQzMihzZWxmLnZvdGVkX21lbWJlcnMudmFsdWUpLAogICAgLy8gICAgICAgICB0b3RhbF9hcHByb3ZhbHM9YXJjNC5VSW50MzIoc2VsZi5hcHByb3ZhbHMudmFsdWUpLAogICAgLy8gICAgICAgICB0b3RhbF9yZWplY3Rpb25zPWFyYzQuVUludDMyKHNlbGYucmVqZWN0aW9ucy52YWx1ZSksCiAgICAvLyAgICAgICAgIHRvdGFsX251bGxzPWFyYzQuVUludDMyKHNlbGYubnVsbHMudmFsdWUpLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIHB1c2hieXRlcyAweDE1NzdmNmU3IC8vIG1ldGhvZCAiVm90ZShhZGRyZXNzLHVpbnQzMix1aW50MzIsdWludDMyLHVpbnQzMikiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgZGlnIDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4MzkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBiIHZvdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudm90ZUA2Cgp2b3RlX2FmdGVyX2lmX2Vsc2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyMjUKICAgIC8vIHZvdGVzID0gc2VsZi52b3RlcnNbdm90ZXJdCiAgICBkaWcgNwogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudm90ZXJzIGVudHJ5IGV4aXN0cwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjIyNwogICAgLy8gaWYgYXBwcm92YWxzICsgcmVqZWN0aW9ucyA+IHZvdGVzOgogICAgZGlnIDYKICAgIGRpZyA1CiAgICArCiAgICA8CiAgICBieiB2b3RlX2FmdGVyX2lmX2Vsc2VAMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyMjgKICAgIC8vIHJldHVybiB0eXAuRXJyb3IoZXJyLkFSQ182NV9QUkVGSVggKyBlcnIuVk9URVNfRVhDRUVERUQpCiAgICBwdXNoYnl0ZXMgMHgwMDEyNDU1MjUyM2E1NjZmNzQ2NTczMjA2NTc4NjM2NTY1NjQ2NTY0CiAgICBidXJ5IDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo4NjUtODY3CiAgICAvLyBlcnJvciA9IHNlbGYudm90ZV9pbnB1dF92YWxpZGF0aW9uKAogICAgLy8gICAgIHZvdGVyLm5hdGl2ZSwgYXBwcm92YWxzLmFzX3VpbnQ2NCgpLCByZWplY3Rpb25zLmFzX3VpbnQ2NCgpCiAgICAvLyApCiAgICBiIHZvdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudm90ZV9pbnB1dF92YWxpZGF0aW9uQDEyCgp2b3RlX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICBkaWcgOAogICAgYnVyeSA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODY1LTg2NwogICAgLy8gZXJyb3IgPSBzZWxmLnZvdGVfaW5wdXRfdmFsaWRhdGlvbigKICAgIC8vICAgICB2b3Rlci5uYXRpdmUsIGFwcHJvdmFscy5hc191aW50NjQoKSwgcmVqZWN0aW9ucy5hc191aW50NjQoKQogICAgLy8gKQogICAgYiB2b3RlX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLnZvdGVfaW5wdXRfdmFsaWRhdGlvbkAxMgoKdm90ZV9hZnRlcl9pZl9lbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjIwOQogICAgLy8gaXNfdm90aW5nX29wZW4sIGVycm9yID0gc2VsZi5pc192b3Rpbmdfb3BlbigpCiAgICBjYWxsc3ViIGlzX3ZvdGluZ19vcGVuCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgOQogICAgYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MjEwCiAgICAvLyBpZiBlcnJvciAhPSB0eXAuRXJyb3IoIiIpOgogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgIGJ1cnkgMTEKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAhPQogICAgYm56IHZvdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudm90ZV9jaGVja19hdXRob3JpemF0aW9uQDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MjEzCiAgICAvLyBpZiBub3QgaXNfdm90aW5nX29wZW46CiAgICBkaWcgNAogICAgYm56IHZvdGVfYWZ0ZXJfaWZfZWxzZUAxOQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjIxNAogICAgLy8gcmV0dXJuIHR5cC5FcnJvcihlcnIuQVJDXzY1X1BSRUZJWCArIGVyci5WT1RJTkdfUEVSSU9EX0VYUElSRUQpCiAgICBwdXNoYnl0ZXMgMHgwMDE5NDU1MjUyM2E1NjZmNzQ2OTZlNjcyMDUwNjU3MjY5NmY2NDIwNDU3ODcwNjk3MjY1NjQKICAgIGJ1cnkgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojg2MQogICAgLy8gZXJyb3IgPSBzZWxmLnZvdGVfY2hlY2tfYXV0aG9yaXphdGlvbigpCiAgICBiIHZvdGVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwudm90ZV9jaGVja19hdXRob3JpemF0aW9uQDIwCgp2b3RlX2FmdGVyX2lmX2Vsc2VAMTk6CiAgICBkaWcgOQogICAgYnVyeSA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODYxCiAgICAvLyBlcnJvciA9IHNlbGYudm90ZV9jaGVja19hdXRob3JpemF0aW9uKCkKICAgIGIgdm90ZV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC52b3RlX2NoZWNrX2F1dGhvcml6YXRpb25AMjAKCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuc2NydXRpbnlbcm91dGluZ10oKSAtPiB2b2lkOgpzY3J1dGlueToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5MDYKICAgIC8vIHNlbGYuY2hlY2tfcmVnaXN0cnlfbm90X3BhdXNlZCgpCiAgICBjYWxsc3ViIGNoZWNrX3JlZ2lzdHJ5X25vdF9wYXVzZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyMzgKICAgIC8vIGFzc2VydCBzZWxmLnN0YXR1cy52YWx1ZSA9PSBlbm0uU1RBVFVTX1ZPVElORywgZXJyLldST05HX1BST1BPU0FMX1NUQVRVUwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0dXMgZXhpc3RzCiAgICBwdXNoaW50IDI1IC8vIDI1CiAgICA9PQogICAgYXNzZXJ0IC8vIFdyb25nIFByb3Bvc2FsIFN0YXR1cyBvciBmaW5hbGl6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNDAKICAgIC8vIGlzX3ZvdGluZ19vcGVuLCBlcnJvciA9IHNlbGYuaXNfdm90aW5nX29wZW4oKQogICAgY2FsbHN1YiBpc192b3Rpbmdfb3BlbgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI0MQogICAgLy8gYXNzZXJ0IGVycm9yID09IHR5cC5FcnJvcigiIiksIGVyci5NSVNTSU5HX0NPTkZJRwogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgID09CiAgICBhc3NlcnQgLy8gTWlzc2luZyBDb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNDQKICAgIC8vIG5vdCBpc192b3Rpbmdfb3BlbiAgIyB2b3RpbmcgcGVyaW9kIGhhcyBlbmRlZAogICAgYnogc2NydXRpbnlfYm9vbF90cnVlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNDUKICAgIC8vIG9yIHNlbGYuaXNfcGxlYmlzY2l0ZSgpICAjIGFsbCBjb21taXR0ZWUgbWVtYmVycyBhbHJlYWR5IHZvdGVkCiAgICBjYWxsc3ViIGlzX3BsZWJpc2NpdGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNDQtMjQ1CiAgICAvLyBub3QgaXNfdm90aW5nX29wZW4gICMgdm90aW5nIHBlcmlvZCBoYXMgZW5kZWQKICAgIC8vIG9yIHNlbGYuaXNfcGxlYmlzY2l0ZSgpICAjIGFsbCBjb21taXR0ZWUgbWVtYmVycyBhbHJlYWR5IHZvdGVkCiAgICBieiBzY3J1dGlueV9ib29sX2ZhbHNlQDgKCnNjcnV0aW55X2Jvb2xfdHJ1ZUA3OgogICAgaW50Y18xIC8vIDEKCnNjcnV0aW55X2Jvb2xfbWVyZ2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyNDMtMjQ2CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG5vdCBpc192b3Rpbmdfb3BlbiAgIyB2b3RpbmcgcGVyaW9kIGhhcyBlbmRlZAogICAgLy8gICAgIG9yIHNlbGYuaXNfcGxlYmlzY2l0ZSgpICAjIGFsbCBjb21taXR0ZWUgbWVtYmVycyBhbHJlYWR5IHZvdGVkCiAgICAvLyApLCBlcnIuVk9USU5HX09OR09JTkcKICAgIGFzc2VydCAvLyBWb3RpbmcgT25nb2luZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjkxMAogICAgLy8gaWYgc2VsZi5pc19wcm9wb3NhbF9hcHByb3ZlZCgpOgogICAgY2FsbHN1YiBpc19wcm9wb3NhbF9hcHByb3ZlZAogICAgYnogc2NydXRpbnlfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5MTEKICAgIC8vIHNlbGYuc3RhdHVzLnZhbHVlID0gVUludDY0KGVubS5TVEFUVVNfQVBQUk9WRUQpCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNzQ3NTczCiAgICBwdXNoaW50IDMwIC8vIDMwCiAgICBhcHBfZ2xvYmFsX3B1dAoKc2NydXRpbnlfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjkyMAogICAgLy8gYXBwcm92ZWQ9YXJjNC5Cb29sKHNlbGYuaXNfcHJvcG9zYWxfYXBwcm92ZWQoKSksCiAgICBjYWxsc3ViIGlzX3Byb3Bvc2FsX2FwcHJvdmVkCiAgICBieXRlYyAxOCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5MjEKICAgIC8vIHBsZWJpc2NpdGU9YXJjNC5Cb29sKHNlbGYuaXNfcGxlYmlzY2l0ZSgpKSwKICAgIGNhbGxzdWIgaXNfcGxlYmlzY2l0ZQogICAgYnl0ZWMgMTggLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTE5LTkyMgogICAgLy8gdHlwLlNjcnV0aW55KAogICAgLy8gICAgIGFwcHJvdmVkPWFyYzQuQm9vbChzZWxmLmlzX3Byb3Bvc2FsX2FwcHJvdmVkKCkpLAogICAgLy8gICAgIHBsZWJpc2NpdGU9YXJjNC5Cb29sKHNlbGYuaXNfcGxlYmlzY2l0ZSgpKSwKICAgIC8vICkKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGludGNfMSAvLyAxCiAgICBzd2FwCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5MTgtOTIzCiAgICAvLyBhcmM0LmVtaXQoCiAgICAvLyAgICAgdHlwLlNjcnV0aW55KAogICAgLy8gICAgICAgICBhcHByb3ZlZD1hcmM0LkJvb2woc2VsZi5pc19wcm9wb3NhbF9hcHByb3ZlZCgpKSwKICAgIC8vICAgICAgICAgcGxlYmlzY2l0ZT1hcmM0LkJvb2woc2VsZi5pc19wbGViaXNjaXRlKCkpLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIHB1c2hieXRlcyAweDJiZDk5YWU0IC8vIG1ldGhvZCAiU2NydXRpbnkoYm9vbCxib29sKSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6ODk1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKc2NydXRpbnlfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTEzCiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSA9IFVJbnQ2NChlbm0uU1RBVFVTX1JFSkVDVEVEKQogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgcHVzaGludCA0MCAvLyA0MAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5MTUKICAgIC8vIHJlY2VpdmVyPXNlbGYucHJvcG9zZXIudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAweDcwNzI2ZjcwNmY3MzY1NzIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wcm9wb3NlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5MTQtOTE2CiAgICAvLyBzZWxmLnRyYW5zZmVyX2xvY2tlZF9hbW91bnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9c2VsZi5wcm9wb3Nlci52YWx1ZSwKICAgIC8vICkKICAgIGNhbGxzdWIgdHJhbnNmZXJfbG9ja2VkX2Ftb3VudAogICAgYiBzY3J1dGlueV9hZnRlcl9pZl9lbHNlQDQKCnNjcnV0aW55X2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIHNjcnV0aW55X2Jvb2xfbWVyZ2VAOQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5yZXZpZXdbcm91dGluZ10oKSAtPiB2b2lkOgpyZXZpZXc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTI1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwbiAyCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmJvb2wKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1MTYKICAgIC8vIHJldHVybiBUeG4uc2VuZGVyID09IEFjY291bnQoCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTE3CiAgICAvLyBzZWxmLmdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZyhCeXRlcyhyZWdfY2ZnLkdTX0tFWV9YR09WX0NPVU5DSUwpKQogICAgcHVzaGJ5dGVzIDB4Nzg2NzZmNzY1ZjYzNmY3NTZlNjM2OTZjCiAgICBjYWxsc3ViIGdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUxNi01MTgKICAgIC8vIHJldHVybiBUeG4uc2VuZGVyID09IEFjY291bnQoCiAgICAvLyAgICAgc2VsZi5nZXRfYnl0ZXNfZnJvbV9yZWdpc3RyeV9jb25maWcoQnl0ZXMocmVnX2NmZy5HU19LRVlfWEdPVl9DT1VOQ0lMKSkKICAgIC8vICkKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gQWRkcmVzcyBsZW5ndGggaXMgMzIgYnl0ZXMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTYxCiAgICAvLyBhc3NlcnQgc2VsZi5pc19jb3VuY2lsKCksIGVyci5VTkFVVEhPUklaRUQKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxNjIKICAgIC8vIGFzc2VydCBzZWxmLnN0YXR1cy52YWx1ZSA9PSBlbm0uU1RBVFVTX0FQUFJPVkVELCBlcnIuV1JPTkdfUFJPUE9TQUxfU1RBVFVTCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXR1cyBleGlzdHMKICAgIHB1c2hpbnQgMzAgLy8gMzAKICAgID09CiAgICBhc3NlcnQgLy8gV3JvbmcgUHJvcG9zYWwgU3RhdHVzIG9yIGZpbmFsaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk0MS05NDIKICAgIC8vICMgY2hlY2sgbm8gYXNzaWduZWQgdm90ZXJzCiAgICAvLyBhc3NlcnQgbm90IHNlbGYudm90ZXJzX2NvdW50LCBlcnIuVk9URVJTX0FTU0lHTkVECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNiAvLyAidm90ZXJzX2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZvdGVyc19jb3VudCBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBUaGVyZSBhcmUgdm90ZXJzIGFzc2lnbmVkIHRvIHRoaXMgcHJvcG9zYWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5NDQKICAgIC8vIGlmIGJsb2NrOgogICAgYnogcmV2aWV3X2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTQ1CiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSA9IFVJbnQ2NChlbm0uU1RBVFVTX0JMT0NLRUQpCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNzQ3NTczCiAgICBwdXNoaW50IDYwIC8vIDYwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk0Ny05NDgKICAgIC8vICMgc2xhc2hpbmc6IHNlbmQgbG9ja2VkIGFtb3VudCB0byB0aGUgcmVnaXN0cnkgdHJlYXN1cnkKICAgIC8vIHJlZ19hcHAgPSBBcHBsaWNhdGlvbihzZWxmLnJlZ2lzdHJ5X2FwcF9pZC52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vIDB4NzI2NTY3Njk3Mzc0NzI3OTVmNjE3MDcwNWY2OTY0CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucmVnaXN0cnlfYXBwX2lkIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk1MAogICAgLy8gcmVjZWl2ZXI9cmVnX2FwcC5hZGRyZXNzLAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk0OS05NTEKICAgIC8vIHNlbGYudHJhbnNmZXJfbG9ja2VkX2Ftb3VudCgKICAgIC8vICAgICByZWNlaXZlcj1yZWdfYXBwLmFkZHJlc3MsCiAgICAvLyApCiAgICBjYWxsc3ViIHRyYW5zZmVyX2xvY2tlZF9hbW91bnQKCnJldmlld19hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTYxCiAgICAvLyBhcmM0LmVtaXQodHlwLlJldmlldyh2ZXRvPWFyYzQuQm9vbChibG9jaykpKQogICAgcHVzaGJ5dGVzIDB4ZDk5Mzk2NDQgLy8gbWV0aG9kICJSZXZpZXcoYm9vbCkiCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5MjUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpyZXZpZXdfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTU0CiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSA9IFVJbnQ2NChlbm0uU1RBVFVTX1JFVklFV0VEKQogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgcHVzaGludCA0NSAvLyA0NQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5NTgKICAgIC8vIHJlY2VpdmVyPXNlbGYucHJvcG9zZXIudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAweDcwNzI2ZjcwNmY3MzY1NzIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wcm9wb3NlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5NTYtOTU5CiAgICAvLyAjIHJlZnVuZCB0aGUgbG9ja2VkIGFtb3VudCB0byB0aGUgcHJvcG9zZXIKICAgIC8vIHNlbGYudHJhbnNmZXJfbG9ja2VkX2Ftb3VudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLnByb3Bvc2VyLnZhbHVlLAogICAgLy8gKQogICAgY2FsbHN1YiB0cmFuc2Zlcl9sb2NrZWRfYW1vdW50CiAgICBiIHJldmlld19hZnRlcl9pZl9lbHNlQDQKCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuZnVuZFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmZ1bmQ6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTY2CiAgICAvLyBhc3NlcnQgc2VsZi5pc19yZWdpc3RyeV9jYWxsKCksIGVyci5VTkFVVEhPUklaRUQKICAgIGNhbGxzdWIgaXNfcmVnaXN0cnlfY2FsbAogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE2NwogICAgLy8gaWYgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19SRVZJRVdFRDoKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNzQ3NTczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdHVzIGV4aXN0cwogICAgcHVzaGludCA0NSAvLyA0NQogICAgIT0KICAgIGJ6IGZ1bmRfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTY4CiAgICAvLyByZXR1cm4gdHlwLkVycm9yKGVyci5BUkNfNjVfUFJFRklYICsgZXJyLldST05HX1BST1BPU0FMX1NUQVRVUykKICAgIGJ5dGVjIDI0IC8vIDB4MDAyNjQ1NTI1MjNhNTc3MjZmNmU2NzIwNTA3MjZmNzA2ZjczNjE2YzIwNTM3NDYxNzQ3NTczMjA2ZjcyMjA2NjY5NmU2MTZjNjk3YTY1NjQKICAgIGJ1cnkgMQoKZnVuZF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5mdW5kX2NoZWNrX2F1dGhvcml6YXRpb25AODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5NzMKICAgIC8vIGlmIGVycm9yICE9IHR5cC5FcnJvcigiIik6CiAgICBieXRlY18wIC8vIDB4MDAwMAogICAgYnVyeSAyCiAgICBkdXAKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAhPQogICAgYnogZnVuZF9hZnRlcl9pZl9lbHNlQDMKICAgIGR1cAoKZnVuZF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5mdW5kQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTYzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgYnl0ZWMgMTIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmZ1bmRfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk3NgogICAgLy8gc2VsZi5zdGF0dXMudmFsdWUgPSBVSW50NjQoZW5tLlNUQVRVU19GVU5ERUQpCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNzQ3NTczCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5NjMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBiIGZ1bmRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuZnVuZEA0CgpmdW5kX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxNzAKICAgIC8vIHJldHVybiB0eXAuRXJyb3IoIiIpCiAgICBieXRlY18wIC8vIDB4MDAwMAogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6OTcyCiAgICAvLyBlcnJvciA9IHNlbGYuZnVuZF9jaGVja19hdXRob3JpemF0aW9uKCkKICAgIGIgZnVuZF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5mdW5kX2NoZWNrX2F1dGhvcml6YXRpb25AOAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC51bmFzc2lnbl92b3RlcnNbcm91dGluZ10oKSAtPiB2b2lkOgp1bmFzc2lnbl92b3RlcnM6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk4MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cG4gMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGR1cAogICAgY292ZXIgMgogICAgaW50Y18yIC8vIDMyCiAgICAqCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+PgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE3NAogICAgLy8gaWYgc2VsZi5zdGF0dXMudmFsdWUgPT0gZW5tLlNUQVRVU19TVUJNSVRURUQ6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXR1cyBleGlzdHMKICAgIHB1c2hpbnQgMjAgLy8gMjAKICAgID09CiAgICBieiB1bmFzc2lnbl92b3RlcnNfZWxzZV9ib2R5QDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTc1CiAgICAvLyBhc3NlcnQgc2VsZi5pc194Z292X2RhZW1vbigpLCBlcnIuVU5BVVRIT1JJWkVECiAgICBjYWxsc3ViIGlzX3hnb3ZfZGFlbW9uCiAgICBhc3NlcnQgLy8gVW5hdXRob3JpemVkCgp1bmFzc2lnbl92b3RlcnNfYWZ0ZXJfaWZfZWxzZUAyMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5OTYKICAgIC8vIGlmIFR4bi5ncm91cF9pbmRleCA9PSAwOgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGJueiB1bmFzc2lnbl92b3RlcnNfZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5OTctOTk4CiAgICAvLyAjIENoZWNrIHRoYXQgdGhlIGVudGlyZSBncm91cCBjYWxscyB0aGUgc2FtZSBhcHAgYW5kIG1ldGhvZAogICAgLy8gZm9yIGkgaW4gdXJhbmdlKDEsIEdsb2JhbC5ncm91cF9zaXplKToKICAgIGdsb2JhbCBHcm91cFNpemUKICAgIGJ1cnkgMwogICAgaW50Y18xIC8vIDEKICAgIGJ1cnkgNQoKdW5hc3NpZ25fdm90ZXJzX2Zvcl9oZWFkZXJAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo5OTctOTk4CiAgICAvLyAjIENoZWNrIHRoYXQgdGhlIGVudGlyZSBncm91cCBjYWxscyB0aGUgc2FtZSBhcHAgYW5kIG1ldGhvZAogICAgLy8gZm9yIGkgaW4gdXJhbmdlKDEsIEdsb2JhbC5ncm91cF9zaXplKToKICAgIGRpZyA0CiAgICBkaWcgMwogICAgPAogICAgYnogdW5hc3NpZ25fdm90ZXJzX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk5OQogICAgLy8gc2VsZi5hc3NlcnRfc2FtZV9hcHBfYW5kX21ldGhvZChpKQogICAgZGlnIDQKICAgIGR1cAogICAgY2FsbHN1YiBhc3NlcnRfc2FtZV9hcHBfYW5kX21ldGhvZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk5Ny05OTgKICAgIC8vICMgQ2hlY2sgdGhhdCB0aGUgZW50aXJlIGdyb3VwIGNhbGxzIHRoZSBzYW1lIGFwcCBhbmQgbWV0aG9kCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoMSwgR2xvYmFsLmdyb3VwX3NpemUpOgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgNQogICAgYiB1bmFzc2lnbl92b3RlcnNfZm9yX2hlYWRlckAzCgp1bmFzc2lnbl92b3RlcnNfYWZ0ZXJfaWZfZWxzZUA4OgogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgNAoKdW5hc3NpZ25fdm90ZXJzX2Zvcl9oZWFkZXJAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDA0LTEwMDUKICAgIC8vICMgcmVtb3ZlIHZvdGVycwogICAgLy8gZm9yIHZvdGVyIGluIHZvdGVyczoKICAgIGRpZyAzCiAgICBkaWcgMQogICAgPAogICAgYnogdW5hc3NpZ25fdm90ZXJzX2FmdGVyX2ZvckAxNAogICAgZGlnIDEKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgNAogICAgaW50Y18yIC8vIDMyCiAgICAqCiAgICBpbnRjXzIgLy8gMzIKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBidXJ5IDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDA2CiAgICAvLyBpZiB2b3Rlci5uYXRpdmUgaW4gc2VsZi52b3RlcnM6CiAgICBieXRlYyAxOSAvLyAiViIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBidXJ5IDgKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogdW5hc3NpZ25fdm90ZXJzX2FmdGVyX2lmX2Vsc2VAMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDA3CiAgICAvLyB2b3RlcyA9IHNlbGYudm90ZXJzW3ZvdGVyLm5hdGl2ZV0KICAgIGRpZyA2CiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52b3RlcnMgZW50cnkgZXhpc3RzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTAwOAogICAgLy8gc2VsZi5fdW5hc3NpZ25fdm90ZXIodm90ZXIubmF0aXZlLCB2b3RlcykKICAgIGRpZyA2CiAgICBzd2FwCiAgICBjYWxsc3ViIF91bmFzc2lnbl92b3RlcgoKdW5hc3NpZ25fdm90ZXJzX2FmdGVyX2lmX2Vsc2VAMTI6CiAgICBkaWcgMwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgNAogICAgYiB1bmFzc2lnbl92b3RlcnNfZm9yX2hlYWRlckA5Cgp1bmFzc2lnbl92b3RlcnNfYWZ0ZXJfZm9yQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojk4MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnVuYXNzaWduX3ZvdGVyc19lbHNlX2JvZHlANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDAxLTEwMDIKICAgIC8vICMgQ2hlY2sgdGhhdCB0aGUgZmlyc3QgdHJhbnNhY3Rpb24gaW4gdGhlIGdyb3VwIGNhbGxzIHRoZSBzYW1lIGFwcCBhbmQgbWV0aG9kCiAgICAvLyBzZWxmLmFzc2VydF9zYW1lX2FwcF9hbmRfbWV0aG9kKFVJbnQ2NCgwKSkKICAgIGludGNfMCAvLyAwCiAgICBjYWxsc3ViIGFzc2VydF9zYW1lX2FwcF9hbmRfbWV0aG9kCiAgICBiIHVuYXNzaWduX3ZvdGVyc19hZnRlcl9pZl9lbHNlQDgKCnVuYXNzaWduX3ZvdGVyc19lbHNlX2JvZHlAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTc4CiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSA9PSBlbm0uU1RBVFVTX0FQUFJPVkVECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXR1cyBleGlzdHMKICAgIHB1c2hpbnQgMzAgLy8gMzAKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTc4LTE3OQogICAgLy8gc2VsZi5zdGF0dXMudmFsdWUgPT0gZW5tLlNUQVRVU19BUFBST1ZFRAogICAgLy8gb3Igc2VsZi5zdGF0dXMudmFsdWUgPT0gZW5tLlNUQVRVU19SRUpFQ1RFRAogICAgYm56IHVuYXNzaWduX3ZvdGVyc19hbmRfY29udGRAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxNzkKICAgIC8vIG9yIHNlbGYuc3RhdHVzLnZhbHVlID09IGVubS5TVEFUVVNfUkVKRUNURUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNzQ3NTczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdHVzIGV4aXN0cwogICAgcHVzaGludCA0MCAvLyA0MAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxNzgtMTc5CiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSA9PSBlbm0uU1RBVFVTX0FQUFJPVkVECiAgICAvLyBvciBzZWxmLnN0YXR1cy52YWx1ZSA9PSBlbm0uU1RBVFVTX1JFSkVDVEVECiAgICBieiB1bmFzc2lnbl92b3RlcnNfYm9vbF9mYWxzZUAyMQoKdW5hc3NpZ25fdm90ZXJzX2FuZF9jb250ZEAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxODAKICAgIC8vICkgYW5kIG5vdCBzZWxmLmZpbmFsaXplZC52YWx1ZSwgZXJyLldST05HX1BST1BPU0FMX1NUQVRVUwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gMHg2NjY5NmU2MTZjNjk3YTY1NjQKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5maW5hbGl6ZWQgZXhpc3RzCiAgICBibnogdW5hc3NpZ25fdm90ZXJzX2Jvb2xfZmFsc2VAMjEKICAgIGludGNfMSAvLyAxCgp1bmFzc2lnbl92b3RlcnNfYm9vbF9tZXJnZUAyMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxNzctMTgwCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuc3RhdHVzLnZhbHVlID09IGVubS5TVEFUVVNfQVBQUk9WRUQKICAgIC8vICAgICBvciBzZWxmLnN0YXR1cy52YWx1ZSA9PSBlbm0uU1RBVFVTX1JFSkVDVEVECiAgICAvLyApIGFuZCBub3Qgc2VsZi5maW5hbGl6ZWQudmFsdWUsIGVyci5XUk9OR19QUk9QT1NBTF9TVEFUVVMKICAgIGFzc2VydCAvLyBXcm9uZyBQcm9wb3NhbCBTdGF0dXMgb3IgZmluYWxpemVkCiAgICBiIHVuYXNzaWduX3ZvdGVyc19hZnRlcl9pZl9lbHNlQDIzCgp1bmFzc2lnbl92b3RlcnNfYm9vbF9mYWxzZUAyMToKICAgIGludGNfMCAvLyAwCiAgICBiIHVuYXNzaWduX3ZvdGVyc19ib29sX21lcmdlQDIyCgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmZpbmFsaXplW3JvdXRpbmddKCkgLT4gdm9pZDoKZmluYWxpemU6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTg0CiAgICAvLyBhc3NlcnQgc2VsZi5pc19yZWdpc3RyeV9jYWxsKCksIGVyci5VTkFVVEhPUklaRUQKICAgIGNhbGxzdWIgaXNfcmVnaXN0cnlfY2FsbAogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE4NgogICAgLy8gaWYgc2VsZi5maW5hbGl6ZWQudmFsdWUgb3IgKAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gMHg2NjY5NmU2MTZjNjk3YTY1NjQKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5maW5hbGl6ZWQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTg2LTE5MgogICAgLy8gaWYgc2VsZi5maW5hbGl6ZWQudmFsdWUgb3IgKAogICAgLy8gICAgIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfRU1QVFkKICAgIC8vICAgICBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19EUkFGVAogICAgLy8gICAgIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0ZVTkRFRAogICAgLy8gICAgIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0JMT0NLRUQKICAgIC8vICAgICBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19SRUpFQ1RFRAogICAgLy8gKToKICAgIGJueiBmaW5hbGl6ZV9pZl9ib2R5QDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTg3CiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0VNUFRZCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXR1cyBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxODctMTkxCiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0VNUFRZCiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19EUkFGVAogICAgLy8gYW5kIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfRlVOREVECiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19CTE9DS0VECiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19SRUpFQ1RFRAogICAgYnogZmluYWxpemVfYWZ0ZXJfaWZfZWxzZUAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE4OAogICAgLy8gYW5kIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfRFJBRlQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNzQ3NTczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdHVzIGV4aXN0cwogICAgaW50Y18zIC8vIDEwCiAgICAhPQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE4Ny0xOTEKICAgIC8vIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfRU1QVFkKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0RSQUZUCiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19GVU5ERUQKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0JMT0NLRUQKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX1JFSkVDVEVECiAgICBieiBmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDE2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTg5CiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19GVU5ERUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNzQ3NTczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdHVzIGV4aXN0cwogICAgcHVzaGludCA1MCAvLyA1MAogICAgIT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxODctMTkxCiAgICAvLyBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0VNUFRZCiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19EUkFGVAogICAgLy8gYW5kIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfRlVOREVECiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19CTE9DS0VECiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19SRUpFQ1RFRAogICAgYnogZmluYWxpemVfYWZ0ZXJfaWZfZWxzZUAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE5MAogICAgLy8gYW5kIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfQkxPQ0tFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0dXMgZXhpc3RzCiAgICBwdXNoaW50IDYwIC8vIDYwCiAgICAhPQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE4Ny0xOTEKICAgIC8vIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfRU1QVFkKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0RSQUZUCiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19GVU5ERUQKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0JMT0NLRUQKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX1JFSkVDVEVECiAgICBieiBmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDE2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTkxCiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19SRUpFQ1RFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0dXMgZXhpc3RzCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICAhPQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE4Ny0xOTEKICAgIC8vIHNlbGYuc3RhdHVzLnZhbHVlICE9IGVubS5TVEFUVVNfRU1QVFkKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0RSQUZUCiAgICAvLyBhbmQgc2VsZi5zdGF0dXMudmFsdWUgIT0gZW5tLlNUQVRVU19GVU5ERUQKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX0JMT0NLRUQKICAgIC8vIGFuZCBzZWxmLnN0YXR1cy52YWx1ZSAhPSBlbm0uU1RBVFVTX1JFSkVDVEVECiAgICBieiBmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDE2CgpmaW5hbGl6ZV9pZl9ib2R5QDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE5MwogICAgLy8gcmV0dXJuIHR5cC5FcnJvcihlcnIuQVJDXzY1X1BSRUZJWCArIGVyci5XUk9OR19QUk9QT1NBTF9TVEFUVVMpCiAgICBieXRlYyAyNCAvLyAweDAwMjY0NTUyNTIzYTU3NzI2ZjZlNjcyMDUwNzI2ZjcwNmY3MzYxNmMyMDUzNzQ2MTc0NzU3MzIwNmY3MjIwNjY2OTZlNjE2YzY5N2E2NTY0CiAgICBidXJ5IDEKCmZpbmFsaXplX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmZpbmFsaXplX2NoZWNrX2F1dGhvcml6YXRpb25AMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTAyMgogICAgLy8gaWYgZXJyb3IgIT0gdHlwLkVycm9yKCIiKToKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICBidXJ5IDIKICAgIGR1cAogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgICE9CiAgICBieiBmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDMKICAgIGR1cAoKZmluYWxpemVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuZmluYWxpemVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDEwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgYnl0ZWMgMTIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmZpbmFsaXplX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDI1LTEwMjYKICAgIC8vICMgY2hlY2sgbm8gYXNzaWduZWQgdm90ZXJzCiAgICAvLyBpZiBzZWxmLnZvdGVyc19jb3VudCA+IFVJbnQ2NCgwKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ2b3RlcnNfY291bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudm90ZXJzX2NvdW50IGV4aXN0cwogICAgYnogZmluYWxpemVfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTAyNwogICAgLy8gcmV0dXJuIHR5cC5FcnJvcihlcnIuQVJDXzY1X1BSRUZJWCArIGVyci5WT1RFUlNfQVNTSUdORUQpCiAgICBwdXNoYnl0ZXMgMHgwMDJlNDU1MjUyM2E1NDY4NjU3MjY1MjA2MTcyNjUyMDc2NmY3NDY1NzI3MzIwNjE3MzczNjk2NzZlNjU2NDIwNzQ2ZjIwNzQ2ODY5NzMyMDcwNzI2ZjcwNmY3MzYxNmMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDEwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgYiBmaW5hbGl6ZV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5maW5hbGl6ZUA4CgpmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTAyOS0xMDMyCiAgICAvLyAjIHJlZnVuZCB0aGUgbG9ja2VkIGFtb3VudCBmb3IgRFJBRlQgcHJvcG9zYWxzCiAgICAvLyAjIGZvciBSRUpFQ1RFRCBwcm9wb3NhbHMsIHRoZSBsb2NrZWQgYW1vdW50IGlzIGFscmVhZHkgcmVmdW5kZWQgaW4gdGhlIHNjcnV0aW55IG1ldGhvZAogICAgLy8gIyBmb3IgRU1QVFksIEZVTkRFRCwgb3IgQkxPQ0tFRCBwcm9wb3NhbHMsIHRoZSBsb2NrZWQgYW1vdW50IGlzIG5vdCByZWZ1bmRhYmxlCiAgICAvLyBpZiBzZWxmLnN0YXR1cy52YWx1ZSA9PSBlbm0uU1RBVFVTX0RSQUZUOgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0dXMgZXhpc3RzCiAgICBpbnRjXzMgLy8gMTAKICAgID09CiAgICBieiBmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDM0CiAgICAvLyByZWNlaXZlcj1zZWxmLnByb3Bvc2VyLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gMHg3MDcyNmY3MDZmNzM2NTcyCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucHJvcG9zZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTAzMy0xMDM1CiAgICAvLyBzZWxmLnRyYW5zZmVyX2xvY2tlZF9hbW91bnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9c2VsZi5wcm9wb3Nlci52YWx1ZSwKICAgIC8vICkKICAgIGNhbGxzdWIgdHJhbnNmZXJfbG9ja2VkX2Ftb3VudAoKZmluYWxpemVfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwMzYKICAgIC8vIHJlZ19hcHAgPSBBcHBsaWNhdGlvbihzZWxmLnJlZ2lzdHJ5X2FwcF9pZC52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vIDB4NzI2NTY3Njk3Mzc0NzI3OTVmNjE3MDcwNWY2OTY0CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucmVnaXN0cnlfYXBwX2lkIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwMzgKICAgIC8vIHJlY2VpdmVyPXJlZ19hcHAuYWRkcmVzcywKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDM5CiAgICAvLyBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDQwCiAgICAvLyAtIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDM5LTEwNDAKICAgIC8vIGFtb3VudD1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UKICAgIC8vIC0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZSwKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDM3LTEwNDEKICAgIC8vIHNlbGYucGF5KAogICAgLy8gICAgIHJlY2VpdmVyPXJlZ19hcHAuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlCiAgICAvLyAgICAgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlLAogICAgLy8gKQogICAgY2FsbHN1YiBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDQyCiAgICAvLyBzZWxmLmZpbmFsaXplZC52YWx1ZSA9IFRydWUKICAgIGJ5dGVjXzMgLy8gMHg2NjY5NmU2MTZjNjk3YTY1NjQKICAgIGludGNfMSAvLyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDEwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgYiBmaW5hbGl6ZV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5maW5hbGl6ZUA4CgpmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE5NQogICAgLy8gcmV0dXJuIHR5cC5FcnJvcigiIikKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDIxCiAgICAvLyBlcnJvciA9IHNlbGYuZmluYWxpemVfY2hlY2tfYXV0aG9yaXphdGlvbigpCiAgICBiIGZpbmFsaXplX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmZpbmFsaXplX2NoZWNrX2F1dGhvcml6YXRpb25AMTcKCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuZGVsZXRlW3JvdXRpbmddKCkgLT4gdm9pZDoKZGVsZXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE5OQogICAgLy8gYXNzZXJ0IHNlbGYuaXNfeGdvdl9kYWVtb24oKSwgZXJyLlVOQVVUSE9SSVpFRAogICAgY2FsbHN1YiBpc194Z292X2RhZW1vbgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjIwMAogICAgLy8gYXNzZXJ0IHNlbGYuZmluYWxpemVkLnZhbHVlLCBlcnIuV1JPTkdfUFJPUE9TQUxfU1RBVFVTCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAweDY2Njk2ZTYxNmM2OTdhNjU2NAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZpbmFsaXplZCBleGlzdHMKICAgIGFzc2VydCAvLyBXcm9uZyBQcm9wb3NhbCBTdGF0dXMgb3IgZmluYWxpemVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA1OC0xMDU5CiAgICAvLyAjIGRlbGV0ZSBtZXRhZGF0YSBib3ggaWYgaXQgZXhpc3RzCiAgICAvLyBkZWwgc2VsZi5tZXRhZGF0YS52YWx1ZQogICAgYnl0ZWMgNyAvLyAiTSIKICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwNjEKICAgIC8vIHJlZ19hcHAgPSBBcHBsaWNhdGlvbihzZWxmLnJlZ2lzdHJ5X2FwcF9pZC52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vIDB4NzI2NTY3Njk3Mzc0NzI3OTVmNjE3MDcwNWY2OTY0CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucmVnaXN0cnlfYXBwX2lkIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwNjMKICAgIC8vIHJlY2VpdmVyPXJlZ19hcHAuYWRkcmVzcywKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDY0CiAgICAvLyBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA2Mi0xMDY1CiAgICAvLyBzZWxmLnBheSgKICAgIC8vICAgICByZWNlaXZlcj1yZWdfYXBwLmFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50PUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZSwKICAgIC8vICkKICAgIGNhbGxzdWIgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA0NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9KCJEZWxldGVBcHBsaWNhdGlvbiIsKSkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuZ2V0X3N0YXRlW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0X3N0YXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwNzYKICAgIC8vIHByb3Bvc2VyPWFyYzQuQWRkcmVzcyhzZWxmLnByb3Bvc2VyLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vIDB4NzA3MjZmNzA2ZjczNjU3MgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnByb3Bvc2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwNzcKICAgIC8vIHJlZ2lzdHJ5X2FwcF9pZD1hcmM0LlVJbnQ2NChzZWxmLnJlZ2lzdHJ5X2FwcF9pZC52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAweDcyNjU2NzY5NzM3NDcyNzk1ZjYxNzA3MDVmNjk2NAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJlZ2lzdHJ5X2FwcF9pZCBleGlzdHMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDc4CiAgICAvLyB0aXRsZT1hcmM0LlN0cmluZyhzZWxmLnRpdGxlLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyNSAvLyAweDc0Njk3NDZjNjUKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50aXRsZSBleGlzdHMKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA3OQogICAgLy8gb3Blbl90cz1hcmM0LlVJbnQ2NChzZWxmLm9wZW5fdHMudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDIwIC8vIDB4NmY3MDY1NmU1Zjc0Njk2ZDY1NzM3NDYxNmQ3MAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm9wZW5fdHMgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA4MAogICAgLy8gc3VibWlzc2lvbl90cz1hcmM0LlVJbnQ2NChzZWxmLnN1Ym1pc3Npb25fdHMudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDI2IC8vIDB4NzM3NTYyNmQ2OTczNzM2OTZmNmU1Zjc0Njk2ZDY1NzM3NDYxNmQ3MAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN1Ym1pc3Npb25fdHMgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA4MQogICAgLy8gdm90ZV9vcGVuX3RzPWFyYzQuVUludDY0KHNlbGYudm90ZV9vcGVuX3RzLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNiAvLyAweDc2NmY3NDY1NWY2ZjcwNjU2ZTY5NmU2NzVmNzQ2OTZkNjU3Mzc0NjE2ZDcwCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudm90ZV9vcGVuX3RzIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwODIKICAgIC8vIHN0YXR1cz1hcmM0LlVJbnQ2NChzZWxmLnN0YXR1cy52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAweDczNzQ2MTc0NzU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXR1cyBleGlzdHMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDgzCiAgICAvLyBmaW5hbGl6ZWQ9YXJjNC5Cb29sKHNlbGYuZmluYWxpemVkLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vIDB4NjY2OTZlNjE2YzY5N2E2NTY0CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmluYWxpemVkIGV4aXN0cwogICAgYnl0ZWMgMTggLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA4NAogICAgLy8gZnVuZGluZ19jYXRlZ29yeT1hcmM0LlVJbnQ2NChzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gMHg2Njc1NmU2NDY5NmU2NzVmNjM2MTc0NjU2NzZmNzI3OQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA4NQogICAgLy8gZm9jdXM9YXJjNC5VSW50OChzZWxmLmZvY3VzLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyNyAvLyAweDY2NmY2Mzc1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5mb2N1cyBleGlzdHMKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDg2CiAgICAvLyBmdW5kaW5nX3R5cGU9YXJjNC5VSW50NjQoc2VsZi5mdW5kaW5nX3R5cGUudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDIxIC8vIDB4NjY3NTZlNjQ2OTZlNjc1Zjc0Nzk3MDY1CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZnVuZGluZ190eXBlIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwODcKICAgIC8vIHJlcXVlc3RlZF9hbW91bnQ9YXJjNC5VSW50NjQoc2VsZi5yZXF1ZXN0ZWRfYW1vdW50LnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMiAvLyAweDcyNjU3MTc1NjU3Mzc0NjU2NDVmNjE2ZDZmNzU2ZTc0CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucmVxdWVzdGVkX2Ftb3VudCBleGlzdHMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDg4CiAgICAvLyBsb2NrZWRfYW1vdW50PWFyYzQuVUludDY0KHNlbGYubG9ja2VkX2Ftb3VudC52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTcgLy8gMHg2YzZmNjM2YjY1NjQ1ZjYxNmQ2Zjc1NmU3NAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmxvY2tlZF9hbW91bnQgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA4OQogICAgLy8gY29tbWl0dGVlX2lkPXNlbGYuY29tbWl0dGVlX2lkLnZhbHVlLmNvcHkoKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMyAvLyAweDYzNmY2ZDZkNjk3NDc0NjU2NTVmNjk2NAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbW1pdHRlZV9pZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDkwCiAgICAvLyBjb21taXR0ZWVfbWVtYmVycz1hcmM0LlVJbnQ2NChzZWxmLmNvbW1pdHRlZV9tZW1iZXJzLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vIDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY2ZDY1NmQ2MjY1NzI3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbW1pdHRlZV9tZW1iZXJzIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwOTEKICAgIC8vIGNvbW1pdHRlZV92b3Rlcz1hcmM0LlVJbnQ2NChzZWxmLmNvbW1pdHRlZV92b3Rlcy52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTMgLy8gMHg2MzZmNmQ2ZDY5NzQ3NDY1NjU1Zjc2NmY3NDY1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb21taXR0ZWVfdm90ZXMgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA5MgogICAgLy8gdm90ZWRfbWVtYmVycz1hcmM0LlVJbnQ2NChzZWxmLnZvdGVkX21lbWJlcnMudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gMHg3NjZmNzQ2NTY0NWY2ZDY1NmQ2MjY1NzI3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZvdGVkX21lbWJlcnMgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA5MwogICAgLy8gYXBwcm92YWxzPWFyYzQuVUludDY0KHNlbGYuYXBwcm92YWxzLnZhbHVlKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAweDYxNzA3MDcyNmY3NjYxNmM3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFwcHJvdmFscyBleGlzdHMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMDk0CiAgICAvLyByZWplY3Rpb25zPWFyYzQuVUludDY0KHNlbGYucmVqZWN0aW9ucy52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTEgLy8gMHg3MjY1NmE2NTYzNzQ2OTZmNmU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJlamVjdGlvbnMgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA5NQogICAgLy8gbnVsbHM9YXJjNC5VSW50NjQoc2VsZi5udWxscy52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTQgLy8gMHg2ZTc1NmM2YzczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubnVsbHMgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA3NS0xMDk2CiAgICAvLyByZXR1cm4gdHlwLlByb3Bvc2FsVHlwZWRHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBwcm9wb3Nlcj1hcmM0LkFkZHJlc3Moc2VsZi5wcm9wb3Nlci52YWx1ZSksCiAgICAvLyAgICAgcmVnaXN0cnlfYXBwX2lkPWFyYzQuVUludDY0KHNlbGYucmVnaXN0cnlfYXBwX2lkLnZhbHVlKSwKICAgIC8vICAgICB0aXRsZT1hcmM0LlN0cmluZyhzZWxmLnRpdGxlLnZhbHVlKSwKICAgIC8vICAgICBvcGVuX3RzPWFyYzQuVUludDY0KHNlbGYub3Blbl90cy52YWx1ZSksCiAgICAvLyAgICAgc3VibWlzc2lvbl90cz1hcmM0LlVJbnQ2NChzZWxmLnN1Ym1pc3Npb25fdHMudmFsdWUpLAogICAgLy8gICAgIHZvdGVfb3Blbl90cz1hcmM0LlVJbnQ2NChzZWxmLnZvdGVfb3Blbl90cy52YWx1ZSksCiAgICAvLyAgICAgc3RhdHVzPWFyYzQuVUludDY0KHNlbGYuc3RhdHVzLnZhbHVlKSwKICAgIC8vICAgICBmaW5hbGl6ZWQ9YXJjNC5Cb29sKHNlbGYuZmluYWxpemVkLnZhbHVlKSwKICAgIC8vICAgICBmdW5kaW5nX2NhdGVnb3J5PWFyYzQuVUludDY0KHNlbGYuZnVuZGluZ19jYXRlZ29yeS52YWx1ZSksCiAgICAvLyAgICAgZm9jdXM9YXJjNC5VSW50OChzZWxmLmZvY3VzLnZhbHVlKSwKICAgIC8vICAgICBmdW5kaW5nX3R5cGU9YXJjNC5VSW50NjQoc2VsZi5mdW5kaW5nX3R5cGUudmFsdWUpLAogICAgLy8gICAgIHJlcXVlc3RlZF9hbW91bnQ9YXJjNC5VSW50NjQoc2VsZi5yZXF1ZXN0ZWRfYW1vdW50LnZhbHVlKSwKICAgIC8vICAgICBsb2NrZWRfYW1vdW50PWFyYzQuVUludDY0KHNlbGYubG9ja2VkX2Ftb3VudC52YWx1ZSksCiAgICAvLyAgICAgY29tbWl0dGVlX2lkPXNlbGYuY29tbWl0dGVlX2lkLnZhbHVlLmNvcHkoKSwKICAgIC8vICAgICBjb21taXR0ZWVfbWVtYmVycz1hcmM0LlVJbnQ2NChzZWxmLmNvbW1pdHRlZV9tZW1iZXJzLnZhbHVlKSwKICAgIC8vICAgICBjb21taXR0ZWVfdm90ZXM9YXJjNC5VSW50NjQoc2VsZi5jb21taXR0ZWVfdm90ZXMudmFsdWUpLAogICAgLy8gICAgIHZvdGVkX21lbWJlcnM9YXJjNC5VSW50NjQoc2VsZi52b3RlZF9tZW1iZXJzLnZhbHVlKSwKICAgIC8vICAgICBhcHByb3ZhbHM9YXJjNC5VSW50NjQoc2VsZi5hcHByb3ZhbHMudmFsdWUpLAogICAgLy8gICAgIHJlamVjdGlvbnM9YXJjNC5VSW50NjQoc2VsZi5yZWplY3Rpb25zLnZhbHVlKSwKICAgIC8vICAgICBudWxscz1hcmM0LlVJbnQ2NChzZWxmLm51bGxzLnZhbHVlKSwKICAgIC8vICkKICAgIHVuY292ZXIgMTkKICAgIHVuY292ZXIgMTkKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MDBiYwogICAgY29uY2F0CiAgICB1bmNvdmVyIDE3CiAgICBjb25jYXQKICAgIHVuY292ZXIgMTYKICAgIGNvbmNhdAogICAgdW5jb3ZlciAxNQogICAgY29uY2F0CiAgICB1bmNvdmVyIDE0CiAgICBjb25jYXQKICAgIHVuY292ZXIgMTMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAxMgogICAgY29uY2F0CiAgICB1bmNvdmVyIDExCiAgICBjb25jYXQKICAgIHVuY292ZXIgMTAKICAgIGNvbmNhdAogICAgdW5jb3ZlciA5CiAgICBjb25jYXQKICAgIHVuY292ZXIgOAogICAgY29uY2F0CiAgICB1bmNvdmVyIDcKICAgIGNvbmNhdAogICAgdW5jb3ZlciA2CiAgICBjb25jYXQKICAgIHVuY292ZXIgNQogICAgY29uY2F0CiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwNjcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWMgMTIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuZ2V0X3ZvdGVyX2JveFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldF92b3Rlcl9ib3g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTA5OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMTEwCiAgICAvLyBleGlzdHMgPSB2b3Rlcl9hZGRyZXNzLm5hdGl2ZSBpbiBzZWxmLnZvdGVycwogICAgYnl0ZWMgMTkgLy8gIlYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjExMTEKICAgIC8vIGlmIGV4aXN0czoKICAgIGJ6IGdldF92b3Rlcl9ib3hfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxMTEyCiAgICAvLyB2b3RlcyA9IHNlbGYudm90ZXJzW3ZvdGVyX2FkZHJlc3MubmF0aXZlXQogICAgZGlnIDEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZvdGVycyBlbnRyeSBleGlzdHMKICAgIGJ0b2kKCmdldF92b3Rlcl9ib3hfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjExMTYKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NCh2b3RlcyksIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjEwOTgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWMgMTggLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIGRpZyAzCiAgICBzZXRiaXQKICAgIGNvbmNhdAogICAgYnl0ZWMgMTIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmdldF92b3Rlcl9ib3hfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTExNAogICAgLy8gdm90ZXMgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBiIGdldF92b3Rlcl9ib3hfYWZ0ZXJfaWZfZWxzZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmlzX3ZvdGluZ19vcGVuKCkgLT4gdWludDY0LCBieXRlczoKaXNfdm90aW5nX29wZW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTQ4LTE0OQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBpc192b3Rpbmdfb3BlbihzZWxmKSAtPiB0dXBsZVtib29sLCB0eXAuRXJyb3JdOgogICAgcHJvdG8gMCAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTUwCiAgICAvLyB2b3RpbmdfZHVyYXRpb24gPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCAtIHNlbGYudm90ZV9vcGVuX3RzLnZhbHVlCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTYgLy8gMHg3NjZmNzQ2NTVmNmY3MDY1NmU2OTZlNjc1Zjc0Njk2ZDY1NzM3NDYxNmQ3MAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZvdGVfb3Blbl90cyBleGlzdHMKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxNTIKICAgIC8vIHNlbGYuZnVuZGluZ19jYXRlZ29yeS52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gMHg2Njc1NmU2NDY5NmU2NzVmNjM2MTc0NjU2NzZmNzI3OQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTUxLTE1MwogICAgLy8gbWF4aW11bV92b3RpbmdfZHVyYXRpb24sIGVycm9yID0gc2VsZi5nZXRfdm90aW5nX2R1cmF0aW9uKAogICAgLy8gICAgIHNlbGYuZnVuZGluZ19jYXRlZ29yeS52YWx1ZQogICAgLy8gKQogICAgY2FsbHN1YiBnZXRfdm90aW5nX2R1cmF0aW9uCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE1NAogICAgLy8gaWYgZXJyb3IgIT0gdHlwLkVycm9yKCIiKToKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICAhPQogICAgYnogaXNfdm90aW5nX29wZW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MTU1CiAgICAvLyByZXR1cm4gRmFsc2UsIGVycm9yCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmlzX3ZvdGluZ19vcGVuX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxNTcKICAgIC8vIHJldHVybiB2b3RpbmdfZHVyYXRpb24gPD0gbWF4aW11bV92b3RpbmdfZHVyYXRpb24sIHR5cC5FcnJvcigiIikKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMgogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToxNTQKICAgIC8vIGlmIGVycm9yICE9IHR5cC5FcnJvcigiIik6CiAgICBieXRlY18wIC8vIDB4MDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjE1NwogICAgLy8gcmV0dXJuIHZvdGluZ19kdXJhdGlvbiA8PSBtYXhpbXVtX3ZvdGluZ19kdXJhdGlvbiwgdHlwLkVycm9yKCIiKQogICAgZnJhbWVfYnVyeSAxCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5pc19wbGViaXNjaXRlKCkgLT4gdWludDY0Ogppc19wbGViaXNjaXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjIzNAogICAgLy8gcmV0dXJuIHNlbGYudm90ZWRfbWVtYmVycy52YWx1ZSA9PSBzZWxmLmNvbW1pdHRlZV9tZW1iZXJzLnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAweDc2NmY3NDY1NjQ1ZjZkNjU2ZDYyNjU3MjczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudm90ZWRfbWVtYmVycyBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vIDB4NjM2ZjZkNmQ2OTc0NzQ2NTY1NWY2ZDY1NmQ2MjY1NzI3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbW1pdHRlZV9tZW1iZXJzIGV4aXN0cwogICAgPT0KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5nZXRfdm90aW5nX2R1cmF0aW9uKGNhdGVnb3J5OiB1aW50NjQpIC0+IHVpbnQ2NCwgYnl0ZXM6CmdldF92b3RpbmdfZHVyYXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Mjc3LTI3OAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBnZXRfdm90aW5nX2R1cmF0aW9uKHNlbGYsIGNhdGVnb3J5OiBVSW50NjQpIC0+IHR1cGxlW1VJbnQ2NCwgdHlwLkVycm9yXToKICAgIHByb3RvIDEgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI3OQogICAgLy8gaWYgY2F0ZWdvcnkgPT0gZW5tLkZVTkRJTkdfQ0FURUdPUllfU01BTEw6CiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMyAvLyAxMAogICAgPT0KICAgIGJ6IGdldF92b3RpbmdfZHVyYXRpb25fZWxzZV9ib2R5QDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyODEKICAgIC8vIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX1ZPVElOR19EVVJBVElPTl9TTUFMTCkKICAgIHB1c2hieXRlcyAweDc2NmY3NDY5NmU2NzVmNjQ3NTcyNjE3NDY5NmY2ZTVmNzM2ZDYxNmM2YwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI4MC0yODIKICAgIC8vIHJldHVybiBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX1ZPVElOR19EVVJBVElPTl9TTUFMTCkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIHJldHN1YgoKZ2V0X3ZvdGluZ19kdXJhdGlvbl9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyODMKICAgIC8vIGVsaWYgY2F0ZWdvcnkgPT0gZW5tLkZVTkRJTkdfQ0FURUdPUllfTUVESVVNOgogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDIwIC8vIDIwCiAgICA9PQogICAgYnogZ2V0X3ZvdGluZ19kdXJhdGlvbl9lbHNlX2JvZHlANAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI4NQogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfVk9USU5HX0RVUkFUSU9OX01FRElVTSkKICAgIHB1c2hieXRlcyAweDc2NmY3NDY5NmU2NzVmNjQ3NTcyNjE3NDY5NmY2ZTVmNmQ2NTY0Njk3NTZkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Mjg0LTI4NgogICAgLy8gcmV0dXJuIHNlbGYuZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcoCiAgICAvLyAgICAgQnl0ZXMocmVnX2NmZy5HU19LRVlfVk9USU5HX0RVUkFUSU9OX01FRElVTSkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIHJldHN1YgoKZ2V0X3ZvdGluZ19kdXJhdGlvbl9lbHNlX2JvZHlANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyODkKICAgIC8vIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX1ZPVElOR19EVVJBVElPTl9MQVJHRSkKICAgIHB1c2hieXRlcyAweDc2NmY3NDY5NmU2NzVmNjQ3NTcyNjE3NDY5NmY2ZTVmNmM2MTcyNjc2NQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI4OC0yOTAKICAgIC8vIHJldHVybiBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX1ZPVElOR19EVVJBVElPTl9MQVJHRSkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5hc3NlcnRfZHJhZnRfYW5kX3Byb3Bvc2VyKCkgLT4gdm9pZDoKYXNzZXJ0X2RyYWZ0X2FuZF9wcm9wb3NlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNTkKICAgIC8vIGFzc2VydCBzZWxmLmlzX3Byb3Bvc2VyKCksIGVyci5VTkFVVEhPUklaRUQKICAgIGNhbGxzdWIgaXNfcHJvcG9zZXIKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNjEKICAgIC8vIHNlbGYuc3RhdHVzLnZhbHVlID09IGVubS5TVEFUVVNfRFJBRlQgYW5kIG5vdCBzZWxmLmZpbmFsaXplZC52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE3NDc1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0dXMgZXhpc3RzCiAgICBpbnRjXzMgLy8gMTAKICAgID09CiAgICBieiBhc3NlcnRfZHJhZnRfYW5kX3Byb3Bvc2VyX2Jvb2xfZmFsc2VAMwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gMHg2NjY5NmU2MTZjNjk3YTY1NjQKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5maW5hbGl6ZWQgZXhpc3RzCiAgICBibnogYXNzZXJ0X2RyYWZ0X2FuZF9wcm9wb3Nlcl9ib29sX2ZhbHNlQDMKICAgIGludGNfMSAvLyAxCgphc3NlcnRfZHJhZnRfYW5kX3Byb3Bvc2VyX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozNjAtMzYyCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuc3RhdHVzLnZhbHVlID09IGVubS5TVEFUVVNfRFJBRlQgYW5kIG5vdCBzZWxmLmZpbmFsaXplZC52YWx1ZQogICAgLy8gKSwgZXJyLldST05HX1BST1BPU0FMX1NUQVRVUwogICAgYXNzZXJ0IC8vIFdyb25nIFByb3Bvc2FsIFN0YXR1cyBvciBmaW5hbGl6ZWQKICAgIHJldHN1YgoKYXNzZXJ0X2RyYWZ0X2FuZF9wcm9wb3Nlcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhc3NlcnRfZHJhZnRfYW5kX3Byb3Bvc2VyX2Jvb2xfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5nZXRfZXhwZWN0ZWRfbG9ja2VkX2Ftb3VudChyZXF1ZXN0ZWRfYW1vdW50OiB1aW50NjQpIC0+IHVpbnQ2NDoKZ2V0X2V4cGVjdGVkX2xvY2tlZF9hbW91bnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDM1LTQzNgogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBnZXRfZXhwZWN0ZWRfbG9ja2VkX2Ftb3VudChzZWxmLCByZXF1ZXN0ZWRfYW1vdW50OiBVSW50NjQpIC0+IFVJbnQ2NDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQzOAogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfUFJPUE9TQUxfQ09NTUlUTUVOVF9CUFMpCiAgICBwdXNoYnl0ZXMgMHg3MDcyNmY3MDZmNzM2MTZjNWY2MzZmNmQ2ZDY5NzQ2ZDY1NmU3NDVmNjI3MDczCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDM3LTQzOQogICAgLy8gcHJvcG9zYWxfY29tbWl0bWVudF9icHMsIGVycm9yID0gc2VsZi5nZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZygKICAgIC8vICAgICBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9QUk9QT1NBTF9DT01NSVRNRU5UX0JQUykKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0NDAKICAgIC8vIGFzc2VydCBlcnJvciA9PSB0eXAuRXJyb3IoIiIpLCBlcnIuTUlTU0lOR19DT05GSUcKICAgIGJ5dGVjXzAgLy8gMHgwMDAwCiAgICA9PQogICAgYXNzZXJ0IC8vIE1pc3NpbmcgQ29uZmlnCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDMzCiAgICAvLyByZXR1cm4gYW1vdW50ICogZnJhY3Rpb25faW5fYnBzIC8vIGNvbnN0LkJQUwogICAgZnJhbWVfZGlnIC0xCiAgICAqCiAgICBpbnRjIDQgLy8gMTAwMDAKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0NDEtNDQ0CiAgICAvLyByZXR1cm4gc2VsZi5yZWxhdGl2ZV90b19hYnNvbHV0ZV9hbW91bnQoCiAgICAvLyAgICAgcmVxdWVzdGVkX2Ftb3VudCwKICAgIC8vICAgICBwcm9wb3NhbF9jb21taXRtZW50X2JwcywKICAgIC8vICkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5nZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZyhnbG9iYWxfc3RhdGVfa2V5OiBieXRlcykgLT4gdWludDY0LCBieXRlczoKZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDc3LTQ4MAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBnZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZygKICAgIC8vICAgICBzZWxmLCBnbG9iYWxfc3RhdGVfa2V5OiBCeXRlcwogICAgLy8gKSAtPiB0dXBsZVtVSW50NjQsIHR5cC5FcnJvcl06CiAgICBwcm90byAxIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0ODIKICAgIC8vIHNlbGYucmVnaXN0cnlfYXBwX2lkLnZhbHVlLCBnbG9iYWxfc3RhdGVfa2V5CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAweDcyNjU2NzY5NzM3NDcyNzk1ZjYxNzA3MDVmNjk2NAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJlZ2lzdHJ5X2FwcF9pZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0ODEtNDgzCiAgICAvLyB2YWx1ZSwgZXhpc3RzID0gQXBwR2xvYmFsLmdldF9leF91aW50NjQoCiAgICAvLyAgICAgc2VsZi5yZWdpc3RyeV9hcHBfaWQudmFsdWUsIGdsb2JhbF9zdGF0ZV9rZXkKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0ODQKICAgIC8vIGVycm9yID0gdHlwLkVycm9yKCIiKQogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0ODUKICAgIC8vIGlmIG5vdCBleGlzdHM6CiAgICBibnogZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWdfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDg2CiAgICAvLyBlcnJvciA9IHR5cC5FcnJvcihlcnIuQVJDXzY1X1BSRUZJWCArIGVyci5NSVNTSU5HX0NPTkZJRykKICAgIHB1c2hieXRlcyAweDAwMTI0NTUyNTIzYTRkNjk3MzczNjk2ZTY3MjA0MzZmNmU2NjY5NjcKICAgIGZyYW1lX2J1cnkgMQoKZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWdfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ4NwogICAgLy8gcmV0dXJuIHZhbHVlLCBlcnJvcgogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2RpZyAxCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZyhnbG9iYWxfc3RhdGVfa2V5OiBieXRlcykgLT4gYnl0ZXM6CmdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0ODktNDkwCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZyhzZWxmLCBnbG9iYWxfc3RhdGVfa2V5OiBCeXRlcykgLT4gQnl0ZXM6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0OTIKICAgIC8vIHNlbGYucmVnaXN0cnlfYXBwX2lkLnZhbHVlLCBnbG9iYWxfc3RhdGVfa2V5CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAweDcyNjU2NzY5NzM3NDcyNzk1ZjYxNzA3MDVmNjk2NAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJlZ2lzdHJ5X2FwcF9pZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0OTEtNDkzCiAgICAvLyB2YWx1ZSwgZXhpc3RzID0gQXBwR2xvYmFsLmdldF9leF9ieXRlcygKICAgIC8vICAgICBzZWxmLnJlZ2lzdHJ5X2FwcF9pZC52YWx1ZSwgZ2xvYmFsX3N0YXRlX2tleQogICAgLy8gKQogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjQ5NAogICAgLy8gYXNzZXJ0IGV4aXN0cywgZXJyLk1JU1NJTkdfQ09ORklHCiAgICBhc3NlcnQgLy8gTWlzc2luZyBDb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo0OTUKICAgIC8vIHJldHVybiB2YWx1ZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmNoZWNrX3JlZ2lzdHJ5X25vdF9wYXVzZWQoKSAtPiB2b2lkOgpjaGVja19yZWdpc3RyeV9ub3RfcGF1c2VkOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUwMAogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfUEFVU0VEX1JFR0lTVFJZKQogICAgcHVzaGJ5dGVzIDB4NzA2MTc1NzM2NTY0NWY3MjY1Njc2OTczNzQ3Mjc5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDk5LTUwMQogICAgLy8gcmVnaXN0cnlfcGF1c2VkLCBlcnJvciA9IHNlbGYuZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcoCiAgICAvLyAgICAgQnl0ZXMocmVnX2NmZy5HU19LRVlfUEFVU0VEX1JFR0lTVFJZKQogICAgLy8gKQogICAgY2FsbHN1YiBnZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUwMwogICAgLy8gYXNzZXJ0IGVycm9yID09IHR5cC5FcnJvcigiIiksIGVyci5NSVNTSU5HX0NPTkZJRwogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgID09CiAgICBhc3NlcnQgLy8gTWlzc2luZyBDb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1MDQKICAgIC8vIGFzc2VydCBub3QgcmVnaXN0cnlfcGF1c2VkLCBlcnIuUEFVU0VEX1JFR0lTVFJZCiAgICAhCiAgICBhc3NlcnQgLy8gUmVnaXN0cnkncyBub24tYWRtaW4gbWV0aG9kcyBhcmUgcGF1c2VkCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwuaXNfcHJvcG9zZXIoKSAtPiB1aW50NjQ6CmlzX3Byb3Bvc2VyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUxMgogICAgLy8gcmV0dXJuIFR4bi5zZW5kZXIgPT0gc2VsZi5wcm9wb3Nlci52YWx1ZQogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gMHg3MDcyNmY3MDZmNzM2NTcyCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucHJvcG9zZXIgZXhpc3RzCiAgICA9PQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmlzX3hnb3ZfZGFlbW9uKCkgLT4gdWludDY0Ogppc194Z292X2RhZW1vbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1MjIKICAgIC8vIHJldHVybiBUeG4uc2VuZGVyID09IEFjY291bnQoCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTIzCiAgICAvLyBzZWxmLmdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZyhCeXRlcyhyZWdfY2ZnLkdTX0tFWV9YR09WX0RBRU1PTikpCiAgICBieXRlYyAyOSAvLyAweDc4Njc2Zjc2NWY2NDYxNjU2ZDZmNmUKICAgIGNhbGxzdWIgZ2V0X2J5dGVzX2Zyb21fcmVnaXN0cnlfY29uZmlnCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTIyLTUyNAogICAgLy8gcmV0dXJuIFR4bi5zZW5kZXIgPT0gQWNjb3VudCgKICAgIC8vICAgICBzZWxmLmdldF9ieXRlc19mcm9tX3JlZ2lzdHJ5X2NvbmZpZyhCeXRlcyhyZWdfY2ZnLkdTX0tFWV9YR09WX0RBRU1PTikpCiAgICAvLyApCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIEFkZHJlc3MgbGVuZ3RoIGlzIDMyIGJ5dGVzCiAgICA9PQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmlzX3JlZ2lzdHJ5X2NhbGwoKSAtPiB1aW50NjQ6CmlzX3JlZ2lzdHJ5X2NhbGw6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTI4CiAgICAvLyByZXR1cm4gR2xvYmFsLmNhbGxlcl9hcHBsaWNhdGlvbl9pZCA9PSBzZWxmLnJlZ2lzdHJ5X2FwcF9pZC52YWx1ZQogICAgZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vIDB4NzI2NTY3Njk3Mzc0NzI3OTVmNjE3MDcwNWY2OTY0CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucmVnaXN0cnlfYXBwX2lkIGV4aXN0cwogICAgPT0KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5wYXkocmVjZWl2ZXI6IGJ5dGVzLCBhbW91bnQ6IHVpbnQ2NCkgLT4gdm9pZDoKcGF5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUzMC01MzEKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgcGF5KHNlbGYsIHJlY2VpdmVyOiBBY2NvdW50LCBhbW91bnQ6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUzMi01MzYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1yZWNlaXZlciwKICAgIC8vICAgICBhbW91bnQ9YW1vdW50LAogICAgLy8gICAgIGZlZT1VSW50NjQoMCksICAjIGVuZm9yY2VzIHRoZSBzZW5kZXIgdG8gcGF5IHRoZSBmZWUKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUzMgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjUzNQogICAgLy8gZmVlPVVJbnQ2NCgwKSwgICMgZW5mb3JjZXMgdGhlIHNlbmRlciB0byBwYXkgdGhlIGZlZQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTMyLTUzNgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXJlY2VpdmVyLAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgwKSwgICMgZW5mb3JjZXMgdGhlIHNlbmRlciB0byBwYXkgdGhlIGZlZQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC50cmFuc2Zlcl9sb2NrZWRfYW1vdW50KHJlY2VpdmVyOiBieXRlcykgLT4gdm9pZDoKdHJhbnNmZXJfbG9ja2VkX2Ftb3VudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1MzgtNTM5CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIHRyYW5zZmVyX2xvY2tlZF9hbW91bnQoc2VsZiwgcmVjZWl2ZXI6IEFjY291bnQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1NDAKICAgIC8vIHNlbGYucGF5KHJlY2VpdmVyLCBzZWxmLmxvY2tlZF9hbW91bnQudmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTcgLy8gMHg2YzZmNjM2YjY1NjQ1ZjYxNmQ2Zjc1NmU3NAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmxvY2tlZF9hbW91bnQgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIHN3YXAKICAgIGNhbGxzdWIgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTQxCiAgICAvLyBzZWxmLmxvY2tlZF9hbW91bnQudmFsdWUgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDE3IC8vIDB4NmM2ZjYzNmI2NTY0NWY2MTZkNmY3NTZlNzQKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnByb3Bvc2FsLmNvbnRyYWN0LlByb3Bvc2FsLmFzc2VydF9zYW1lX2FwcF9hbmRfbWV0aG9kKGdyb3VwX2luZGV4OiB1aW50NjQpIC0+IHZvaWQ6CmFzc2VydF9zYW1lX2FwcF9hbmRfbWV0aG9kOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU0My01NDQKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgYXNzZXJ0X3NhbWVfYXBwX2FuZF9tZXRob2Qoc2VsZiwgZ3JvdXBfaW5kZXg6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU0NgogICAgLy8gR1R4bi5hcHBsaWNhdGlvbl9pZChncm91cF9pbmRleCkgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQXBwbGljYXRpb25JRAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU0NS01NDcKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgR1R4bi5hcHBsaWNhdGlvbl9pZChncm91cF9pbmRleCkgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIC8vICksIGVyci5XUk9OR19BUFBfSUQKICAgIGFzc2VydCAvLyBXcm9uZyBBcHAgSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1NDgKICAgIC8vIGFzc2VydCBHVHhuLmFwcGxpY2F0aW9uX2FyZ3MoZ3JvdXBfaW5kZXgsIDApID09IFR4bi5hcHBsaWNhdGlvbl9hcmdzKAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhuc2EgQXBwbGljYXRpb25BcmdzIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1NDgtNTUwCiAgICAvLyBhc3NlcnQgR1R4bi5hcHBsaWNhdGlvbl9hcmdzKGdyb3VwX2luZGV4LCAwKSA9PSBUeG4uYXBwbGljYXRpb25fYXJncygKICAgIC8vICAgICAwCiAgICAvLyApLCBlcnIuV1JPTkdfTUVUSE9EX0NBTEwKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgID09CiAgICBhc3NlcnQgLy8gV3JvbmcgTWV0aG9kIENhbGwKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5xdW9ydW1fdm90ZXJzX3RocmVzaG9sZCgpIC0+IHVpbnQ2NDoKcXVvcnVtX3ZvdGVyc190aHJlc2hvbGQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTUyLTU1MwogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBxdW9ydW1fdm90ZXJzX3RocmVzaG9sZChzZWxmKSAtPiBVSW50NjQ6CiAgICBwcm90byAwIDEKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTU0LTU1NgogICAgLy8gIyBBIGNhdGVnb3J5IGRlcGVuZGVudCBxdW9ydW0gb2YgYWxsIHhHb3YgVm90aW5nIENvbW1pdHRlZSAoMSB4R292LCAxIHZvdGUpIGlzIHJlYWNoZWQuCiAgICAvLyAjIE51bGwgdm90ZXMgYWZmZWN0IHRoaXMgcXVvcnVtLgogICAgLy8gcXVvcnVtX2JwcyA9IHNlbGYuZ2V0X3F1b3J1bShzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkudmFsdWUpCiAgICBkdXAKICAgIGJ5dGVjXzIgLy8gMHg2Njc1NmU2NDY5NmU2NzVmNjM2MTc0NjU2NzZmNzI3OQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5mdW5kaW5nX2NhdGVnb3J5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI5NAogICAgLy8gaWYgY2F0ZWdvcnkgPT0gZW5tLkZVTkRJTkdfQ0FURUdPUllfU01BTEw6CiAgICBpbnRjXzMgLy8gMTAKICAgID09CiAgICBieiBxdW9ydW1fdm90ZXJzX3RocmVzaG9sZF9lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjI5NgogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfUVVPUlVNX1NNQUxMKQogICAgcHVzaGJ5dGVzIDB4NzE3NTZmNzI3NTZkNWY3MzZkNjE2YzZjCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Mjk1LTI5NwogICAgLy8gdmFsdWUsIGVycm9yID0gc2VsZi5nZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZygKICAgIC8vICAgICBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9RVU9SVU1fU01BTEwpCiAgICAvLyApCiAgICBjYWxsc3ViIGdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnCiAgICBmcmFtZV9idXJ5IDAKCnF1b3J1bV92b3RlcnNfdGhyZXNob2xkX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMDYKICAgIC8vIGFzc2VydCBlcnJvciA9PSB0eXAuRXJyb3IoIiIpLCBlcnIuTUlTU0lOR19DT05GSUcKICAgIGZyYW1lX2RpZyAwCiAgICBieXRlY18wIC8vIDB4MDAwMAogICAgPT0KICAgIGFzc2VydCAvLyBNaXNzaW5nIENvbmZpZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU1OAogICAgLy8gc2VsZi5jb21taXR0ZWVfbWVtYmVycy52YWx1ZSwgcXVvcnVtX2JwcwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDggLy8gMHg2MzZmNmQ2ZDY5NzQ3NDY1NjU1ZjZkNjU2ZDYyNjU3MjczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY29tbWl0dGVlX21lbWJlcnMgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDMzCiAgICAvLyByZXR1cm4gYW1vdW50ICogZnJhY3Rpb25faW5fYnBzIC8vIGNvbnN0LkJQUwogICAgKgogICAgaW50YyA0IC8vIDEwMDAwCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTU3LTU1OQogICAgLy8gcmV0dXJuIHNlbGYucmVsYXRpdmVfdG9fYWJzb2x1dGVfYW1vdW50KAogICAgLy8gICAgIHNlbGYuY29tbWl0dGVlX21lbWJlcnMudmFsdWUsIHF1b3J1bV9icHMKICAgIC8vICkKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpxdW9ydW1fdm90ZXJzX3RocmVzaG9sZF9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weToyOTgKICAgIC8vIGVsaWYgY2F0ZWdvcnkgPT0gZW5tLkZVTkRJTkdfQ0FURUdPUllfTUVESVVNOgogICAgZnJhbWVfZGlnIDEKICAgIHB1c2hpbnQgMjAgLy8gMjAKICAgID09CiAgICBieiBxdW9ydW1fdm90ZXJzX3RocmVzaG9sZF9lbHNlX2JvZHlANQogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjMwMAogICAgLy8gQnl0ZXMocmVnX2NmZy5HU19LRVlfUVVPUlVNX01FRElVTSkKICAgIHB1c2hieXRlcyAweDcxNzU2ZjcyNzU2ZDVmNmQ2NTY0Njk3NTZkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6Mjk5LTMwMQogICAgLy8gdmFsdWUsIGVycm9yID0gc2VsZi5nZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZygKICAgIC8vICAgICBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9RVU9SVU1fTUVESVVNKQogICAgLy8gKQogICAgY2FsbHN1YiBnZXRfdWludF9mcm9tX3JlZ2lzdHJ5X2NvbmZpZwogICAgZnJhbWVfYnVyeSAwCiAgICBiIHF1b3J1bV92b3RlcnNfdGhyZXNob2xkX2FmdGVyX2lmX2Vsc2VANwoKcXVvcnVtX3ZvdGVyc190aHJlc2hvbGRfZWxzZV9ib2R5QDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzA0CiAgICAvLyBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9RVU9SVU1fTEFSR0UpCiAgICBwdXNoYnl0ZXMgMHg3MTc1NmY3Mjc1NmQ1ZjZjNjE3MjY3NjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMDMtMzA1CiAgICAvLyB2YWx1ZSwgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX1FVT1JVTV9MQVJHRSkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIGZyYW1lX2J1cnkgMAogICAgYiBxdW9ydW1fdm90ZXJzX3RocmVzaG9sZF9hZnRlcl9pZl9lbHNlQDcKCgovLyBzbWFydF9jb250cmFjdHMucHJvcG9zYWwuY29udHJhY3QuUHJvcG9zYWwud2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzX3RocmVzaG9sZCgpIC0+IHVpbnQ2NDoKd2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzX3RocmVzaG9sZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1NjEtNTYyCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIHdlaWdodGVkX3F1b3J1bV92b3Rlc190aHJlc2hvbGQoc2VsZikgLT4gVUludDY0OgogICAgcHJvdG8gMCAxCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU2My01NjUKICAgIC8vICMgQSBjYXRlZ29yeSBkZXBlbmRlbnQgd2VpZ2h0ZWQgcXVvcnVtIG9mIGFsbCB4R292IFZvdGluZyBDb21taXR0ZWUgdm90aW5nIHBvd2VyICgxIHZvdGUpIGlzIHJlYWNoZWQuCiAgICAvLyAjIE51bGwgdm90ZXMgYWZmZWN0IHRoaXMgcXVvcnVtLgogICAgLy8gd2VpZ2h0ZWRfcXVvcnVtX2JwcyA9IHNlbGYuZ2V0X3dlaWdodGVkX3F1b3J1bShzZWxmLmZ1bmRpbmdfY2F0ZWdvcnkudmFsdWUpCiAgICBkdXAKICAgIGJ5dGVjXzIgLy8gMHg2Njc1NmU2NDY5NmU2NzVmNjM2MTc0NjU2NzZmNzI3OQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5mdW5kaW5nX2NhdGVnb3J5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjMxMQogICAgLy8gaWYgY2F0ZWdvcnkgPT0gZW5tLkZVTkRJTkdfQ0FURUdPUllfU01BTEw6CiAgICBpbnRjXzMgLy8gMTAKICAgID09CiAgICBieiB3ZWlnaHRlZF9xdW9ydW1fdm90ZXNfdGhyZXNob2xkX2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzEzCiAgICAvLyBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9XRUlHSFRFRF9RVU9SVU1fU01BTEwpCiAgICBwdXNoYnl0ZXMgMHg3NzY1Njk2NzY4NzQ2NTY0NWY3MTc1NmY3Mjc1NmQ1ZjczNmQ2MTZjNmMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMTItMzE0CiAgICAvLyB2YWx1ZSwgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX1dFSUdIVEVEX1FVT1JVTV9TTUFMTCkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIGZyYW1lX2J1cnkgMAoKd2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzX3RocmVzaG9sZF9hZnRlcl9pZl9lbHNlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzIzCiAgICAvLyBhc3NlcnQgZXJyb3IgPT0gdHlwLkVycm9yKCIiKSwgZXJyLk1JU1NJTkdfQ09ORklHCiAgICBmcmFtZV9kaWcgMAogICAgYnl0ZWNfMCAvLyAweDAwMDAKICAgID09CiAgICBhc3NlcnQgLy8gTWlzc2luZyBDb25maWcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1NjcKICAgIC8vIHNlbGYuY29tbWl0dGVlX3ZvdGVzLnZhbHVlLCB3ZWlnaHRlZF9xdW9ydW1fYnBzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTMgLy8gMHg2MzZmNmQ2ZDY5NzQ3NDY1NjU1Zjc2NmY3NDY1NzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb21taXR0ZWVfdm90ZXMgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NDMzCiAgICAvLyByZXR1cm4gYW1vdW50ICogZnJhY3Rpb25faW5fYnBzIC8vIGNvbnN0LkJQUwogICAgKgogICAgaW50YyA0IC8vIDEwMDAwCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTY2LTU2OAogICAgLy8gcmV0dXJuIHNlbGYucmVsYXRpdmVfdG9fYWJzb2x1dGVfYW1vdW50KAogICAgLy8gICAgIHNlbGYuY29tbWl0dGVlX3ZvdGVzLnZhbHVlLCB3ZWlnaHRlZF9xdW9ydW1fYnBzCiAgICAvLyApCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKd2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzX3RocmVzaG9sZF9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMTUKICAgIC8vIGVsaWYgY2F0ZWdvcnkgPT0gZW5tLkZVTkRJTkdfQ0FURUdPUllfTUVESVVNOgogICAgZnJhbWVfZGlnIDEKICAgIHB1c2hpbnQgMjAgLy8gMjAKICAgID09CiAgICBieiB3ZWlnaHRlZF9xdW9ydW1fdm90ZXNfdGhyZXNob2xkX2Vsc2VfYm9keUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzE3CiAgICAvLyBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9XRUlHSFRFRF9RVU9SVU1fTUVESVVNKQogICAgcHVzaGJ5dGVzIDB4Nzc2NTY5Njc2ODc0NjU2NDVmNzE3NTZmNzI3NTZkNWY2ZDY1NjQ2OTc1NmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMTYtMzE4CiAgICAvLyB2YWx1ZSwgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX1dFSUdIVEVEX1FVT1JVTV9NRURJVU0pCiAgICAvLyApCiAgICBjYWxsc3ViIGdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnCiAgICBmcmFtZV9idXJ5IDAKICAgIGIgd2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzX3RocmVzaG9sZF9hZnRlcl9pZl9lbHNlQDcKCndlaWdodGVkX3F1b3J1bV92b3Rlc190aHJlc2hvbGRfZWxzZV9ib2R5QDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6MzIxCiAgICAvLyBCeXRlcyhyZWdfY2ZnLkdTX0tFWV9XRUlHSFRFRF9RVU9SVU1fTEFSR0UpCiAgICBwdXNoYnl0ZXMgMHg3NzY1Njk2NzY4NzQ2NTY0NWY3MTc1NmY3Mjc1NmQ1ZjZjNjE3MjY3NjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTozMjAtMzIyCiAgICAvLyB2YWx1ZSwgZXJyb3IgPSBzZWxmLmdldF91aW50X2Zyb21fcmVnaXN0cnlfY29uZmlnKAogICAgLy8gICAgIEJ5dGVzKHJlZ19jZmcuR1NfS0VZX1dFSUdIVEVEX1FVT1JVTV9MQVJHRSkKICAgIC8vICkKICAgIGNhbGxzdWIgZ2V0X3VpbnRfZnJvbV9yZWdpc3RyeV9jb25maWcKICAgIGZyYW1lX2J1cnkgMAogICAgYiB3ZWlnaHRlZF9xdW9ydW1fdm90ZXNfdGhyZXNob2xkX2FmdGVyX2lmX2Vsc2VANwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5pc19wcm9wb3NhbF9hcHByb3ZlZCgpIC0+IHVpbnQ2NDoKaXNfcHJvcG9zYWxfYXBwcm92ZWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTcwLTU3MQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBpc19wcm9wb3NhbF9hcHByb3ZlZChzZWxmKSAtPiBib29sOgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTcyCiAgICAvLyBtaW5pbXVtX3ZvdGVyc19yZXF1aXJlZCA9IHNlbGYucXVvcnVtX3ZvdGVyc190aHJlc2hvbGQoKQogICAgY2FsbHN1YiBxdW9ydW1fdm90ZXJzX3RocmVzaG9sZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU3MwogICAgLy8gbWluaW11bV92b3Rlc19yZXF1aXJlZCA9IHNlbGYud2VpZ2h0ZWRfcXVvcnVtX3ZvdGVzX3RocmVzaG9sZCgpCiAgICBjYWxsc3ViIHdlaWdodGVkX3F1b3J1bV92b3Rlc190aHJlc2hvbGQKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1NzQKICAgIC8vIHRvdGFsX3ZvdGVzID0gc2VsZi5hcHByb3ZhbHMudmFsdWUgKyBzZWxmLnJlamVjdGlvbnMudmFsdWUgKyBzZWxmLm51bGxzLnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTAgLy8gMHg2MTcwNzA3MjZmNzY2MTZjNzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hcHByb3ZhbHMgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTEgLy8gMHg3MjY1NmE2NTYzNzQ2OTZmNmU3MwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJlamVjdGlvbnMgZXhpc3RzCiAgICArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTQgLy8gMHg2ZTc1NmM2YzczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubnVsbHMgZXhpc3RzCiAgICArCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcHJvcG9zYWwvY29udHJhY3QucHk6NTc2CiAgICAvLyBzZWxmLnZvdGVkX21lbWJlcnMudmFsdWUgPj0gbWluaW11bV92b3RlcnNfcmVxdWlyZWQKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA5IC8vIDB4NzY2Zjc0NjU2NDVmNmQ2NTZkNjI2NTcyNzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52b3RlZF9tZW1iZXJzIGV4aXN0cwogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1NzYtNTgwCiAgICAvLyBzZWxmLnZvdGVkX21lbWJlcnMudmFsdWUgPj0gbWluaW11bV92b3RlcnNfcmVxdWlyZWQKICAgIC8vIGFuZCB0b3RhbF92b3RlcyA+PSBtaW5pbXVtX3ZvdGVzX3JlcXVpcmVkCiAgICAvLyAjIFRoZSByZWxhdGl2ZSBtYWpvcml0eSBvZiBBcHByb3ZlZCBvdmVyIFJlamVjdGVkIHZvdGVzIGlzIHJlYWNoZWQuCiAgICAvLyAjIE51bGwgdm90ZXMgZG8gbm90IGFmZmVjdCB0aGUgcmVsYXRpdmUgbWFqb3JpdHkuCiAgICAvLyBhbmQgc2VsZi5hcHByb3ZhbHMudmFsdWUgPiBzZWxmLnJlamVjdGlvbnMudmFsdWUKICAgIGJ6IGlzX3Byb3Bvc2FsX2FwcHJvdmVkX2Jvb2xfZmFsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU3NwogICAgLy8gYW5kIHRvdGFsX3ZvdGVzID49IG1pbmltdW1fdm90ZXNfcmVxdWlyZWQKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9kaWcgMAogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo1NzYtNTgwCiAgICAvLyBzZWxmLnZvdGVkX21lbWJlcnMudmFsdWUgPj0gbWluaW11bV92b3RlcnNfcmVxdWlyZWQKICAgIC8vIGFuZCB0b3RhbF92b3RlcyA+PSBtaW5pbXVtX3ZvdGVzX3JlcXVpcmVkCiAgICAvLyAjIFRoZSByZWxhdGl2ZSBtYWpvcml0eSBvZiBBcHByb3ZlZCBvdmVyIFJlamVjdGVkIHZvdGVzIGlzIHJlYWNoZWQuCiAgICAvLyAjIE51bGwgdm90ZXMgZG8gbm90IGFmZmVjdCB0aGUgcmVsYXRpdmUgbWFqb3JpdHkuCiAgICAvLyBhbmQgc2VsZi5hcHByb3ZhbHMudmFsdWUgPiBzZWxmLnJlamVjdGlvbnMudmFsdWUKICAgIGJ6IGlzX3Byb3Bvc2FsX2FwcHJvdmVkX2Jvb2xfZmFsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU3OC01ODAKICAgIC8vICMgVGhlIHJlbGF0aXZlIG1ham9yaXR5IG9mIEFwcHJvdmVkIG92ZXIgUmVqZWN0ZWQgdm90ZXMgaXMgcmVhY2hlZC4KICAgIC8vICMgTnVsbCB2b3RlcyBkbyBub3QgYWZmZWN0IHRoZSByZWxhdGl2ZSBtYWpvcml0eS4KICAgIC8vIGFuZCBzZWxmLmFwcHJvdmFscy52YWx1ZSA+IHNlbGYucmVqZWN0aW9ucy52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vIDB4NjE3MDcwNzI2Zjc2NjE2YzczCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXBwcm92YWxzIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDExIC8vIDB4NzI2NTZhNjU2Mzc0Njk2ZjZlNzMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yZWplY3Rpb25zIGV4aXN0cwogICAgPgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU3Ni01ODAKICAgIC8vIHNlbGYudm90ZWRfbWVtYmVycy52YWx1ZSA+PSBtaW5pbXVtX3ZvdGVyc19yZXF1aXJlZAogICAgLy8gYW5kIHRvdGFsX3ZvdGVzID49IG1pbmltdW1fdm90ZXNfcmVxdWlyZWQKICAgIC8vICMgVGhlIHJlbGF0aXZlIG1ham9yaXR5IG9mIEFwcHJvdmVkIG92ZXIgUmVqZWN0ZWQgdm90ZXMgaXMgcmVhY2hlZC4KICAgIC8vICMgTnVsbCB2b3RlcyBkbyBub3QgYWZmZWN0IHRoZSByZWxhdGl2ZSBtYWpvcml0eS4KICAgIC8vIGFuZCBzZWxmLmFwcHJvdmFscy52YWx1ZSA+IHNlbGYucmVqZWN0aW9ucy52YWx1ZQogICAgYnogaXNfcHJvcG9zYWxfYXBwcm92ZWRfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzEgLy8gMQoKaXNfcHJvcG9zYWxfYXBwcm92ZWRfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5OjU3NS01ODEKICAgIC8vIHJldHVybiAoCiAgICAvLyAgICAgc2VsZi52b3RlZF9tZW1iZXJzLnZhbHVlID49IG1pbmltdW1fdm90ZXJzX3JlcXVpcmVkCiAgICAvLyAgICAgYW5kIHRvdGFsX3ZvdGVzID49IG1pbmltdW1fdm90ZXNfcmVxdWlyZWQKICAgIC8vICAgICAjIFRoZSByZWxhdGl2ZSBtYWpvcml0eSBvZiBBcHByb3ZlZCBvdmVyIFJlamVjdGVkIHZvdGVzIGlzIHJlYWNoZWQuCiAgICAvLyAgICAgIyBOdWxsIHZvdGVzIGRvIG5vdCBhZmZlY3QgdGhlIHJlbGF0aXZlIG1ham9yaXR5LgogICAgLy8gICAgIGFuZCBzZWxmLmFwcHJvdmFscy52YWx1ZSA+IHNlbGYucmVqZWN0aW9ucy52YWx1ZQogICAgLy8gKQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmlzX3Byb3Bvc2FsX2FwcHJvdmVkX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIGlzX3Byb3Bvc2FsX2FwcHJvdmVkX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5wcm9wb3NhbC5jb250cmFjdC5Qcm9wb3NhbC5fdW5hc3NpZ25fdm90ZXIodm90ZXI6IGJ5dGVzLCB2b3RpbmdfcG93ZXI6IHVpbnQ2NCkgLT4gdm9pZDoKX3VuYXNzaWduX3ZvdGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc3Mi03NzMKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX3VuYXNzaWduX3ZvdGVyKHNlbGYsIHZvdGVyOiBBY2NvdW50LCB2b3RpbmdfcG93ZXI6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc3NAogICAgLy8gc2VsZi52b3RlcnNfY291bnQgLT0gMQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gInZvdGVyc19jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52b3RlcnNfY291bnQgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgYnl0ZWMgNiAvLyAidm90ZXJzX2NvdW50IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wcm9wb3NhbC9jb250cmFjdC5weTo3NzUKICAgIC8vIHNlbGYuYXNzaWduZWRfdm90ZXMgLT0gdm90aW5nX3Bvd2VyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTUgLy8gImFzc2lnbmVkX3ZvdGVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFzc2lnbmVkX3ZvdGVzIGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICAtCiAgICBieXRlYyAxNSAvLyAiYXNzaWduZWRfdm90ZXMiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Byb3Bvc2FsL2NvbnRyYWN0LnB5Ojc3NgogICAgLy8gZGVsIHNlbGYudm90ZXJzW3ZvdGVyXQogICAgYnl0ZWMgMTkgLy8gIlYiCiAgICBmcmFtZV9kaWcgLTIKICAgIGNvbmNhdAogICAgYm94X2RlbAogICAgcG9wCiAgICByZXRzdWIK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [1610, 2173, 2494, 3589], "errorMessage": "Address length is 32 bytes"}, {"pc": [1335], "errorMessage": "Empty payload"}, {"pc": [1815], "errorMessage": "Invalid Voting Power"}, {"pc": [1100], "errorMessage": "Locked amount is incorrect"}, {"pc": [1027, 1061, 1139, 1177, 1520, 1558, 1600, 2385, 3473, 3541, 3565, 3702, 3817], "errorMessage": "Missing Config"}, {"pc": [1564], "errorMessage": "Missing Metadata"}, {"pc": [655], "errorMessage": "OnCompletion must be DeleteApplication && can only call when not creating"}, {"pc": [519], "errorMessage": "OnCompletion must be NoOp"}, {"pc": [3567], "errorMessage": "Registry's non-admin methods are paused"}, {"pc": [1068], "errorMessage": "Requested amount is less than the minimum requested amount"}, {"pc": [1073], "errorMessage": "Requested amount is more than the maximum requested amount"}, {"pc": [2511], "errorMessage": "There are voters assigned to this proposal"}, {"pc": [1524], "errorMessage": "Too early"}, {"pc": [674, 937, 1392, 1726, 1991, 2496, 2562, 2647, 2789, 2981, 3416], "errorMessage": "Unauthorized"}, {"pc": [1812], "errorMessage": "Voter Already Assigned"}, {"pc": [2396], "errorMessage": "Voting Ongoing"}, {"pc": [1873], "errorMessage": "Voting Power Mismatch"}, {"pc": [3650], "errorMessage": "Wrong App ID"}, {"pc": [999], "errorMessage": "Wrong Funding Type"}, {"pc": [396], "errorMessage": "Wrong Global Bytes allocation"}, {"pc": [402], "errorMessage": "Wrong Global UInts allocation"}, {"pc": [406], "errorMessage": "Wrong Local Bytes allocation"}, {"pc": [410], "errorMessage": "Wrong Local UInts allocation"}, {"pc": [3660], "errorMessage": "Wrong Method Call"}, {"pc": [953, 1734, 2379, 2504, 2776, 2986, 3434], "errorMessage": "Wrong Proposal Status or finalized"}, {"pc": [1096], "errorMessage": "Wrong Receiver"}, {"pc": [1089], "errorMessage": "Wrong Sender"}, {"pc": [980, 984], "errorMessage": "Wrong Title length"}, {"pc": [2954, 2959, 3003], "errorMessage": "account funded"}, {"pc": [2526, 2949, 2998], "errorMessage": "application exists"}, {"pc": [2119, 2192, 3131, 3915, 3950], "errorMessage": "check self.approvals exists"}, {"pc": [1835, 1866, 3986], "errorMessage": "check self.assigned_votes exists"}, {"pc": [3108], "errorMessage": "check self.committee_id exists"}, {"pc": [1857, 3113, 3310, 3707], "errorMessage": "check self.committee_members exists"}, {"pc": [1871, 3119, 3822], "errorMessage": "check self.committee_votes exists"}, {"pc": [948, 1405, 2771, 2793, 2985, 3059, 3429], "errorMessage": "check self.finalized exists"}, {"pc": [3075], "errorMessage": "check self.focus exists"}, {"pc": [1244, 1478, 1886, 3069, 3273, 3673, 3779], "errorMessage": "check self.funding_category exists"}, {"pc": [1224, 3090], "errorMessage": "check self.funding_type exists"}, {"pc": [3102, 3628], "errorMessage": "check self.locked_amount exists"}, {"pc": [1366], "errorMessage": "check self.metadata exists"}, {"pc": [1563], "errorMessage": "check self.metadata_uploaded exists"}, {"pc": [2143, 2220, 3143, 3926], "errorMessage": "check self.nulls exists"}, {"pc": [1469, 3037], "errorMessage": "check self.open_ts exists"}, {"pc": [1087, 1434, 2449, 2550, 2938, 3013, 3575], "errorMessage": "check self.proposer exists"}, {"pc": [2523, 2946, 2995, 3018, 3488, 3537, 3598], "errorMessage": "check self.registry_app_id exists"}, {"pc": [2131, 2206, 3137, 3920, 3955], "errorMessage": "check self.rejections exists"}, {"pc": [1239, 3096], "errorMessage": "check self.requested_amount exists"}, {"pc": [941, 1396, 1730, 1995, 2375, 2500, 2566, 2637, 2751, 2761, 2800, 2807, 2816, 2826, 2836, 2928, 3054, 3420], "errorMessage": "check self.status exists"}, {"pc": [3043], "errorMessage": "check self.submission_ts exists"}, {"pc": [3024], "errorMessage": "check self.title exists"}, {"pc": [1895, 3049, 3268], "errorMessage": "check self.vote_open_ts exists"}, {"pc": [2095, 2178, 3125, 3305, 3933], "errorMessage": "check self.voted_members exists"}, {"pc": [2089, 2260, 2722, 3238], "errorMessage": "check self.voters entry exists"}, {"pc": [1824, 1852, 2509, 2868, 3975], "errorMessage": "check self.voters_count exists"}, {"pc": [1794, 2702], "errorMessage": "index access is out of bounds"}, {"pc": [897, 1307, 1709, 2621], "errorMessage": "invalid array length header"}, {"pc": [1327, 2468], "errorMessage": "invalid number of bytes for arc4.bool"}, {"pc": [2633], "errorMessage": "invalid number of bytes for arc4.dynamic_array<arc4.static_array<arc4.uint8, 32>>"}, {"pc": [904, 1319], "errorMessage": "invalid number of bytes for arc4.dynamic_array<arc4.uint8>"}, {"pc": [1722], "errorMessage": "invalid number of bytes for arc4.dynamic_array<smart_contracts.common.abi_types.CommitteeMember>"}, {"pc": [671, 1969, 3221], "errorMessage": "invalid number of bytes for arc4.static_array<arc4.uint8, 32>"}, {"pc": [913, 922, 1978, 1987], "errorMessage": "invalid number of bytes for arc4.uint64"}, {"pc": [930], "errorMessage": "invalid number of bytes for arc4.uint8"}, {"pc": [1231, 1251, 1911, 1923, 2184, 2198, 2212, 2226, 3082], "errorMessage": "overflow"}, {"pc": [890], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class ProposalTypedGlobalState:
    """Struct for ProposalTypedGlobalState"""
    proposer: str
    registry_app_id: int
    title: str
    open_ts: int
    submission_ts: int
    vote_open_ts: int
    status: int
    finalized: bool
    funding_category: int
    focus: int
    funding_type: int
    requested_amount: int
    locked_amount: int
    committee_id: bytes
    committee_members: int
    committee_votes: int
    voted_members: int
    approvals: int
    rejections: int
    nulls: int


@dataclasses.dataclass(frozen=True, kw_only=True)
class OpenArgs:
    """Dataclass for open arguments"""
    payment: algokit_utils.AppMethodCallTransactionArgument
    title: str
    funding_type: int
    requested_amount: int
    focus: int

    @property
    def abi_method_signature(self) -> str:
        return "open(pay,string,uint64,uint64,uint8)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class UploadMetadataArgs:
    """Dataclass for upload_metadata arguments"""
    payload: bytes | str
    is_first_in_group: bool

    @property
    def abi_method_signature(self) -> str:
        return "upload_metadata(byte[],bool)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class AssignVotersArgs:
    """Dataclass for assign_voters arguments"""
    voters: list[tuple[str, int]]

    @property
    def abi_method_signature(self) -> str:
        return "assign_voters((address,uint64)[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class VoteArgs:
    """Dataclass for vote arguments"""
    voter: str
    approvals: int
    rejections: int

    @property
    def abi_method_signature(self) -> str:
        return "vote(address,uint64,uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ReviewArgs:
    """Dataclass for review arguments"""
    block: bool

    @property
    def abi_method_signature(self) -> str:
        return "review(bool)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class UnassignVotersArgs:
    """Dataclass for unassign_voters arguments"""
    voters: list[str]

    @property
    def abi_method_signature(self) -> str:
        return "unassign_voters(address[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetVoterBoxArgs:
    """Dataclass for get_voter_box arguments"""
    voter_address: str

    @property
    def abi_method_signature(self) -> str:
        return "get_voter_box(address)(uint64,bool)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateArgs:
    """Dataclass for create arguments"""
    proposer: str

    @property
    def abi_method_signature(self) -> str:
        return "create(address)string"


class _ProposalDelete:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppDeleteMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete()void",
        }))


class ProposalParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_ProposalDelete":
        return _ProposalDelete(self.app_client)

    def open(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, str, int, int, int] | OpenArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "open(pay,string,uint64,uint64,uint8)void",
            "args": method_args,
        }))

    def upload_metadata(
        self,
        args: tuple[bytes | str, bool] | UploadMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "upload_metadata(byte[],bool)void",
            "args": method_args,
        }))

    def drop(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "drop()string",
        }))

    def submit(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "submit()void",
        }))

    def assign_voters(
        self,
        args: tuple[list[tuple[str, int]]] | AssignVotersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "assign_voters((address,uint64)[])void",
            "args": method_args,
        }))

    def vote(
        self,
        args: tuple[str, int, int] | VoteArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vote(address,uint64,uint64)string",
            "args": method_args,
        }))

    def scrutiny(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "scrutiny()void",
        }))

    def review(
        self,
        args: tuple[bool] | ReviewArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "review(bool)void",
            "args": method_args,
        }))

    def fund(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "fund()string",
        }))

    def unassign_voters(
        self,
        args: tuple[list[str]] | UnassignVotersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "unassign_voters(address[])void",
            "args": method_args,
        }))

    def finalize(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "finalize()string",
        }))

    def get_state(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)",
        }))

    def get_voter_box(
        self,
        args: tuple[str] | GetVoterBoxArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_voter_box(address)(uint64,bool)",
            "args": method_args,
        }))

    def op_up(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "op_up()void",
        }))

    def create(
        self,
        args: tuple[str] | CreateArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create(address)string",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class _ProposalDeleteTransaction:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete()void",
        }))


class ProposalCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_ProposalDeleteTransaction":
        return _ProposalDeleteTransaction(self.app_client)

    def open(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, str, int, int, int] | OpenArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "open(pay,string,uint64,uint64,uint8)void",
            "args": method_args,
        }))

    def upload_metadata(
        self,
        args: tuple[bytes | str, bool] | UploadMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "upload_metadata(byte[],bool)void",
            "args": method_args,
        }))

    def drop(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "drop()string",
        }))

    def submit(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "submit()void",
        }))

    def assign_voters(
        self,
        args: tuple[list[tuple[str, int]]] | AssignVotersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "assign_voters((address,uint64)[])void",
            "args": method_args,
        }))

    def vote(
        self,
        args: tuple[str, int, int] | VoteArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vote(address,uint64,uint64)string",
            "args": method_args,
        }))

    def scrutiny(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "scrutiny()void",
        }))

    def review(
        self,
        args: tuple[bool] | ReviewArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "review(bool)void",
            "args": method_args,
        }))

    def fund(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "fund()string",
        }))

    def unassign_voters(
        self,
        args: tuple[list[str]] | UnassignVotersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "unassign_voters(address[])void",
            "args": method_args,
        }))

    def finalize(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "finalize()string",
        }))

    def get_state(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)",
        }))

    def get_voter_box(
        self,
        args: tuple[str] | GetVoterBoxArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_voter_box(address)(uint64,bool)",
            "args": method_args,
        }))

    def op_up(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "op_up()void",
        }))

    def create(
        self,
        args: tuple[str] | CreateArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create(address)string",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class _ProposalDeleteSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)


class ProposalSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_ProposalDeleteSend":
        return _ProposalDeleteSend(self.app_client)

    def open(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, str, int, int, int] | OpenArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "open(pay,string,uint64,uint64,uint8)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def upload_metadata(
        self,
        args: tuple[bytes | str, bool] | UploadMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "upload_metadata(byte[],bool)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def drop(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "drop()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def submit(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "submit()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def assign_voters(
        self,
        args: tuple[list[tuple[str, int]]] | AssignVotersArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "assign_voters((address,uint64)[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def vote(
        self,
        args: tuple[str, int, int] | VoteArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vote(address,uint64,uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def scrutiny(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "scrutiny()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def review(
        self,
        args: tuple[bool] | ReviewArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "review(bool)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def fund(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "fund()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def unassign_voters(
        self,
        args: tuple[list[str]] | UnassignVotersArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "unassign_voters(address[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def finalize(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "finalize()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def get_state(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[ProposalTypedGlobalState]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)",
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(ProposalTypedGlobalState, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[ProposalTypedGlobalState], parsed_response)

    def get_voter_box(
        self,
        args: tuple[str] | GetVoterBoxArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[tuple[int, bool]]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_voter_box(address)(uint64,bool)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[tuple[int, bool]], parsed_response)

    def op_up(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "op_up()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def create(
        self,
        args: tuple[str] | CreateArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create(address)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    proposer: str
    registry_app_id: int
    title: str
    open_ts: int
    submission_ts: int
    vote_open_ts: int
    status: int
    finalized: int
    funding_category: int
    focus: int
    funding_type: int
    requested_amount: int
    locked_amount: int
    committee_id: bytes
    committee_members: int
    committee_votes: int
    voted_members: int
    approvals: int
    rejections: int
    nulls: int
    voters_count: int
    assigned_votes: int
    metadata_uploaded: int

class BoxStateValue(typing.TypedDict):
    """Shape of box state key values"""
    metadata: bytes

class ProposalState:
    """Methods to access state for the current Proposal app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def proposer(self) -> str:
        """Get the current value of the proposer key in global_state state"""
        value = self.app_client.state.global_state.get_value("proposer")
        if isinstance(value, dict) and "address" in self._struct_classes:
            return _init_dataclass(self._struct_classes["address"], value)  # type: ignore
        return typing.cast(str, value)

    @property
    def registry_app_id(self) -> int:
        """Get the current value of the registry_app_id key in global_state state"""
        value = self.app_client.state.global_state.get_value("registry_app_id")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def title(self) -> str:
        """Get the current value of the title key in global_state state"""
        value = self.app_client.state.global_state.get_value("title")
        if isinstance(value, dict) and "AVMString" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMString"], value)  # type: ignore
        return typing.cast(str, value)

    @property
    def open_ts(self) -> int:
        """Get the current value of the open_ts key in global_state state"""
        value = self.app_client.state.global_state.get_value("open_ts")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def submission_ts(self) -> int:
        """Get the current value of the submission_ts key in global_state state"""
        value = self.app_client.state.global_state.get_value("submission_ts")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def vote_open_ts(self) -> int:
        """Get the current value of the vote_open_ts key in global_state state"""
        value = self.app_client.state.global_state.get_value("vote_open_ts")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def status(self) -> int:
        """Get the current value of the status key in global_state state"""
        value = self.app_client.state.global_state.get_value("status")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def finalized(self) -> int:
        """Get the current value of the finalized key in global_state state"""
        value = self.app_client.state.global_state.get_value("finalized")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def funding_category(self) -> int:
        """Get the current value of the funding_category key in global_state state"""
        value = self.app_client.state.global_state.get_value("funding_category")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def focus(self) -> int:
        """Get the current value of the focus key in global_state state"""
        value = self.app_client.state.global_state.get_value("focus")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def funding_type(self) -> int:
        """Get the current value of the funding_type key in global_state state"""
        value = self.app_client.state.global_state.get_value("funding_type")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def requested_amount(self) -> int:
        """Get the current value of the requested_amount key in global_state state"""
        value = self.app_client.state.global_state.get_value("requested_amount")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def locked_amount(self) -> int:
        """Get the current value of the locked_amount key in global_state state"""
        value = self.app_client.state.global_state.get_value("locked_amount")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def committee_id(self) -> bytes:
        """Get the current value of the committee_id key in global_state state"""
        value = self.app_client.state.global_state.get_value("committee_id")
        if isinstance(value, dict) and "byte[32]" in self._struct_classes:
            return _init_dataclass(self._struct_classes["byte[32]"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def committee_members(self) -> int:
        """Get the current value of the committee_members key in global_state state"""
        value = self.app_client.state.global_state.get_value("committee_members")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def committee_votes(self) -> int:
        """Get the current value of the committee_votes key in global_state state"""
        value = self.app_client.state.global_state.get_value("committee_votes")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def voted_members(self) -> int:
        """Get the current value of the voted_members key in global_state state"""
        value = self.app_client.state.global_state.get_value("voted_members")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def approvals(self) -> int:
        """Get the current value of the approvals key in global_state state"""
        value = self.app_client.state.global_state.get_value("approvals")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def rejections(self) -> int:
        """Get the current value of the rejections key in global_state state"""
        value = self.app_client.state.global_state.get_value("rejections")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def nulls(self) -> int:
        """Get the current value of the nulls key in global_state state"""
        value = self.app_client.state.global_state.get_value("nulls")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def voters_count(self) -> int:
        """Get the current value of the voters_count key in global_state state"""
        value = self.app_client.state.global_state.get_value("voters_count")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def assigned_votes(self) -> int:
        """Get the current value of the assigned_votes key in global_state state"""
        value = self.app_client.state.global_state.get_value("assigned_votes")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def metadata_uploaded(self) -> int:
        """Get the current value of the metadata_uploaded key in global_state state"""
        value = self.app_client.state.global_state.get_value("metadata_uploaded")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> BoxStateValue:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return typing.cast(BoxStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(BoxStateValue, converted)

    @property
    def metadata(self) -> bytes:
        """Get the current value of the metadata key in box state"""
        value = self.app_client.state.box.get_value("metadata")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def voters(self) -> "_MapState[str, int]":
        """Get values from the voters map in box state"""
        return _MapState(
            self.app_client.state.box,
            "voters",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class ProposalClient:
    """Client for interacting with Proposal smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = ProposalParams(self.app_client)
        self.create_transaction = ProposalCreateTransactionParams(self.app_client)
        self.send = ProposalSend(self.app_client)
        self.state = ProposalState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "ProposalClient":
        return ProposalClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "ProposalClient":
        return ProposalClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "ProposalClient":
        return ProposalClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "ProposalComposer":
        return ProposalComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["open(pay,string,uint64,uint64,uint8)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["upload_metadata(byte[],bool)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["drop()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["submit()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["assign_voters((address,uint64)[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["vote(address,uint64,uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["scrutiny()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["review(bool)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["fund()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["unassign_voters(address[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["finalize()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> ProposalTypedGlobalState | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_voter_box(address)(uint64,bool)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> tuple[int, bool] | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["op_up()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create(address)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["delete()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | ProposalTypedGlobalState | str | tuple[int, bool]:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class ProposalMethodCallCreateParams(
    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[
        CreateArgs,
        str | None,
    ]
):
    """Parameters for creating Proposal contract using ABI"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallCreateParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

@dataclasses.dataclass(frozen=True)
class ProposalMethodCallDeleteParams(
    algokit_utils.BaseAppClientMethodCallParams[
        typing.Any,
        str | None,
    ]
):
    """Parameters for calling Proposal contract using ABI"""
    on_complete: typing.Literal[OnComplete.DeleteApplicationOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

class ProposalFactory(algokit_utils.TypedAppFactoryProtocol[ProposalMethodCallCreateParams, None, ProposalMethodCallDeleteParams]):
    """Factory for deploying and managing ProposalClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = ProposalFactoryParams(self.app_factory)
        self.create_transaction = ProposalFactoryCreateTransaction(self.app_factory)
        self.send = ProposalFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: ProposalMethodCallCreateParams | None = None,
        update_params: None = None,
        delete_params: ProposalMethodCallDeleteParams | None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[ProposalClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params.to_algokit_utils_params() if delete_params else None,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return ProposalClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> ProposalClient:
        """Get an app client by creator address and name"""
        return ProposalClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> ProposalClient:
        """Get an app client by app ID"""
        return ProposalClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class ProposalFactoryParams:
    """Parameters for creating transactions for Proposal contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = ProposalFactoryCreateParams(app_factory)
        self.update = ProposalFactoryUpdateParams(app_factory)
        self.delete = ProposalFactoryDeleteParams(app_factory)

class ProposalFactoryCreateParams:
    """Parameters for 'create' operations of Proposal contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def open(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, str, int, int, int] | OpenArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the open(pay,string,uint64,uint64,uint8)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "open(pay,string,uint64,uint64,uint8)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def upload_metadata(
        self,
        args: tuple[bytes | str, bool] | UploadMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the upload_metadata(byte[],bool)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "upload_metadata(byte[],bool)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def drop(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the drop()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "drop()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def submit(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the submit()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "submit()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def assign_voters(
        self,
        args: tuple[list[tuple[str, int]]] | AssignVotersArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the assign_voters((address,uint64)[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "assign_voters((address,uint64)[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def vote(
        self,
        args: tuple[str, int, int] | VoteArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the vote(address,uint64,uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "vote(address,uint64,uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def scrutiny(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the scrutiny()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "scrutiny()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def review(
        self,
        args: tuple[bool] | ReviewArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the review(bool)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "review(bool)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def fund(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the fund()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "fund()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def unassign_voters(
        self,
        args: tuple[list[str]] | UnassignVotersArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the unassign_voters(address[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "unassign_voters(address[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def finalize(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the finalize()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "finalize()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def get_state(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def get_voter_box(
        self,
        args: tuple[str] | GetVoterBoxArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_voter_box(address)(uint64,bool) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_voter_box(address)(uint64,bool)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def op_up(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the op_up()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "op_up()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def create(
        self,
        args: tuple[str] | CreateArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create(address)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create(address)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def delete(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the delete()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "delete()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class ProposalFactoryUpdateParams:
    """Parameters for 'update' operations of Proposal contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class ProposalFactoryDeleteParams:
    """Parameters for 'delete' operations of Proposal contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class ProposalFactoryCreateTransaction:
    """Create transactions for Proposal contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = ProposalFactoryCreateTransactionCreate(app_factory)


class ProposalFactoryCreateTransactionCreate:
    """Create new instances of Proposal contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class ProposalFactorySend:
    """Send calls to Proposal contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = ProposalFactorySendCreate(app_factory)


class ProposalFactorySendCreate:
    """Send create calls to Proposal contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[ProposalClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return ProposalClient(result[0]), result[1]

    def create(
        self,
        args: tuple[str] | CreateArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> tuple[ProposalClient, algokit_utils.AppFactoryCreateMethodCallResult[str]]:
            """Creates and sends a transaction using the create(address)string ABI method"""
            params = params or algokit_utils.CommonAppCallCreateParams()
            client, result = self.app_factory.send.create(
                algokit_utils.AppFactoryCreateMethodCallParams(
                    **{
                    **dataclasses.asdict(params),
                    "method": "create(address)string",
                    "args": _parse_abi_args(args),
                    }
                ),
                send_params=send_params,
                compilation_params=compilation_params
            )
            return_value = None if result.abi_return is None else typing.cast(str, result.abi_return)
    
            return ProposalClient(client), algokit_utils.AppFactoryCreateMethodCallResult[str](
                **{
                    **result.__dict__,
                    "app_id": result.app_id,
                    "abi_return": return_value,
                    "transaction": result.transaction,
                    "confirmation": result.confirmation,
                    "group_id": result.group_id,
                    "tx_ids": result.tx_ids,
                    "transactions": result.transactions,
                    "confirmations": result.confirmations,
                    "app_address": result.app_address,
                }
            )


class _ProposalDeleteComposer:
    def __init__(self, composer: "ProposalComposer"):
        self.composer = composer
    def delete(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self.composer._composer.add_app_delete_method_call(
            self.composer.client.params.delete.delete(
                
                params=params,
                
            )
        )
        self.composer._result_mappers.append(
            lambda v: self.composer.client.decode_return_value(
                "delete()void", v
            )
        )
        return self.composer


class ProposalComposer:
    """Composer for creating transaction groups for Proposal contract calls"""

    def __init__(self, client: "ProposalClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    @property
    def delete(self) -> "_ProposalDeleteComposer":
        return _ProposalDeleteComposer(self)

    def open(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, str, int, int, int] | OpenArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.open(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "open(pay,string,uint64,uint64,uint8)void", v
            )
        )
        return self

    def upload_metadata(
        self,
        args: tuple[bytes | str, bool] | UploadMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.upload_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "upload_metadata(byte[],bool)void", v
            )
        )
        return self

    def drop(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.drop(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "drop()string", v
            )
        )
        return self

    def submit(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.submit(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "submit()void", v
            )
        )
        return self

    def assign_voters(
        self,
        args: tuple[list[tuple[str, int]]] | AssignVotersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.assign_voters(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "assign_voters((address,uint64)[])void", v
            )
        )
        return self

    def vote(
        self,
        args: tuple[str, int, int] | VoteArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.vote(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "vote(address,uint64,uint64)string", v
            )
        )
        return self

    def scrutiny(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.scrutiny(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "scrutiny()void", v
            )
        )
        return self

    def review(
        self,
        args: tuple[bool] | ReviewArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.review(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "review(bool)void", v
            )
        )
        return self

    def fund(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.fund(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "fund()string", v
            )
        )
        return self

    def unassign_voters(
        self,
        args: tuple[list[str]] | UnassignVotersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.unassign_voters(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "unassign_voters(address[])void", v
            )
        )
        return self

    def finalize(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.finalize(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "finalize()string", v
            )
        )
        return self

    def get_state(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_state(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)", v
            )
        )
        return self

    def get_voter_box(
        self,
        args: tuple[str] | GetVoterBoxArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_voter_box(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_voter_box(address)(uint64,bool)", v
            )
        )
        return self

    def op_up(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.op_up(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "op_up()void", v
            )
        )
        return self

    def create(
        self,
        args: tuple[str] | CreateArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ProposalComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create(address)string", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "ProposalComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "ProposalComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
