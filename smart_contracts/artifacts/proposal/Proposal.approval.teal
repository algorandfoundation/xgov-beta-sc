#pragma version 10
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 10 10000
    bytecblock 0x737461747573 0x 0x66696e616c697a6564 0x70726f706f736572 0x72656769737472795f6170705f6964 0x61737369676e65645f6d656d62657273 0x766f7465645f6d656d62657273 0x617070726f76616c73 0x72656a656374696f6e73 "M" 0x151f7c75 0x636f6d6d69747465655f6d656d62657273 0x7265717565737465645f616d6f756e74 0x626f79636f747465645f6d656d62657273 0x6e756c6c73 0x636f6d6d69747465655f766f746573 0x66756e64696e675f63617465676f7279 0x61737369676e65645f766f746573 "V" 0x00 0x6c6f636b65645f616d6f756e74 0x71756f72756d5f7468726573686f6c64 0x77656967687465645f71756f72756d5f7468726573686f6c64 "ERR:Wrong Proposal Status or finalized" 0x636f6d6d69747465655f6964 0x6f70656e5f70726f706f73616c5f666565 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073 0x6f70656e5f74696d657374616d70 0x766f74655f6f70656e696e675f74696d657374616d70 0x66756e64696e675f74797065 0x766f74696e675f6475726174696f6e 0x7061757365645f7265676973747279 0x7375626d697373696f6e5f74696d657374616d70 0x6d657461646174615f75706c6f61646564 0x7469746c65 0x666f637573 0x64697363757373696f6e5f6475726174696f6e 0x6d696e5f7265717565737465645f616d6f756e74 0x6d61785f7265717565737465645f616d6f756e745f6c61726765 0x78676f765f6461656d6f6e "ERR:Voter not found"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/proposal/contract.py:48
    // Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 3
    ==
    // smart_contracts/proposal/contract.py:46-49
    // # Preconditions
    // assert (
    //     Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    // ), err.WRONG_GLOBAL_BYTES
    assert // Wrong Global Bytes allocation
    // smart_contracts/proposal/contract.py:50
    // assert Txn.global_num_uint == prop_cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    pushint 27
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/proposal/contract.py:51
    // assert Txn.local_num_byte_slice == prop_cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/proposal/contract.py:52
    // assert Txn.local_num_uint == prop_cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/proposal/contract.py:57
    // key=prop_cfg.GS_KEY_PROPOSER,
    bytec_3 // 0x70726f706f736572
    // smart_contracts/proposal/contract.py:56
    // Account(),
    global ZeroAddress
    // smart_contracts/proposal/contract.py:54-58
    // # Base State
    // self.proposer = GlobalState(
    //     Account(),
    //     key=prop_cfg.GS_KEY_PROPOSER,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:61
    // key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    bytec 4 // 0x72656769737472795f6170705f6964
    // smart_contracts/proposal/contract.py:60
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:59-62
    // self.registry_app_id = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:67
    // key=reg_cfg.GS_KEY_COMMITTEE_ID,
    bytec 24 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:66
    // typ.Bytes32.from_bytes(b""),
    bytec_1 // 0x
    // smart_contracts/proposal/contract.py:64-68
    // # From xGov Registry
    // self.committee_id = GlobalState(
    //     typ.Bytes32.from_bytes(b""),
    //     key=reg_cfg.GS_KEY_COMMITTEE_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:71
    // key=reg_cfg.GS_KEY_COMMITTEE_MEMBERS,
    bytec 11 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:70
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:69-72
    // self.committee_members = GlobalState(
    //     UInt64(),
    //     key=reg_cfg.GS_KEY_COMMITTEE_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:75
    // key=reg_cfg.GS_KEY_COMMITTEE_VOTES,
    bytec 15 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:74
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:73-76
    // self.committee_votes = GlobalState(
    //     UInt64(),
    //     key=reg_cfg.GS_KEY_COMMITTEE_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:79
    // key=reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE,
    bytec 25 // 0x6f70656e5f70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:78
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:77-80
    // self.open_proposal_fee = GlobalState(
    //     UInt64(),
    //     key=reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:83
    // key=reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS,
    bytec 26 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    // smart_contracts/proposal/contract.py:82
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:81-84
    // self.daemon_ops_funding_bps = GlobalState(
    //     UInt64(),
    //     key=reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:89
    // key=prop_cfg.GS_KEY_OPEN_TS,
    bytec 27 // 0x6f70656e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:88
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:86-90
    // # Time Anchors
    // self.open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:93
    // key=prop_cfg.GS_KEY_SUBMISSION_TS,
    bytec 32 // 0x7375626d697373696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:92
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:91-94
    // self.submission_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_SUBMISSION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:97
    // key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    bytec 28 // 0x766f74655f6f70656e696e675f74696d657374616d70
    // smart_contracts/proposal/contract.py:96
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:95-98
    // self.vote_open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:103
    // key=prop_cfg.GS_KEY_STATUS,
    bytec_0 // 0x737461747573
    // smart_contracts/proposal/contract.py:102
    // UInt64(enm.STATUS_EMPTY),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:100-104
    // # Proposal State
    // self.status = GlobalState(
    //     UInt64(enm.STATUS_EMPTY),
    //     key=prop_cfg.GS_KEY_STATUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:107
    // key=prop_cfg.GS_KEY_FINALIZED,
    bytec_2 // 0x66696e616c697a6564
    // smart_contracts/proposal/contract.py:106
    // False,  # noqa: FBT003
    intc_0 // 0
    // smart_contracts/proposal/contract.py:105-108
    // self.finalized = GlobalState(
    //     False,  # noqa: FBT003
    //     key=prop_cfg.GS_KEY_FINALIZED,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:111
    // key=prop_cfg.GS_KEY_METADATA_UPLOADED,
    bytec 33 // 0x6d657461646174615f75706c6f61646564
    // smart_contracts/proposal/contract.py:110
    // False,  # noqa: FBT003
    intc_0 // 0
    // smart_contracts/proposal/contract.py:109-112
    // self.metadata_uploaded = GlobalState(
    //     False,  # noqa: FBT003
    //     key=prop_cfg.GS_KEY_METADATA_UPLOADED,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:117
    // key=prop_cfg.GS_KEY_TITLE,
    bytec 34 // 0x7469746c65
    // smart_contracts/proposal/contract.py:116
    // String(),
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:114-118
    // # Proposal Configuration
    // self.title = GlobalState(
    //     String(),
    //     key=prop_cfg.GS_KEY_TITLE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:121
    // key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    bytec 16 // 0x66756e64696e675f63617465676f7279
    // smart_contracts/proposal/contract.py:120
    // UInt64(enm.FUNDING_CATEGORY_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:119-122
    // self.funding_category = GlobalState(
    //     UInt64(enm.FUNDING_CATEGORY_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:125
    // key=prop_cfg.GS_KEY_FOCUS,
    bytec 35 // 0x666f637573
    // smart_contracts/proposal/contract.py:124
    // UInt64(enm.FOCUS_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:123-126
    // self.focus = GlobalState(
    //     UInt64(enm.FOCUS_NULL),
    //     key=prop_cfg.GS_KEY_FOCUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:129
    // key=prop_cfg.GS_KEY_FUNDING_TYPE,
    bytec 29 // 0x66756e64696e675f74797065
    // smart_contracts/proposal/contract.py:128
    // UInt64(enm.FUNDING_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:127-130
    // self.funding_type = GlobalState(
    //     UInt64(enm.FUNDING_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_TYPE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:133
    // key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    bytec 12 // 0x7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:132
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:131-134
    // self.requested_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:137
    // key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    bytec 20 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:136
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:135-138
    // self.locked_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:141
    // key=prop_cfg.GS_KEY_DISCUSSION_DURATION,
    bytec 36 // 0x64697363757373696f6e5f6475726174696f6e
    // smart_contracts/proposal/contract.py:140
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:139-142
    // self.discussion_duration = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_DISCUSSION_DURATION,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:145
    // key=prop_cfg.GS_KEY_VOTING_DURATION,
    bytec 30 // 0x766f74696e675f6475726174696f6e
    // smart_contracts/proposal/contract.py:144
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:143-146
    // self.voting_duration = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTING_DURATION,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:149
    // key=prop_cfg.GS_KEY_QUORUM_THRESHOLD,
    bytec 21 // 0x71756f72756d5f7468726573686f6c64
    // smart_contracts/proposal/contract.py:148
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:147-150
    // self.quorum_threshold = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_QUORUM_THRESHOLD,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:153
    // key=prop_cfg.GS_KEY_WEIGHTED_QUORUM_THRESHOLD,
    bytec 22 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    // smart_contracts/proposal/contract.py:152
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:151-154
    // self.weighted_quorum_threshold = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_WEIGHTED_QUORUM_THRESHOLD,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:159
    // key=prop_cfg.GS_KEY_ASSIGNED_MEMBERS,
    bytec 5 // 0x61737369676e65645f6d656d62657273
    // smart_contracts/proposal/contract.py:158
    // UInt64(0),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:156-160
    // # Proposal Vote
    // self.assigned_members = GlobalState(
    //     UInt64(0),
    //     key=prop_cfg.GS_KEY_ASSIGNED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:163
    // key=prop_cfg.GS_KEY_ASSIGNED_VOTES,
    bytec 17 // 0x61737369676e65645f766f746573
    // smart_contracts/proposal/contract.py:162
    // UInt64(0),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:161-164
    // self.assigned_votes = GlobalState(
    //     UInt64(0),
    //     key=prop_cfg.GS_KEY_ASSIGNED_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:167
    // key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    bytec 6 // 0x766f7465645f6d656d62657273
    // smart_contracts/proposal/contract.py:166
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:165-168
    // self.voted_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:171
    // key=prop_cfg.GS_KEY_BOYCOTTED_MEMBERS,
    bytec 13 // 0x626f79636f747465645f6d656d62657273
    // smart_contracts/proposal/contract.py:170
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:169-172
    // self.boycotted_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_BOYCOTTED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:175
    // key=prop_cfg.GS_KEY_APPROVALS,
    bytec 7 // 0x617070726f76616c73
    // smart_contracts/proposal/contract.py:174
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:173-176
    // self.approvals = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_APPROVALS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:179
    // key=prop_cfg.GS_KEY_REJECTIONS,
    bytec 8 // 0x72656a656374696f6e73
    // smart_contracts/proposal/contract.py:178
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:177-180
    // self.rejections = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REJECTIONS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:183
    // key=prop_cfg.GS_KEY_NULLS,
    bytec 14 // 0x6e756c6c73
    // smart_contracts/proposal/contract.py:182
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:181-184
    // self.nulls = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_NULLS,
    // )
    app_global_put

main_after_if_else@2:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ProposalInterface,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x24378d3c // method "delete()void"
    txna ApplicationArgs 0
    match main_delete_route@4

main_switch_case_next@5:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ProposalInterface,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@24
    pushbytess 0xedaeb9ca 0x7143994f 0x7371321a 0x34e613ca 0x0d9ab0d7 0x1841a0d2 0x734dbecc 0x76ff4c70 0x212d9f07 0x8a5e4c80 0x2ac19b05 0x802069b4 0xb649e874 0x24615f90 0x369c42ba 0xdbd83dd9 // method "open(pay,string,uint64,uint64,uint8)void", method "upload_metadata(byte[],bool)void", method "drop()string", method "submit()void", method "assign_voters((address,uint64)[])void", method "vote(address,uint64,uint64)string", method "scrutiny()void", method "unassign_absentees(address[])string", method "review(bool)void", method "fund()string", method "unassign_voters(address[])void", method "finalize()string", method "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "get_voter_box(address)(uint64,bool)", method "get_voting_state()(uint32,uint32,uint32,uint32,uint32,uint32,uint32,bool,bool,bool,bool)", method "op_up()void"
    txna ApplicationArgs 0
    match open upload_metadata drop submit assign_voters vote scrutiny unassign_absentees review fund unassign_voters finalize get_state get_voter_box get_voting_state main_op_up_route@22
    err

main_op_up_route@22:
    // smart_contracts/proposal/contract.py:1184
    // @arc4.abimethod()
    intc_1 // 1
    return

main_create_NoOp@24:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ProposalInterface,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0xcc694eaa // method "create(address)void"
    txna ApplicationArgs 0
    match create
    err

main_delete_route@4:
    // smart_contracts/proposal/contract.py:1078
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert
    b delete


// smart_contracts.proposal.contract.Proposal.create[routing]() -> void:
create:
    // smart_contracts/proposal/contract.py:569
    // @arc4.abimethod(create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/proposal/contract.py:582
    // Global.caller_application_id != 0
    global CallerApplicationID
    // smart_contracts/proposal/contract.py:581-583
    // assert (
    //     Global.caller_application_id != 0
    // ), err.UNAUTHORIZED  # Only callable by another contract
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:585-586
    // # Set Proposal Base State
    // self.proposer.value = proposer
    bytec_3 // 0x70726f706f736572
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:587
    // self.registry_app_id.value = Global.caller_application_id
    bytec 4 // 0x72656769737472795f6170705f6964
    global CallerApplicationID
    app_global_put
    // smart_contracts/proposal/contract.py:591
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    bytec 24 // 0x636f6d6d69747465655f6964
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:589-590
    // # Set values from xGov Registry
    // self.committee_id.value = typ.Bytes32.from_bytes(
    bytec 24 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:589-592
    // # Set values from xGov Registry
    // self.committee_id.value = typ.Bytes32.from_bytes(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    // )  # The xGov Registry COMMITTEE_STALE error ensures the Committee is available
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:594
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 11 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:593-595
    // self.committee_members.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:593
    // self.committee_members.value = self.get_uint_from_registry_config(
    bytec 11 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:593-595
    // self.committee_members.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:597
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 15 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:596-598
    // self.committee_votes.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:596
    // self.committee_votes.value = self.get_uint_from_registry_config(
    bytec 15 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:596-598
    // self.committee_votes.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:600
    // Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    bytec 25 // 0x6f70656e5f70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:599-601
    // self.open_proposal_fee.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:599
    // self.open_proposal_fee.value = self.get_uint_from_registry_config(
    bytec 25 // 0x6f70656e5f70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:599-601
    // self.open_proposal_fee.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:603
    // Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    bytec 26 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    // smart_contracts/proposal/contract.py:602-604
    // self.daemon_ops_funding_bps.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:602
    // self.daemon_ops_funding_bps.value = self.get_uint_from_registry_config(
    bytec 26 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    // smart_contracts/proposal/contract.py:602-604
    // self.daemon_ops_funding_bps.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:569
    // @arc4.abimethod(create="require")
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.open[routing]() -> void:
open:
    bytec_1 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:606
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    // smart_contracts/proposal/contract.py:438
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    bytec 31 // 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:437-439
    // registry_paused = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:440
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/proposal/contract.py:364
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:366
    // self.status.value == enm.STATUS_EMPTY and not self.finalized.value
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    bnz open_bool_false@4
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz open_bool_false@4
    intc_1 // 1

open_bool_merge@5:
    // smart_contracts/proposal/contract.py:365-367
    // assert (
    //     self.status.value == enm.STATUS_EMPTY and not self.finalized.value
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:376
    // assert title.bytes.length <= const.TITLE_MAX_BYTES, err.WRONG_TITLE_LENGTH
    dig 3
    dup
    len
    pushint 123
    <=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:377
    // assert title != "", err.WRONG_TITLE_LENGTH
    bytec_1 // ""
    !=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:380
    // funding_type == enm.FUNDING_PROACTIVE
    dig 2
    intc_3 // 10
    ==
    // smart_contracts/proposal/contract.py:380-381
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bnz open_bool_true@9
    // smart_contracts/proposal/contract.py:381
    // or funding_type == enm.FUNDING_RETROACTIVE
    dig 2
    pushint 20
    ==
    // smart_contracts/proposal/contract.py:380-381
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bz open_bool_false@10

open_bool_true@9:
    intc_1 // 1

open_bool_merge@11:
    // smart_contracts/proposal/contract.py:379-382
    // assert (
    //     funding_type == enm.FUNDING_PROACTIVE
    //     or funding_type == enm.FUNDING_RETROACTIVE
    // ), err.WRONG_FUNDING_TYPE
    assert // Wrong Funding Type
    // smart_contracts/proposal/contract.py:385
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    bytec 37 // 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:384-386
    // min_requested_amount = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:389
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    bytec 38 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:388-390
    // max_requested_amount_large = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:392
    // assert requested_amount >= min_requested_amount, err.WRONG_MIN_REQUESTED_AMOUNT
    dig 3
    dup
    cover 2
    uncover 3
    >=
    assert // Requested amount is less than the minimum requested amount
    // smart_contracts/proposal/contract.py:394
    // requested_amount <= max_requested_amount_large
    dig 1
    >=
    // smart_contracts/proposal/contract.py:393-395
    // assert (
    //     requested_amount <= max_requested_amount_large
    // ), err.WRONG_MAX_REQUESTED_AMOUNT
    assert // Requested amount is more than the maximum requested amount
    // smart_contracts/proposal/contract.py:404
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    pushbytes 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    // smart_contracts/proposal/contract.py:403-405
    // proposal_commitment_bps = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:400
    // return amount * fraction_in_bps // const.BPS
    dig 1
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:416
    // assert payment.sender == self.proposer.value, err.WRONG_SENDER
    dig 6
    dup
    gtxns Sender
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    assert // Wrong Sender
    // smart_contracts/proposal/contract.py:418
    // payment.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/proposal/contract.py:417-419
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/proposal/contract.py:420
    // assert payment.amount == expected_lock_amount, err.WRONG_LOCKED_AMOUNT
    gtxns Amount
    dup
    bury 9
    ==
    assert // Locked amount is incorrect
    // smart_contracts/proposal/contract.py:647-648
    // # Configure Proposal
    // self.title.value = title
    bytec 34 // 0x7469746c65
    dig 5
    app_global_put
    // smart_contracts/proposal/contract.py:424
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    // smart_contracts/proposal/contract.py:423-425
    // max_requested_amount_small = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:427
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    // smart_contracts/proposal/contract.py:426-428
    // max_requested_amount_medium = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    bury 9
    // smart_contracts/proposal/contract.py:429
    // if requested_amount <= max_requested_amount_small:
    <=
    bz open_else_body@17
    // smart_contracts/proposal/contract.py:430
    // return UInt64(enm.FUNDING_CATEGORY_SMALL)
    intc_3 // 10

open_after_inlined_smart_contracts.proposal.contract.Proposal.get_category@20:
    // smart_contracts/proposal/contract.py:649
    // self.funding_category.value = self.get_category(requested_amount)
    bytec 16 // 0x66756e64696e675f63617465676f7279
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:650
    // self.funding_type.value = funding_type
    bytec 29 // 0x66756e64696e675f74797065
    dig 3
    app_global_put
    // smart_contracts/proposal/contract.py:651
    // self.requested_amount.value = requested_amount
    bytec 12 // 0x7265717565737465645f616d6f756e74
    dig 2
    app_global_put
    // smart_contracts/proposal/contract.py:652
    // self.focus.value = focus.as_uint64()
    dup
    btoi
    bytec 35 // 0x666f637573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:653
    // self.locked_amount.value = payment.amount  # The amount is validated
    bytec 20 // 0x6c6f636b65645f616d6f756e74
    dig 6
    app_global_put
    // smart_contracts/proposal/contract.py:657
    // self.funding_category.value != enm.FUNDING_CATEGORY_NULL
    intc_0 // 0
    bytec 16 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    bury 10
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:655-658
    // # Configure category dependent values
    // assert (
    //     self.funding_category.value != enm.FUNDING_CATEGORY_NULL
    // ), err.MISSING_CONFIG
    dup
    assert // Missing Config
    // smart_contracts/proposal/contract.py:659
    // assert self.requested_amount.value != 0, err.MISSING_CONFIG
    intc_0 // 0
    bytec 12 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    assert // Missing Config
    // smart_contracts/proposal/contract.py:311
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_3 // 10
    ==
    bz open_else_body@23
    // smart_contracts/proposal/contract.py:313
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:312-314
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config

open_after_inlined_smart_contracts.proposal.contract.Proposal.get_discussion_duration@26:
    // smart_contracts/proposal/contract.py:660
    // self.discussion_duration.value = self.get_discussion_duration(
    bytec 36 // 0x64697363757373696f6e5f6475726174696f6e
    // smart_contracts/proposal/contract.py:660-662
    // self.discussion_duration.value = self.get_discussion_duration(
    //     self.funding_category.value
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:664
    // self.funding_category.value
    intc_0 // 0
    bytec 16 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    bury 10
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:325
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_3 // 10
    ==
    bz open_else_body@29
    // smart_contracts/proposal/contract.py:327
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    pushbytes 0x766f74696e675f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:326-328
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    bury 6

open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@32:
    // smart_contracts/proposal/contract.py:663
    // self.voting_duration.value = self.get_voting_duration(
    bytec 30 // 0x766f74696e675f6475726174696f6e
    // smart_contracts/proposal/contract.py:663-665
    // self.voting_duration.value = self.get_voting_duration(
    //     self.funding_category.value
    // )
    dig 6
    app_global_put
    // smart_contracts/proposal/contract.py:482
    // Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    pushbytes 0x71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:481-483
    // quorum_min_bps = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:485
    // Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    pushbytes 0x71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:484-486
    // quorum_max_bps = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:487-488
    // # The xGov Registry ensures quorum_max_bps > quorum_min_bps
    // delta_quorum_bps = quorum_max_bps - quorum_min_bps
    dig 1
    -
    // smart_contracts/proposal/contract.py:491
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    bytec 37 // 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:490-492
    // amount_min = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:494
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    bytec 38 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:493-495
    // amount_max = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:496-497
    // # The xGov Registry ensures amount_max > amount_min
    // delta_amount = amount_max - amount_min
    dig 1
    -
    // smart_contracts/proposal/contract.py:502
    // * (self.requested_amount.value - amount_min)
    intc_0 // 0
    bytec 12 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    uncover 2
    -
    // smart_contracts/proposal/contract.py:501-502
    // + delta_quorum_bps
    // * (self.requested_amount.value - amount_min)
    uncover 2
    *
    // smart_contracts/proposal/contract.py:501-503
    // + delta_quorum_bps
    // * (self.requested_amount.value - amount_min)
    // // delta_amount
    swap
    /
    // smart_contracts/proposal/contract.py:500-503
    // quorum_min_bps
    // + delta_quorum_bps
    // * (self.requested_amount.value - amount_min)
    // // delta_amount
    +
    // smart_contracts/proposal/contract.py:506
    // self.committee_members.value, quorum_bps
    intc_0 // 0
    bytec 11 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:400
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:666
    // self.quorum_threshold.value = self.compute_quorum_threshold()
    bytec 21 // 0x71756f72756d5f7468726573686f6c64
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:511
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    pushbytes 0x77656967687465645f71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:510-512
    // weighted_quorum_min_bps = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:514
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    pushbytes 0x77656967687465645f71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:513-515
    // weighted_quorum_max_bps = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:516-517
    // # The xGov Registry ensures weighted_quorum_max_bps > weighted_quorum_min_bps
    // delta_weighted_quorum_bps = weighted_quorum_max_bps - weighted_quorum_min_bps
    dig 1
    -
    // smart_contracts/proposal/contract.py:520
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    bytec 37 // 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:519-521
    // amount_min = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:523
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    bytec 38 // 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:522-524
    // amount_max = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:525-526
    // # The xGov Registry ensures amount_max > amount_min
    // delta_amount = amount_max - amount_min
    dig 1
    -
    // smart_contracts/proposal/contract.py:531
    // * (self.requested_amount.value - amount_min)
    intc_0 // 0
    bytec 12 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    uncover 2
    -
    // smart_contracts/proposal/contract.py:530-531
    // + delta_weighted_quorum_bps
    // * (self.requested_amount.value - amount_min)
    uncover 2
    *
    // smart_contracts/proposal/contract.py:530-532
    // + delta_weighted_quorum_bps
    // * (self.requested_amount.value - amount_min)
    // // delta_amount
    swap
    /
    // smart_contracts/proposal/contract.py:529-532
    // weighted_quorum_min_bps
    // + delta_weighted_quorum_bps
    // * (self.requested_amount.value - amount_min)
    // // delta_amount
    +
    // smart_contracts/proposal/contract.py:535
    // self.committee_votes.value, weighted_quorum_bps
    intc_0 // 0
    bytec 15 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/proposal/contract.py:400
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:667
    // self.weighted_quorum_threshold.value = self.compute_weighted_quorum_threshold()
    bytec 22 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:669-670
    // # Update Proposal State and time anchors
    // self.status.value = UInt64(enm.STATUS_DRAFT)
    bytec_0 // 0x737461747573
    intc_3 // 10
    app_global_put
    // smart_contracts/proposal/contract.py:671
    // self.open_ts.value = Global.latest_timestamp
    bytec 27 // 0x6f70656e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:675
    // funding_type=arc4.UInt8(self.funding_type.value),
    intc_0 // 0
    bytec 29 // 0x66756e64696e675f74797065
    app_global_get_ex
    assert // check self.funding_type exists
    itob
    dup
    bitlen
    pushint 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:676
    // requested_amount=self.requested_amount.value,
    intc_0 // 0
    bytec 12 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    // smart_contracts/proposal/contract.py:677
    // category=arc4.UInt8(self.funding_category.value),
    intc_0 // 0
    bytec 16 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    assert // check self.funding_category exists
    itob
    dup
    bitlen
    pushint 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:674-678
    // typ.Opened(
    //     funding_type=arc4.UInt8(self.funding_type.value),
    //     requested_amount=self.requested_amount.value,
    //     category=arc4.UInt8(self.funding_category.value),
    // )
    swap
    itob
    uncover 2
    swap
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:673-679
    // arc4.emit(
    //     typ.Opened(
    //         funding_type=arc4.UInt8(self.funding_type.value),
    //         requested_amount=self.requested_amount.value,
    //         category=arc4.UInt8(self.funding_category.value),
    //     )
    // )
    pushbytes 0x371243f5 // method "Opened(uint8,uint64,uint8)"
    swap
    concat
    log
    // smart_contracts/proposal/contract.py:606
    // @arc4.abimethod()
    intc_1 // 1
    return

open_else_body@29:
    // smart_contracts/proposal/contract.py:329
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dig 7
    pushint 20
    ==
    bz open_else_body@31
    // smart_contracts/proposal/contract.py:331
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    pushbytes 0x766f74696e675f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:330-332
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    bury 6
    // smart_contracts/proposal/contract.py:663-665
    // self.voting_duration.value = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@32

open_else_body@31:
    // smart_contracts/proposal/contract.py:335
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    pushbytes 0x766f74696e675f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:334-336
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    bury 6
    // smart_contracts/proposal/contract.py:663-665
    // self.voting_duration.value = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@32

open_else_body@23:
    // smart_contracts/proposal/contract.py:315
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dig 7
    pushint 20
    ==
    bz open_else_body@25
    // smart_contracts/proposal/contract.py:317
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:316-318
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:660-662
    // self.discussion_duration.value = self.get_discussion_duration(
    //     self.funding_category.value
    // )
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_discussion_duration@26

open_else_body@25:
    // smart_contracts/proposal/contract.py:321
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:320-322
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:660-662
    // self.discussion_duration.value = self.get_discussion_duration(
    //     self.funding_category.value
    // )
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_discussion_duration@26

open_else_body@17:
    // smart_contracts/proposal/contract.py:431
    // elif requested_amount <= max_requested_amount_medium:
    dig 1
    dig 7
    <=
    bz open_else_body@19
    // smart_contracts/proposal/contract.py:432
    // return UInt64(enm.FUNDING_CATEGORY_MEDIUM)
    pushint 20
    // smart_contracts/proposal/contract.py:649
    // self.funding_category.value = self.get_category(requested_amount)
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_category@20

open_else_body@19:
    // smart_contracts/proposal/contract.py:434
    // return UInt64(enm.FUNDING_CATEGORY_LARGE)
    pushint 30
    // smart_contracts/proposal/contract.py:649
    // self.funding_category.value = self.get_category(requested_amount)
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_category@20

open_bool_false@10:
    intc_0 // 0
    b open_bool_merge@11

open_bool_false@4:
    intc_0 // 0
    b open_bool_merge@5


// smart_contracts.proposal.contract.Proposal.upload_metadata[routing]() -> void:
upload_metadata:
    // smart_contracts/proposal/contract.py:681
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    // smart_contracts/proposal/contract.py:438
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    bytec 31 // 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:437-439
    // registry_paused = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:440
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/proposal/contract.py:358
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:361
    // assert payload.length > 0, err.EMPTY_PAYLOAD
    swap
    len
    dup
    cover 3
    assert // Empty payload
    // smart_contracts/proposal/contract.py:701
    // self.metadata_uploaded.value = True
    bytec 33 // 0x6d657461646174615f75706c6f61646564
    intc_1 // 1
    app_global_put
    // smart_contracts/proposal/contract.py:703
    // if is_first_in_group:
    bz upload_metadata_else_body@3
    // smart_contracts/proposal/contract.py:704-705
    // # clear and write the metadata to the box
    // del self.metadata.value
    bytec 9 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:706
    // self.metadata.value = payload
    bytec 9 // "M"
    box_del
    pop
    bytec 9 // "M"
    swap
    box_put

upload_metadata_after_if_else@4:
    // smart_contracts/proposal/contract.py:681
    // @arc4.abimethod()
    intc_1 // 1
    return

upload_metadata_else_body@3:
    // smart_contracts/proposal/contract.py:708-709
    // # append the metadata to the box
    // old_size = self.metadata.length
    bytec 9 // "M"
    box_len
    assert // check self.metadata exists
    // smart_contracts/proposal/contract.py:710
    // self.metadata.resize(self.metadata.length + payload.length)
    dup
    dig 3
    +
    bytec 9 // "M"
    swap
    box_resize
    // smart_contracts/proposal/contract.py:711
    // self.metadata.replace(old_size, payload)
    bytec 9 // "M"
    swap
    uncover 2
    box_replace
    b upload_metadata_after_if_else@4


// smart_contracts.proposal.contract.Proposal.drop[routing]() -> void:
drop:
    intc_0 // 0
    // smart_contracts/proposal/contract.py:352
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:353
    // if self.status.value != enm.STATUS_DRAFT or self.finalized.value:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 10
    !=
    bnz drop_if_body@7
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bz drop_after_if_else@8

drop_if_body@7:
    // smart_contracts/proposal/contract.py:354
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 23 // "ERR:Wrong Proposal Status or finalized"
    bury 1

drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@9:
    // smart_contracts/proposal/contract.py:724
    // if error != typ.Error(""):
    dup
    bytec_1 // ""
    !=
    bz drop_after_if_else@3
    dup

drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop@4:
    // smart_contracts/proposal/contract.py:713
    // @arc4.abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

drop_after_if_else@3:
    // smart_contracts/proposal/contract.py:728
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:727-729
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:731
    // del self.metadata.value
    bytec 9 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:732
    // self.finalized.value = True
    bytec_2 // 0x66696e616c697a6564
    intc_1 // 1
    app_global_put
    // smart_contracts/proposal/contract.py:734
    // return typ.Error("")
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:713
    // @arc4.abimethod()
    b drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop@4

drop_after_if_else@8:
    // smart_contracts/proposal/contract.py:355
    // return typ.Error("")
    bytec_1 // ""
    bury 1
    // smart_contracts/proposal/contract.py:723
    // error = self.drop_check_authorization()
    b drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@9


// smart_contracts.proposal.contract.Proposal.submit[routing]() -> void:
submit:
    // smart_contracts/proposal/contract.py:438
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    bytec 31 // 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:437-439
    // registry_paused = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:440
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/proposal/contract.py:345
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:346
    // elapsed_discussion_duration = Global.latest_timestamp - self.open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 27 // 0x6f70656e5f74696d657374616d70
    app_global_get_ex
    assert // check self.open_ts exists
    -
    // smart_contracts/proposal/contract.py:348
    // elapsed_discussion_duration >= self.discussion_duration.value
    intc_0 // 0
    bytec 36 // 0x64697363757373696f6e5f6475726174696f6e
    app_global_get_ex
    assert // check self.discussion_duration exists
    >=
    // smart_contracts/proposal/contract.py:347-349
    // assert (
    //     elapsed_discussion_duration >= self.discussion_duration.value
    // ), err.TOO_EARLY
    assert // Too early
    // smart_contracts/proposal/contract.py:752
    // assert self.metadata_uploaded.value, err.MISSING_METADATA
    intc_0 // 0
    bytec 33 // 0x6d657461646174615f75706c6f61646564
    app_global_get_ex
    assert // check self.metadata_uploaded exists
    assert // Missing Metadata
    // smart_contracts/proposal/contract.py:756
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    bytec 39 // 0x78676f765f6461656d6f6e
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:755-757
    // receiver=Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    // ),
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:759
    // self.open_proposal_fee.value, self.daemon_ops_funding_bps.value
    intc_0 // 0
    bytec 25 // 0x6f70656e5f70726f706f73616c5f666565
    app_global_get_ex
    assert // check self.open_proposal_fee exists
    intc_0 // 0
    bytec 26 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    app_global_get_ex
    assert // check self.daemon_ops_funding_bps exists
    // smart_contracts/proposal/contract.py:400
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:754-761
    // self.pay(
    //     receiver=Account(
    //         self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    //     ),
    //     amount=self.relative_to_absolute_amount(
    //         self.open_proposal_fee.value, self.daemon_ops_funding_bps.value
    //     ),
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:762
    // self.status.value = UInt64(enm.STATUS_SUBMITTED)
    bytec_0 // 0x737461747573
    pushint 20
    app_global_put
    // smart_contracts/proposal/contract.py:763
    // self.submission_ts.value = Global.latest_timestamp
    bytec 32 // 0x7375626d697373696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:736
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.assign_voters[routing]() -> void:
assign_voters:
    bytec_1 // ""
    dup
    // smart_contracts/proposal/contract.py:777
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    pushint 40
    *
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts.common.abi_types.CommitteeMember>
    // smart_contracts/proposal/contract.py:301
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:302
    // assert self.status.value == enm.STATUS_SUBMITTED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 20
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:802
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz assign_voters_else_body@7
    // smart_contracts/proposal/contract.py:803-804
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    bury 3
    intc_1 // 1
    bury 4

assign_voters_for_header@3:
    // smart_contracts/proposal/contract.py:803-804
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    dig 3
    dig 3
    <
    bz assign_voters_after_if_else@8
    // smart_contracts/proposal/contract.py:805
    // self.assert_same_app_and_method(i)
    dig 3
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:803-804
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    bury 4
    b assign_voters_for_header@3

assign_voters_after_if_else@8:
    // smart_contracts/proposal/contract.py:810
    // for i in urange(voters.length):
    intc_0 // 0
    bury 4

assign_voters_for_header@9:
    // smart_contracts/proposal/contract.py:810
    // for i in urange(voters.length):
    dig 3
    dig 1
    <
    bz assign_voters_after_for@12
    // smart_contracts/proposal/contract.py:811
    // self._assign_voter(voters[i].address, voters[i].voting_power)
    dig 1
    extract 2 0
    dig 4
    dup
    cover 2
    pushint 40
    *
    pushint 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    swap
    intc_2 // 32
    extract_uint64
    // smart_contracts/proposal/contract.py:307
    // assert voter not in self.voters, err.VOTER_ALREADY_ASSIGNED
    bytec 18 // "V"
    uncover 2
    concat
    dup
    box_len
    bury 1
    !
    assert // Voter Already Assigned
    // smart_contracts/proposal/contract.py:308
    // assert voting_power > 0, err.INVALID_VOTING_POWER
    dig 1
    assert // Invalid Voting Power
    // smart_contracts/proposal/contract.py:768
    // self.voters[voter] = voting_power
    dig 1
    itob
    box_put
    // smart_contracts/proposal/contract.py:769
    // self.assigned_members.value += 1
    intc_0 // 0
    bytec 5 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    intc_1 // 1
    +
    bytec 5 // 0x61737369676e65645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:770
    // self.assigned_votes.value += voting_power
    intc_0 // 0
    bytec 17 // 0x61737369676e65645f766f746573
    app_global_get_ex
    assert // check self.assigned_votes exists
    +
    bytec 17 // 0x61737369676e65645f766f746573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:810
    // for i in urange(voters.length):
    intc_1 // 1
    +
    bury 4
    b assign_voters_for_header@9

assign_voters_after_for@12:
    // smart_contracts/proposal/contract.py:813
    // if self.assigned_members.value == self.committee_members.value:
    intc_0 // 0
    bytec 5 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    intc_0 // 0
    bytec 11 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    bz assign_voters_after_if_else@14
    // smart_contracts/proposal/contract.py:815
    // self.assigned_votes.value == self.committee_votes.value
    intc_0 // 0
    bytec 17 // 0x61737369676e65645f766f746573
    app_global_get_ex
    assert // check self.assigned_votes exists
    intc_0 // 0
    bytec 15 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    ==
    // smart_contracts/proposal/contract.py:814-816
    // assert (
    //     self.assigned_votes.value == self.committee_votes.value
    // ), err.VOTING_POWER_MISMATCH
    assert // Voting Power Mismatch
    // smart_contracts/proposal/contract.py:817
    // self.status.value = UInt64(enm.STATUS_VOTING)
    bytec_0 // 0x737461747573
    pushint 25
    app_global_put
    // smart_contracts/proposal/contract.py:818
    // self.vote_open_ts.value = Global.latest_timestamp
    global LatestTimestamp
    bytec 28 // 0x766f74655f6f70656e696e675f74696d657374616d70
    dig 1
    app_global_put
    // smart_contracts/proposal/contract.py:823
    // vote_closing=self.vote_open_ts.value + self.voting_duration.value,
    intc_0 // 0
    bytec 30 // 0x766f74696e675f6475726174696f6e
    app_global_get_ex
    assert // check self.voting_duration exists
    dig 1
    +
    // smart_contracts/proposal/contract.py:824
    // quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    intc_0 // 0
    bytec 21 // 0x71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.quorum_threshold exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:826
    // self.weighted_quorum_threshold.value
    intc_0 // 0
    bytec 22 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.weighted_quorum_threshold exists
    // smart_contracts/proposal/contract.py:825-827
    // weighted_quorum_votes=arc4.UInt32(
    //     self.weighted_quorum_threshold.value
    // ),
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:821-828
    // typ.Submitted(
    //     vote_opening=self.vote_open_ts.value,
    //     vote_closing=self.vote_open_ts.value + self.voting_duration.value,
    //     quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    //     weighted_quorum_votes=arc4.UInt32(
    //         self.weighted_quorum_threshold.value
    //     ),
    // )
    uncover 3
    itob
    uncover 3
    itob
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:820-829
    // arc4.emit(
    //     typ.Submitted(
    //         vote_opening=self.vote_open_ts.value,
    //         vote_closing=self.vote_open_ts.value + self.voting_duration.value,
    //         quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    //         weighted_quorum_votes=arc4.UInt32(
    //             self.weighted_quorum_threshold.value
    //         ),
    //     )
    // )
    pushbytes 0x980fd5de // method "Submitted(uint64,uint64,uint32,uint32)"
    swap
    concat
    log

assign_voters_after_if_else@14:
    // smart_contracts/proposal/contract.py:777
    // @arc4.abimethod()
    intc_1 // 1
    return

assign_voters_else_body@7:
    // smart_contracts/proposal/contract.py:807-808
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b assign_voters_after_if_else@8


// smart_contracts.proposal.contract.Proposal.vote[routing]() -> void:
vote:
    intc_0 // 0
    dup
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:831
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/proposal/contract.py:262
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:264
    // if self.status.value != enm.STATUS_VOTING:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25
    !=
    bz vote_after_if_else@20
    // smart_contracts/proposal/contract.py:265
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 23 // "ERR:Wrong Proposal Status or finalized"
    bury 5

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@23:
    // smart_contracts/proposal/contract.py:854
    // if error != typ.Error(""):
    dig 4
    bytec_1 // ""
    !=
    bz vote_after_if_else@3
    dig 4

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@10:
    // smart_contracts/proposal/contract.py:831
    // @arc4.abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

vote_after_if_else@3:
    // smart_contracts/proposal/contract.py:278
    // if voter not in self.voters:
    bytec 18 // "V"
    dig 3
    concat
    dup
    bury 7
    box_len
    bury 1
    bnz vote_after_if_else@13
    // smart_contracts/proposal/contract.py:279
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_NOT_FOUND)
    bytec 40 // "ERR:Voter not found"
    bury 5

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@17:
    // smart_contracts/proposal/contract.py:858
    // if error == typ.Error(""):
    dig 4
    bytec_1 // ""
    ==
    bz vote_else_body@8
    // smart_contracts/proposal/contract.py:859
    // votes = self.voters[voter]
    dig 5
    box_get
    assert // check self.voters entry exists
    btoi
    dup
    bury 5
    // smart_contracts/proposal/contract.py:861
    // self.voted_members.value += 1
    intc_0 // 0
    bytec 6 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_1 // 1
    +
    bytec 6 // 0x766f7465645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:862
    // if self.is_boycott(votes, approvals, rejections):
    dig 2
    dig 2
    callsub is_boycott
    bz vote_else_body@6
    // smart_contracts/proposal/contract.py:863
    // self.boycotted_members.value += 1
    intc_0 // 0
    bytec 13 // 0x626f79636f747465645f6d656d62657273
    app_global_get_ex
    assert // check self.boycotted_members exists
    intc_1 // 1
    +
    bytec 13 // 0x626f79636f747465645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:866
    // nulls = UInt64(0)
    intc_0 // 0
    // smart_contracts/proposal/contract.py:864
    // boycotted = True
    intc_1 // 1

vote_after_if_else@7:
    // smart_contracts/proposal/contract.py:878
    // self._unassign_voter(voter, votes)
    dig 4
    dig 6
    callsub _unassign_voter
    // smart_contracts/proposal/contract.py:883
    // self.voters.box(voter).key[1:]
    dig 7
    dup
    len
    intc_1 // 1
    dig 1
    >=
    intc_1 // 1
    dig 2
    uncover 2
    select
    swap
    substring3
    // smart_contracts/proposal/contract.py:882-884
    // xgov=arc4.Address(
    //     self.voters.box(voter).key[1:]
    // ),  # remove the Box prefix
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:885
    // approvals=arc4.UInt32(approvals),
    dig 4
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:886
    // rejections=arc4.UInt32(rejections),
    dig 4
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:887
    // nulls=arc4.UInt32(nulls),
    uncover 4
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:889
    // total_voters=arc4.UInt32(self.voted_members.value),
    intc_0 // 0
    bytec 6 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:890
    // total_boycott=arc4.UInt32(self.boycotted_members.value),
    intc_0 // 0
    bytec 13 // 0x626f79636f747465645f6d656d62657273
    app_global_get_ex
    assert // check self.boycotted_members exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:891
    // total_approvals=arc4.UInt32(self.approvals.value),
    intc_0 // 0
    bytec 7 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:892
    // total_rejections=arc4.UInt32(self.rejections.value),
    intc_0 // 0
    bytec 8 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:893
    // total_nulls=arc4.UInt32(self.nulls.value),
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:881-894
    // typ.Vote(
    //     xgov=arc4.Address(
    //         self.voters.box(voter).key[1:]
    //     ),  # remove the Box prefix
    //     approvals=arc4.UInt32(approvals),
    //     rejections=arc4.UInt32(rejections),
    //     nulls=arc4.UInt32(nulls),
    //     boycotted=boycotted,
    //     total_voters=arc4.UInt32(self.voted_members.value),
    //     total_boycott=arc4.UInt32(self.boycotted_members.value),
    //     total_approvals=arc4.UInt32(self.approvals.value),
    //     total_rejections=arc4.UInt32(self.rejections.value),
    //     total_nulls=arc4.UInt32(self.nulls.value),
    // )
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    bytec 19 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:880-895
    // arc4.emit(
    //     typ.Vote(
    //         xgov=arc4.Address(
    //             self.voters.box(voter).key[1:]
    //         ),  # remove the Box prefix
    //         approvals=arc4.UInt32(approvals),
    //         rejections=arc4.UInt32(rejections),
    //         nulls=arc4.UInt32(nulls),
    //         boycotted=boycotted,
    //         total_voters=arc4.UInt32(self.voted_members.value),
    //         total_boycott=arc4.UInt32(self.boycotted_members.value),
    //         total_approvals=arc4.UInt32(self.approvals.value),
    //         total_rejections=arc4.UInt32(self.rejections.value),
    //         total_nulls=arc4.UInt32(self.nulls.value),
    //     )
    // )
    pushbytes 0x5ef0d3f1 // method "Vote(address,uint32,uint32,uint32,bool,uint32,uint32,uint32,uint32,uint32)"
    swap
    concat
    log
    // smart_contracts/proposal/contract.py:897
    // return typ.Error("")
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:831
    // @arc4.abimethod()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@10

vote_else_body@6:
    // smart_contracts/proposal/contract.py:868
    // boycotted = False
    intc_0 // 0
    // smart_contracts/proposal/contract.py:870
    // nulls = votes - approvals - rejections
    dig 4
    dig 3
    dup
    cover 2
    -
    dig 3
    dup
    cover 3
    -
    dup
    cover 3
    cover 4
    // smart_contracts/proposal/contract.py:872
    // self.approvals.value += approvals
    intc_0 // 0
    bytec 7 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    +
    bytec 7 // 0x617070726f76616c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:873
    // self.rejections.value += rejections
    intc_0 // 0
    bytec 8 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    +
    bytec 8 // 0x72656a656374696f6e73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:874
    // self.nulls.value += nulls
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    bytec 14 // 0x6e756c6c73
    swap
    app_global_put
    b vote_after_if_else@7

vote_else_body@8:
    dig 4
    // smart_contracts/proposal/contract.py:831
    // @arc4.abimethod()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@10

vote_after_if_else@13:
    // smart_contracts/proposal/contract.py:281
    // votes = self.voters[voter]
    dig 5
    box_get
    assert // check self.voters entry exists
    btoi
    dup
    bury 5
    // smart_contracts/proposal/contract.py:283
    // if (approvals + rejections > votes) and not self.is_boycott(
    dig 2
    dig 2
    +
    <
    // smart_contracts/proposal/contract.py:283-285
    // if (approvals + rejections > votes) and not self.is_boycott(
    //     votes, approvals, rejections
    // ):
    bz vote_after_if_else@16
    dig 3
    dig 2
    dig 2
    callsub is_boycott
    bnz vote_after_if_else@16
    // smart_contracts/proposal/contract.py:286
    // return typ.Error(err.ARC_65_PREFIX + err.VOTES_INVALID)
    pushbytes "ERR:Votes invalid"
    bury 5
    // smart_contracts/proposal/contract.py:857
    // error = self.vote_input_validation(voter, approvals, rejections)
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@17

vote_after_if_else@16:
    // smart_contracts/proposal/contract.py:288
    // return typ.Error("")
    bytec_1 // ""
    bury 5
    // smart_contracts/proposal/contract.py:857
    // error = self.vote_input_validation(voter, approvals, rejections)
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@17

vote_after_if_else@20:
    // smart_contracts/proposal/contract.py:267
    // if not self.is_voting_open():
    callsub is_voting_open
    bnz vote_after_if_else@22
    // smart_contracts/proposal/contract.py:268
    // return typ.Error(err.ARC_65_PREFIX + err.VOTING_PERIOD_EXPIRED)
    pushbytes "ERR:Voting Period Expired"
    bury 5
    // smart_contracts/proposal/contract.py:853
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@23

vote_after_if_else@22:
    // smart_contracts/proposal/contract.py:270
    // return typ.Error("")
    bytec_1 // ""
    bury 5
    // smart_contracts/proposal/contract.py:853
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@23


// smart_contracts.proposal.contract.Proposal.scrutiny[routing]() -> void:
scrutiny:
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:438
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    bytec 31 // 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:437-439
    // registry_paused = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:440
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/proposal/contract.py:294
    // assert self.status.value == enm.STATUS_VOTING, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:296
    // not self.is_voting_open()  # voting period has ended
    callsub is_voting_open
    bz scrutiny_bool_true@7
    // smart_contracts/proposal/contract.py:297
    // or self.is_plebiscite()  # all committee members already voted
    callsub is_plebiscite
    // smart_contracts/proposal/contract.py:296-297
    // not self.is_voting_open()  # voting period has ended
    // or self.is_plebiscite()  # all committee members already voted
    bz scrutiny_bool_false@8

scrutiny_bool_true@7:
    intc_1 // 1

scrutiny_bool_merge@9:
    // smart_contracts/proposal/contract.py:295-298
    // assert (
    //     not self.is_voting_open()  # voting period has ended
    //     or self.is_plebiscite()  # all committee members already voted
    // ), err.VOTING_ONGOING
    assert // Voting Ongoing
    // smart_contracts/proposal/contract.py:564
    // self.is_quorum_voters_reached()
    callsub is_quorum_voters_reached
    // smart_contracts/proposal/contract.py:564-566
    // self.is_quorum_voters_reached()
    // and self.is_weighted_quorum_votes_reached()
    // and self.has_majority_approved()
    bz scrutiny_bool_false@15
    // smart_contracts/proposal/contract.py:565
    // and self.is_weighted_quorum_votes_reached()
    callsub is_weighted_quorum_votes_reached
    // smart_contracts/proposal/contract.py:564-566
    // self.is_quorum_voters_reached()
    // and self.is_weighted_quorum_votes_reached()
    // and self.has_majority_approved()
    bz scrutiny_bool_false@15
    // smart_contracts/proposal/contract.py:566
    // and self.has_majority_approved()
    callsub has_majority_approved
    // smart_contracts/proposal/contract.py:564-566
    // self.is_quorum_voters_reached()
    // and self.is_weighted_quorum_votes_reached()
    // and self.has_majority_approved()
    bz scrutiny_bool_false@15
    intc_1 // 1
    bury 1

scrutiny_bool_merge@16:
    // smart_contracts/proposal/contract.py:916
    // if is_approved:
    dup
    bz scrutiny_else_body@3
    // smart_contracts/proposal/contract.py:917
    // self.status.value = UInt64(enm.STATUS_APPROVED)
    bytec_0 // 0x737461747573
    pushint 30
    app_global_put

scrutiny_after_if_else@4:
    // smart_contracts/proposal/contract.py:927
    // plebiscite=self.is_plebiscite(),
    callsub is_plebiscite
    // smart_contracts/proposal/contract.py:925-928
    // typ.Scrutiny(
    //     approved=is_approved,
    //     plebiscite=self.is_plebiscite(),
    // )
    bytec 19 // 0x00
    intc_0 // 0
    dig 3
    setbit
    intc_1 // 1
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:924-929
    // arc4.emit(
    //     typ.Scrutiny(
    //         approved=is_approved,
    //         plebiscite=self.is_plebiscite(),
    //     )
    // )
    pushbytes 0x2bd99ae4 // method "Scrutiny(bool,bool)"
    swap
    concat
    log
    // smart_contracts/proposal/contract.py:899
    // @arc4.abimethod()
    intc_1 // 1
    return

scrutiny_else_body@3:
    // smart_contracts/proposal/contract.py:919
    // self.status.value = UInt64(enm.STATUS_REJECTED)
    bytec_0 // 0x737461747573
    pushint 40
    app_global_put
    // smart_contracts/proposal/contract.py:921
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:920-922
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    b scrutiny_after_if_else@4

scrutiny_bool_false@15:
    intc_0 // 0
    bury 1
    b scrutiny_bool_merge@16

scrutiny_bool_false@8:
    intc_0 // 0
    b scrutiny_bool_merge@9


// smart_contracts.proposal.contract.Proposal.unassign_absentees[routing]() -> void:
unassign_absentees:
    intc_0 // 0
    dupn 2
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:931
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 32
    *
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<account>
    // smart_contracts/proposal/contract.py:231
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:234
    // self.status.value == enm.STATUS_APPROVED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 30
    ==
    // smart_contracts/proposal/contract.py:234-235
    // self.status.value == enm.STATUS_APPROVED
    // or self.status.value == enm.STATUS_REJECTED
    bnz unassign_absentees_and_contd@13
    // smart_contracts/proposal/contract.py:235
    // or self.status.value == enm.STATUS_REJECTED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40
    ==
    // smart_contracts/proposal/contract.py:234-235
    // self.status.value == enm.STATUS_APPROVED
    // or self.status.value == enm.STATUS_REJECTED
    bz unassign_absentees_if_body@14

unassign_absentees_and_contd@13:
    // smart_contracts/proposal/contract.py:237
    // and not self.finalized.value
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bz unassign_absentees_after_if_else@15

unassign_absentees_if_body@14:
    // smart_contracts/proposal/contract.py:239
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 23 // "ERR:Wrong Proposal Status or finalized"
    bury 4

unassign_absentees_after_inlined_smart_contracts.proposal.contract.Proposal.unassign_absentees_check_authorization@16:
    // smart_contracts/proposal/contract.py:945
    // if error != typ.Error(""):
    dig 3
    bytec_1 // ""
    !=
    bz unassign_absentees_after_if_else@3
    dig 3

unassign_absentees_after_inlined_smart_contracts.proposal.contract.Proposal.unassign_absentees@10:
    // smart_contracts/proposal/contract.py:931
    // @arc4.abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

unassign_absentees_after_if_else@3:
    intc_0 // 0
    bury 3

unassign_absentees_for_header@4:
    // smart_contracts/proposal/contract.py:948-949
    // # remove absentee
    // for absentee in absentees:
    dig 2
    dig 1
    <
    bz unassign_absentees_after_for@9
    dig 1
    extract 2 0
    dig 3
    intc_2 // 32
    *
    intc_2 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 7
    // smart_contracts/proposal/contract.py:950
    // if absentee not in self.voters:
    bytec 18 // "V"
    swap
    concat
    dup
    bury 6
    box_len
    bury 1
    bnz unassign_absentees_after_if_else@7
    // smart_contracts/proposal/contract.py:951
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_NOT_FOUND)
    bytec 40 // "ERR:Voter not found"
    // smart_contracts/proposal/contract.py:931
    // @arc4.abimethod()
    b unassign_absentees_after_inlined_smart_contracts.proposal.contract.Proposal.unassign_absentees@10

unassign_absentees_after_if_else@7:
    // smart_contracts/proposal/contract.py:952
    // votes = self.voters[absentee]
    dig 4
    box_get
    assert // check self.voters entry exists
    btoi
    // smart_contracts/proposal/contract.py:953
    // self._unassign_voter(absentee, votes)
    dig 6
    swap
    callsub _unassign_voter
    dig 2
    intc_1 // 1
    +
    bury 3
    b unassign_absentees_for_header@4

unassign_absentees_after_for@9:
    // smart_contracts/proposal/contract.py:955
    // return typ.Error("")
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:931
    // @arc4.abimethod()
    b unassign_absentees_after_inlined_smart_contracts.proposal.contract.Proposal.unassign_absentees@10

unassign_absentees_after_if_else@15:
    // smart_contracts/proposal/contract.py:241
    // return typ.Error("")
    bytec_1 // ""
    bury 4
    // smart_contracts/proposal/contract.py:944
    // error = self.unassign_absentees_check_authorization()
    b unassign_absentees_after_inlined_smart_contracts.proposal.contract.Proposal.unassign_absentees_check_authorization@16


// smart_contracts.proposal.contract.Proposal.review[routing]() -> void:
review:
    // smart_contracts/proposal/contract.py:957
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    dup
    // smart_contracts/proposal/contract.py:449
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:450
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    pushbytes 0x78676f765f636f756e63696c
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:449-451
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    // )
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    ==
    // smart_contracts/proposal/contract.py:216
    // assert self.is_council(), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:217
    // assert self.status.value == enm.STATUS_APPROVED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 30
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:973-974
    // # check no assigned voters
    // assert self.assigned_members.value == 0, err.VOTERS_ASSIGNED
    intc_0 // 0
    bytec 5 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    !
    assert // There are voters assigned to this proposal
    // smart_contracts/proposal/contract.py:976
    // if block:
    bz review_else_body@3
    // smart_contracts/proposal/contract.py:977
    // self.status.value = UInt64(enm.STATUS_BLOCKED)
    bytec_0 // 0x737461747573
    pushint 60
    app_global_put
    // smart_contracts/proposal/contract.py:979-980
    // # slashing: send locked amount to the registry treasury
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:982
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:981-983
    // self.transfer_locked_amount(
    //     receiver=reg_app.address,
    // )
    callsub transfer_locked_amount

review_after_if_else@4:
    // smart_contracts/proposal/contract.py:993
    // arc4.emit(typ.Review(veto=block))
    bytec 19 // 0x00
    intc_0 // 0
    dig 2
    setbit
    pushbytes 0xd9939644 // method "Review(bool)"
    swap
    concat
    log
    // smart_contracts/proposal/contract.py:957
    // @arc4.abimethod()
    intc_1 // 1
    return

review_else_body@3:
    // smart_contracts/proposal/contract.py:986
    // self.status.value = UInt64(enm.STATUS_REVIEWED)
    bytec_0 // 0x737461747573
    pushint 45
    app_global_put
    // smart_contracts/proposal/contract.py:990
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:988-991
    // # refund the locked amount to the proposer
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    b review_after_if_else@4


// smart_contracts.proposal.contract.Proposal.fund[routing]() -> void:
fund:
    intc_0 // 0
    // smart_contracts/proposal/contract.py:220
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:221
    // if self.status.value != enm.STATUS_REVIEWED:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 45
    !=
    bz fund_after_if_else@7
    // smart_contracts/proposal/contract.py:222
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 23 // "ERR:Wrong Proposal Status or finalized"
    bury 1

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@8:
    // smart_contracts/proposal/contract.py:1005
    // if error != typ.Error(""):
    dup
    bytec_1 // ""
    !=
    bz fund_after_if_else@3
    dup

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund@4:
    // smart_contracts/proposal/contract.py:995
    // @arc4.abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

fund_after_if_else@3:
    // smart_contracts/proposal/contract.py:1008
    // self.status.value = UInt64(enm.STATUS_FUNDED)
    bytec_0 // 0x737461747573
    pushint 50
    app_global_put
    // smart_contracts/proposal/contract.py:1010
    // return typ.Error("")
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:995
    // @arc4.abimethod()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund@4

fund_after_if_else@7:
    // smart_contracts/proposal/contract.py:224
    // return typ.Error("")
    bytec_1 // ""
    bury 1
    // smart_contracts/proposal/contract.py:1004
    // error = self.fund_check_authorization()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@8


// smart_contracts.proposal.contract.Proposal.unassign_voters[routing]() -> void:
unassign_voters:
    intc_0 // 0
    dup
    bytec_1 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:1012
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 32
    *
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<account>
    // smart_contracts/proposal/contract.py:227
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:228
    // assert self.status.value == enm.STATUS_SUBMITTED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 20
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:1028
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz unassign_voters_else_body@7
    // smart_contracts/proposal/contract.py:1029-1030
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    bury 3
    intc_1 // 1
    bury 5

unassign_voters_for_header@3:
    // smart_contracts/proposal/contract.py:1029-1030
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    dig 4
    dig 3
    <
    bz unassign_voters_after_if_else@8
    // smart_contracts/proposal/contract.py:1031
    // self.assert_same_app_and_method(i)
    dig 4
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:1029-1030
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    bury 5
    b unassign_voters_for_header@3

unassign_voters_after_if_else@8:
    intc_0 // 0
    bury 4

unassign_voters_for_header@9:
    // smart_contracts/proposal/contract.py:1036-1037
    // # remove voters
    // for voter in voters:
    dig 3
    dig 1
    <
    bz unassign_voters_after_for@14
    dig 1
    extract 2 0
    dig 4
    intc_2 // 32
    *
    intc_2 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 7
    // smart_contracts/proposal/contract.py:1038
    // if voter in self.voters:
    bytec 18 // "V"
    swap
    concat
    dup
    bury 8
    box_len
    bury 1
    bz unassign_voters_after_if_else@12
    // smart_contracts/proposal/contract.py:1039
    // votes = self.voters[voter]
    dig 6
    box_get
    assert // check self.voters entry exists
    btoi
    // smart_contracts/proposal/contract.py:1040
    // self._unassign_voter(voter, votes)
    dig 6
    swap
    callsub _unassign_voter

unassign_voters_after_if_else@12:
    dig 3
    intc_1 // 1
    +
    bury 4
    b unassign_voters_for_header@9

unassign_voters_after_for@14:
    // smart_contracts/proposal/contract.py:1012
    // @arc4.abimethod()
    intc_1 // 1
    return

unassign_voters_else_body@7:
    // smart_contracts/proposal/contract.py:1033-1034
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b unassign_voters_after_if_else@8


// smart_contracts.proposal.contract.Proposal.finalize[routing]() -> void:
finalize:
    intc_0 // 0
    // smart_contracts/proposal/contract.py:244
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:246
    // if self.finalized.value or (
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    // smart_contracts/proposal/contract.py:246-252
    // if self.finalized.value or (
    //     self.status.value != enm.STATUS_EMPTY
    //     and self.status.value != enm.STATUS_DRAFT
    //     and self.status.value != enm.STATUS_FUNDED
    //     and self.status.value != enm.STATUS_BLOCKED
    //     and self.status.value != enm.STATUS_REJECTED
    // ):
    bnz finalize_if_body@15
    // smart_contracts/proposal/contract.py:247
    // self.status.value != enm.STATUS_EMPTY
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    // smart_contracts/proposal/contract.py:247-251
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:248
    // and self.status.value != enm.STATUS_DRAFT
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 10
    !=
    // smart_contracts/proposal/contract.py:247-251
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:249
    // and self.status.value != enm.STATUS_FUNDED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50
    !=
    // smart_contracts/proposal/contract.py:247-251
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:250
    // and self.status.value != enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60
    !=
    // smart_contracts/proposal/contract.py:247-251
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:251
    // and self.status.value != enm.STATUS_REJECTED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40
    !=
    // smart_contracts/proposal/contract.py:247-251
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16

finalize_if_body@15:
    // smart_contracts/proposal/contract.py:253
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 23 // "ERR:Wrong Proposal Status or finalized"
    bury 1

finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize_check_authorization@17:
    // smart_contracts/proposal/contract.py:1054
    // if error != typ.Error(""):
    dup
    bytec_1 // ""
    !=
    bz finalize_after_if_else@3
    dup

finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8:
    // smart_contracts/proposal/contract.py:1042
    // @arc4.abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

finalize_after_if_else@3:
    // smart_contracts/proposal/contract.py:1057-1058
    // # check no assigned voters
    // if self.assigned_members.value > 0:
    intc_0 // 0
    bytec 5 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    bz finalize_after_if_else@5
    // smart_contracts/proposal/contract.py:1059
    // return typ.Error(err.ARC_65_PREFIX + err.VOTERS_ASSIGNED)
    pushbytes "ERR:There are voters assigned to this proposal"
    // smart_contracts/proposal/contract.py:1042
    // @arc4.abimethod()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8

finalize_after_if_else@5:
    // smart_contracts/proposal/contract.py:1061-1064
    // # refund the locked amount for DRAFT proposals
    // # for REJECTED proposals, the locked amount is already refunded in the scrutiny method
    // # for EMPTY, FUNDED, or BLOCKED proposals, the locked amount is not refundable
    // if self.status.value == enm.STATUS_DRAFT:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 10
    ==
    bz finalize_after_if_else@7
    // smart_contracts/proposal/contract.py:1066
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:1065-1067
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount

finalize_after_if_else@7:
    // smart_contracts/proposal/contract.py:1068
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:1070
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:1071
    // amount=Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:1072
    // - Global.current_application_address.min_balance,
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:1071-1072
    // amount=Global.current_application_address.balance
    // - Global.current_application_address.min_balance,
    -
    // smart_contracts/proposal/contract.py:1069-1073
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance
    //     - Global.current_application_address.min_balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:1074
    // self.finalized.value = True
    bytec_2 // 0x66696e616c697a6564
    intc_1 // 1
    app_global_put
    // smart_contracts/proposal/contract.py:1076
    // return typ.Error("")
    bytec_1 // ""
    // smart_contracts/proposal/contract.py:1042
    // @arc4.abimethod()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8

finalize_after_if_else@16:
    // smart_contracts/proposal/contract.py:255
    // return typ.Error("")
    bytec_1 // ""
    bury 1
    // smart_contracts/proposal/contract.py:1053
    // error = self.finalize_check_authorization()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize_check_authorization@17


// smart_contracts.proposal.contract.Proposal.delete[routing]() -> void:
delete:
    // smart_contracts/proposal/contract.py:258
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:259
    // assert self.finalized.value, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:1090-1091
    // # delete metadata box if it exists
    // del self.metadata.value
    bytec 9 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:1093
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:1095
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:1096
    // amount=Global.current_application_address.balance,
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:1094-1097
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:1078
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.get_state[routing]() -> void:
get_state:
    // smart_contracts/proposal/contract.py:1108
    // proposer=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:1109
    // registry_app_id=self.registry_app_id.value,
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:1110
    // title=self.title.value,
    intc_0 // 0
    bytec 34 // 0x7469746c65
    app_global_get_ex
    assert // check self.title exists
    // smart_contracts/proposal/contract.py:1111
    // open_ts=self.open_ts.value,
    intc_0 // 0
    bytec 27 // 0x6f70656e5f74696d657374616d70
    app_global_get_ex
    assert // check self.open_ts exists
    // smart_contracts/proposal/contract.py:1112
    // submission_ts=self.submission_ts.value,
    intc_0 // 0
    bytec 32 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    // smart_contracts/proposal/contract.py:1113
    // vote_open_ts=self.vote_open_ts.value,
    intc_0 // 0
    bytec 28 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    // smart_contracts/proposal/contract.py:1114
    // status=self.status.value,
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    // smart_contracts/proposal/contract.py:1115
    // finalized=self.finalized.value,
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    // smart_contracts/proposal/contract.py:1116
    // funding_category=self.funding_category.value,
    intc_0 // 0
    bytec 16 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:1117
    // focus=arc4.UInt8(self.focus.value),
    intc_0 // 0
    bytec 35 // 0x666f637573
    app_global_get_ex
    assert // check self.focus exists
    itob
    dup
    bitlen
    pushint 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:1118
    // funding_type=self.funding_type.value,
    intc_0 // 0
    bytec 29 // 0x66756e64696e675f74797065
    app_global_get_ex
    assert // check self.funding_type exists
    // smart_contracts/proposal/contract.py:1119
    // requested_amount=self.requested_amount.value,
    intc_0 // 0
    bytec 12 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    // smart_contracts/proposal/contract.py:1120
    // locked_amount=self.locked_amount.value,
    intc_0 // 0
    bytec 20 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    // smart_contracts/proposal/contract.py:1121
    // committee_id=self.committee_id.value.copy(),
    intc_0 // 0
    bytec 24 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    // smart_contracts/proposal/contract.py:1122
    // committee_members=self.committee_members.value,
    intc_0 // 0
    bytec 11 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:1123
    // committee_votes=self.committee_votes.value,
    intc_0 // 0
    bytec 15 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/proposal/contract.py:1124
    // voted_members=self.voted_members.value,
    intc_0 // 0
    bytec 6 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    // smart_contracts/proposal/contract.py:1125
    // boycotted_members=self.boycotted_members.value,
    intc_0 // 0
    bytec 13 // 0x626f79636f747465645f6d656d62657273
    app_global_get_ex
    assert // check self.boycotted_members exists
    // smart_contracts/proposal/contract.py:1126
    // approvals=self.approvals.value,
    intc_0 // 0
    bytec 7 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    // smart_contracts/proposal/contract.py:1127
    // rejections=self.rejections.value,
    intc_0 // 0
    bytec 8 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    // smart_contracts/proposal/contract.py:1128
    // nulls=self.nulls.value,
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    // smart_contracts/proposal/contract.py:1107-1129
    // return typ.ProposalTypedGlobalState(
    //     proposer=self.proposer.value,
    //     registry_app_id=self.registry_app_id.value,
    //     title=self.title.value,
    //     open_ts=self.open_ts.value,
    //     submission_ts=self.submission_ts.value,
    //     vote_open_ts=self.vote_open_ts.value,
    //     status=self.status.value,
    //     finalized=self.finalized.value,
    //     funding_category=self.funding_category.value,
    //     focus=arc4.UInt8(self.focus.value),
    //     funding_type=self.funding_type.value,
    //     requested_amount=self.requested_amount.value,
    //     locked_amount=self.locked_amount.value,
    //     committee_id=self.committee_id.value.copy(),
    //     committee_members=self.committee_members.value,
    //     committee_votes=self.committee_votes.value,
    //     voted_members=self.voted_members.value,
    //     boycotted_members=self.boycotted_members.value,
    //     approvals=self.approvals.value,
    //     rejections=self.rejections.value,
    //     nulls=self.nulls.value,
    // )
    uncover 19
    itob
    uncover 20
    swap
    concat
    dig 19
    len
    itob
    extract 6 2
    uncover 20
    concat
    swap
    pushbytes 0x00c4
    concat
    uncover 19
    itob
    concat
    uncover 18
    itob
    concat
    uncover 17
    itob
    concat
    uncover 16
    itob
    concat
    bytec 19 // 0x00
    intc_0 // 0
    uncover 17
    setbit
    concat
    uncover 14
    itob
    concat
    uncover 13
    concat
    uncover 12
    itob
    concat
    uncover 11
    itob
    concat
    uncover 10
    itob
    concat
    uncover 9
    concat
    uncover 8
    itob
    concat
    uncover 7
    itob
    concat
    uncover 6
    itob
    concat
    uncover 5
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:1099
    // @arc4.abimethod(readonly=True)
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.get_voter_box[routing]() -> void:
get_voter_box:
    // smart_contracts/proposal/contract.py:1131
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/proposal/contract.py:1143
    // exists = voter_address in self.voters
    bytec 18 // "V"
    swap
    concat
    dup
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/proposal/contract.py:1144
    // if exists:
    bz get_voter_box_else_body@3
    // smart_contracts/proposal/contract.py:1145
    // votes = self.voters[voter_address]
    dig 1
    box_get
    assert // check self.voters entry exists
    btoi

get_voter_box_after_if_else@4:
    // smart_contracts/proposal/contract.py:1131
    // @arc4.abimethod(readonly=True)
    itob
    bytec 19 // 0x00
    intc_0 // 0
    dig 3
    setbit
    concat
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_voter_box_else_body@3:
    // smart_contracts/proposal/contract.py:1147
    // votes = UInt64(0)
    intc_0 // 0
    b get_voter_box_after_if_else@4


// smart_contracts.proposal.contract.Proposal.get_voting_state[routing]() -> void:
get_voting_state:
    // smart_contracts/proposal/contract.py:1171
    // quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    intc_0 // 0
    bytec 21 // 0x71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.quorum_threshold exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1172
    // weighted_quorum_votes=arc4.UInt32(self.weighted_quorum_threshold.value),
    intc_0 // 0
    bytec 22 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.weighted_quorum_threshold exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1173
    // total_voters=arc4.UInt32(self.voted_members.value),
    intc_0 // 0
    bytec 6 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1174
    // total_boycott=arc4.UInt32(self.boycotted_members.value),
    intc_0 // 0
    bytec 13 // 0x626f79636f747465645f6d656d62657273
    app_global_get_ex
    assert // check self.boycotted_members exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1175
    // total_approvals=arc4.UInt32(self.approvals.value),
    intc_0 // 0
    bytec 7 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1176
    // total_rejections=arc4.UInt32(self.rejections.value),
    intc_0 // 0
    bytec 8 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1177
    // total_nulls=arc4.UInt32(self.nulls.value),
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1178
    // quorum_reached=self.is_quorum_voters_reached(),
    callsub is_quorum_voters_reached
    // smart_contracts/proposal/contract.py:1179
    // weighted_quorum_reached=self.is_weighted_quorum_votes_reached(),
    callsub is_weighted_quorum_votes_reached
    // smart_contracts/proposal/contract.py:1180
    // majority_approved=self.has_majority_approved(),
    callsub has_majority_approved
    // smart_contracts/proposal/contract.py:1181
    // plebiscite=self.is_plebiscite(),
    callsub is_plebiscite
    // smart_contracts/proposal/contract.py:1170-1182
    // return typ.VotingState(
    //     quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    //     weighted_quorum_votes=arc4.UInt32(self.weighted_quorum_threshold.value),
    //     total_voters=arc4.UInt32(self.voted_members.value),
    //     total_boycott=arc4.UInt32(self.boycotted_members.value),
    //     total_approvals=arc4.UInt32(self.approvals.value),
    //     total_rejections=arc4.UInt32(self.rejections.value),
    //     total_nulls=arc4.UInt32(self.nulls.value),
    //     quorum_reached=self.is_quorum_voters_reached(),
    //     weighted_quorum_reached=self.is_weighted_quorum_votes_reached(),
    //     majority_approved=self.has_majority_approved(),
    //     plebiscite=self.is_plebiscite(),
    // )
    uncover 10
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    bytec 19 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_1 // 1
    uncover 5
    setbit
    pushint 2
    uncover 4
    setbit
    pushint 3
    uncover 3
    setbit
    concat
    // smart_contracts/proposal/contract.py:1151
    // @arc4.abimethod(readonly=True)
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.get_uint_from_registry_config(global_state_key: bytes) -> uint64:
get_uint_from_registry_config:
    // smart_contracts/proposal/contract.py:197
    // def get_uint_from_registry_config(self, global_state_key: Bytes) -> UInt64:
    proto 1 1
    // smart_contracts/proposal/contract.py:199
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:198-200
    // value, exists = AppGlobal.get_ex_uint64(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:201
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:202
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.get_bytes_from_registry_config(global_state_key: bytes) -> bytes:
get_bytes_from_registry_config:
    // smart_contracts/proposal/contract.py:204
    // def get_bytes_from_registry_config(self, global_state_key: Bytes) -> Bytes:
    proto 1 1
    // smart_contracts/proposal/contract.py:206
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:205-207
    // value, exists = AppGlobal.get_ex_bytes(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:208
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:209
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.is_voting_open() -> uint64:
is_voting_open:
    // smart_contracts/proposal/contract.py:212
    // elapsed_voting_duration = Global.latest_timestamp - self.vote_open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 28 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    -
    // smart_contracts/proposal/contract.py:213
    // return elapsed_voting_duration <= self.voting_duration.value
    intc_0 // 0
    bytec 30 // 0x766f74696e675f6475726174696f6e
    app_global_get_ex
    assert // check self.voting_duration exists
    <=
    retsub


// smart_contracts.proposal.contract.Proposal.is_boycott(votes: uint64, approvals: uint64, rejections: uint64) -> uint64:
is_boycott:
    // smart_contracts/proposal/contract.py:272
    // def is_boycott(self, votes: UInt64, approvals: UInt64, rejections: UInt64) -> bool:
    proto 3 1
    // smart_contracts/proposal/contract.py:273
    // return approvals == votes and rejections == votes
    frame_dig -2
    frame_dig -3
    ==
    bz is_boycott_bool_false@3
    frame_dig -1
    frame_dig -3
    ==
    bz is_boycott_bool_false@3
    intc_1 // 1
    retsub

is_boycott_bool_false@3:
    intc_0 // 0
    // smart_contracts/proposal/contract.py:273
    // return approvals == votes and rejections == votes
    retsub


// smart_contracts.proposal.contract.Proposal.is_plebiscite() -> uint64:
is_plebiscite:
    // smart_contracts/proposal/contract.py:291
    // return self.voted_members.value == self.committee_members.value
    intc_0 // 0
    bytec 6 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_0 // 0
    bytec 11 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.assert_draft_and_proposer() -> void:
assert_draft_and_proposer:
    // smart_contracts/proposal/contract.py:339
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:341
    // self.status.value == enm.STATUS_DRAFT and not self.finalized.value
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 10
    ==
    bz assert_draft_and_proposer_bool_false@3
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz assert_draft_and_proposer_bool_false@3
    intc_1 // 1

assert_draft_and_proposer_bool_merge@4:
    // smart_contracts/proposal/contract.py:340-342
    // assert (
    //     self.status.value == enm.STATUS_DRAFT and not self.finalized.value
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    retsub

assert_draft_and_proposer_bool_false@3:
    intc_0 // 0
    b assert_draft_and_proposer_bool_merge@4


// smart_contracts.proposal.contract.Proposal.is_proposer() -> uint64:
is_proposer:
    // smart_contracts/proposal/contract.py:446
    // return Txn.sender == self.proposer.value
    txn Sender
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_xgov_daemon() -> uint64:
is_xgov_daemon:
    // smart_contracts/proposal/contract.py:454
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:455
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    bytec 39 // 0x78676f765f6461656d6f6e
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:454-456
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    // )
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_registry_call() -> uint64:
is_registry_call:
    // smart_contracts/proposal/contract.py:459
    // return Global.caller_application_id == self.registry_app_id.value
    global CallerApplicationID
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.pay(receiver: bytes, amount: uint64) -> void:
pay:
    // smart_contracts/proposal/contract.py:461
    // def pay(self, receiver: Account, amount: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:462-466
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_begin
    frame_dig -1
    itxn_field Amount
    frame_dig -2
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:462
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:465
    // fee=UInt64(0),  # enforces the sender to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:462-466
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.proposal.contract.Proposal.transfer_locked_amount(receiver: bytes) -> void:
transfer_locked_amount:
    // smart_contracts/proposal/contract.py:468
    // def transfer_locked_amount(self, receiver: Account) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:469
    // self.pay(receiver, self.locked_amount.value)
    intc_0 // 0
    bytec 20 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    frame_dig -1
    swap
    callsub pay
    // smart_contracts/proposal/contract.py:470
    // self.locked_amount.value = UInt64(0)
    bytec 20 // 0x6c6f636b65645f616d6f756e74
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.assert_same_app_and_method(group_index: uint64) -> void:
assert_same_app_and_method:
    // smart_contracts/proposal/contract.py:472
    // def assert_same_app_and_method(self, group_index: UInt64) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:474
    // GTxn.application_id(group_index) == Global.current_application_id
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/proposal/contract.py:473-475
    // assert (
    //     GTxn.application_id(group_index) == Global.current_application_id
    // ), err.WRONG_APP_ID
    assert // Wrong App ID
    // smart_contracts/proposal/contract.py:476
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    frame_dig -1
    gtxnsa ApplicationArgs 0
    // smart_contracts/proposal/contract.py:476-478
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    //     0
    // ), err.WRONG_METHOD_CALL
    txna ApplicationArgs 0
    ==
    assert // Wrong Method Call
    retsub


// smart_contracts.proposal.contract.Proposal.is_quorum_voters_reached() -> uint64:
is_quorum_voters_reached:
    // smart_contracts/proposal/contract.py:539-542
    // # A category dependent quorum of all xGov Voting Committee (1 xGov, 1 vote) is reached.
    // # Null votes affect this quorum.
    // # Boycott votes, i.e. invalid, do not affect this quorum.
    // quorum_defined = self.quorum_threshold.value > 0
    intc_0 // 0
    bytec 21 // 0x71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.quorum_threshold exists
    // smart_contracts/proposal/contract.py:544
    // self.voted_members.value - self.boycotted_members.value
    intc_0 // 0
    bytec 6 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_0 // 0
    bytec 13 // 0x626f79636f747465645f6d656d62657273
    app_global_get_ex
    assert // check self.boycotted_members exists
    -
    // smart_contracts/proposal/contract.py:544-545
    //     self.voted_members.value - self.boycotted_members.value
    // ) >= self.quorum_threshold.value and quorum_defined
    dig 1
    >=
    // smart_contracts/proposal/contract.py:543-545
    // return (
    //     self.voted_members.value - self.boycotted_members.value
    // ) >= self.quorum_threshold.value and quorum_defined
    &&
    retsub


// smart_contracts.proposal.contract.Proposal.is_weighted_quorum_votes_reached() -> uint64:
is_weighted_quorum_votes_reached:
    // smart_contracts/proposal/contract.py:548-550
    // # A category dependent weighted quorum of all xGov Voting Committee voting power (1 vote) is reached.
    // # Null votes affect this quorum.
    // weighted_quorum_defined = self.weighted_quorum_threshold.value > 0
    intc_0 // 0
    bytec 22 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.weighted_quorum_threshold exists
    // smart_contracts/proposal/contract.py:551
    // total_votes = self.approvals.value + self.rejections.value + self.nulls.value
    intc_0 // 0
    bytec 7 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 8 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    +
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    // smart_contracts/proposal/contract.py:553
    // total_votes >= self.weighted_quorum_threshold.value
    dig 1
    >=
    // smart_contracts/proposal/contract.py:553-554
    // total_votes >= self.weighted_quorum_threshold.value
    // and weighted_quorum_defined
    &&
    // smart_contracts/proposal/contract.py:552-555
    // return (
    //     total_votes >= self.weighted_quorum_threshold.value
    //     and weighted_quorum_defined
    // )
    retsub


// smart_contracts.proposal.contract.Proposal.has_majority_approved() -> uint64:
has_majority_approved:
    // smart_contracts/proposal/contract.py:558-560
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // return self.approvals.value > self.rejections.value
    intc_0 // 0
    bytec 7 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 8 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    >
    retsub


// smart_contracts.proposal.contract.Proposal._unassign_voter(voter: bytes, voting_power: uint64) -> void:
_unassign_voter:
    // smart_contracts/proposal/contract.py:772
    // def _unassign_voter(self, voter: Account, voting_power: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:773
    // self.assigned_members.value -= 1
    intc_0 // 0
    bytec 5 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    intc_1 // 1
    -
    bytec 5 // 0x61737369676e65645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:774
    // self.assigned_votes.value -= voting_power
    intc_0 // 0
    bytec 17 // 0x61737369676e65645f766f746573
    app_global_get_ex
    assert // check self.assigned_votes exists
    frame_dig -1
    -
    bytec 17 // 0x61737369676e65645f766f746573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:775
    // del self.voters[voter]
    bytec 18 // "V"
    frame_dig -2
    concat
    box_del
    pop
    retsub
