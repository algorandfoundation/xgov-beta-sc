#pragma version 10
#pragma typetrack false

// smart_contracts.proposal.contract.Proposal.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 10 20 10000
    bytecblock 0x0000 0x737461747573 0x 0x70726f706f736572 0x66756e64696e675f63617465676f7279 "M" 0x72656769737472795f6170705f6964 0x636f6d6d69747465655f6d656d62657273 "voters_count" 0x636f6d6d69747465655f766f746573 0x766f7465645f6d656d62657273 0x617070726f76616c73 0x72656a656374696f6e73 "assigned_votes" 0x6c6f636b65645f616d6f756e74 0x6e756c6c73 0x151f7c75 0x7375626d697373696f6e5f74696d657374616d70 0x766f74655f6f70656e696e675f74696d657374616d70 0x636f6d6d69747465655f6964 0x00 0x00194552523a57726f6e672050726f706f73616c20537461747573 0x7469746c65 0x66696e616c697a6174696f6e5f74696d657374616d70 0x666f637573 0x66756e64696e675f74797065 0x7265717565737465645f616d6f756e74 "V" 0x78676f765f6261636b656e64
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/proposal/contract.py:46
    // Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 3 // 3
    ==
    // smart_contracts/proposal/contract.py:44-47
    // # Preconditions
    // assert (
    //     Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    // ), err.WRONG_GLOBAL_BYTES
    assert // Wrong Global Bytes allocation
    // smart_contracts/proposal/contract.py:48
    // assert Txn.global_num_uint == prop_cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    pushint 18 // 18
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/proposal/contract.py:49
    // assert Txn.local_num_byte_slice == prop_cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/proposal/contract.py:50
    // assert Txn.local_num_uint == prop_cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/proposal/contract.py:54
    // key=prop_cfg.GS_KEY_PROPOSER,
    bytec_3 // 0x70726f706f736572
    // smart_contracts/proposal/contract.py:53
    // Account(),
    global ZeroAddress
    // smart_contracts/proposal/contract.py:52-55
    // self.proposer = GlobalState(
    //     Account(),
    //     key=prop_cfg.GS_KEY_PROPOSER,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:58
    // key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    bytec 6 // 0x72656769737472795f6170705f6964
    // smart_contracts/proposal/contract.py:57
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:56-59
    // self.registry_app_id = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:62
    // key=prop_cfg.GS_KEY_TITLE,
    bytec 22 // 0x7469746c65
    // smart_contracts/proposal/contract.py:61
    // String(),
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:60-63
    // self.title = GlobalState(
    //     String(),
    //     key=prop_cfg.GS_KEY_TITLE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:66
    // key=prop_cfg.GS_KEY_SUBMISSION_TS,
    bytec 17 // 0x7375626d697373696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:65
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:64-67
    // self.submission_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_SUBMISSION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:70
    // key=prop_cfg.GS_KEY_FINALIZATION_TS,
    bytec 23 // 0x66696e616c697a6174696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:69
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:68-71
    // self.finalization_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_FINALIZATION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:74
    // key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    bytec 18 // 0x766f74655f6f70656e696e675f74696d657374616d70
    // smart_contracts/proposal/contract.py:73
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:72-75
    // self.vote_open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:78
    // key=prop_cfg.GS_KEY_STATUS,
    bytec_1 // 0x737461747573
    // smart_contracts/proposal/contract.py:77
    // UInt64(enm.STATUS_EMPTY),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:76-79
    // self.status = GlobalState(
    //     UInt64(enm.STATUS_EMPTY),
    //     key=prop_cfg.GS_KEY_STATUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:82
    // key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    bytec 4 // 0x66756e64696e675f63617465676f7279
    // smart_contracts/proposal/contract.py:81
    // UInt64(enm.FUNDING_CATEGORY_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:80-83
    // self.funding_category = GlobalState(
    //     UInt64(enm.FUNDING_CATEGORY_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:86
    // key=prop_cfg.GS_KEY_FOCUS,
    bytec 24 // 0x666f637573
    // smart_contracts/proposal/contract.py:85
    // UInt64(enm.FOCUS_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:84-87
    // self.focus = GlobalState(
    //     UInt64(enm.FOCUS_NULL),
    //     key=prop_cfg.GS_KEY_FOCUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:90
    // key=prop_cfg.GS_KEY_FUNDING_TYPE,
    bytec 25 // 0x66756e64696e675f74797065
    // smart_contracts/proposal/contract.py:89
    // UInt64(enm.FUNDING_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:88-91
    // self.funding_type = GlobalState(
    //     UInt64(enm.FUNDING_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_TYPE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:94
    // key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    bytec 26 // 0x7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:93
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:92-95
    // self.requested_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:98
    // key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    bytec 14 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:97
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:96-99
    // self.locked_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:102
    // key=prop_cfg.GS_KEY_COMMITTEE_ID,
    bytec 19 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:101
    // typ.Bytes32.from_bytes(b""),
    bytec_2 // 0x
    // smart_contracts/proposal/contract.py:100-103
    // self.committee_id = GlobalState(
    //     typ.Bytes32.from_bytes(b""),
    //     key=prop_cfg.GS_KEY_COMMITTEE_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:106
    // key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:105
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:104-107
    // self.committee_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:110
    // key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    bytec 9 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:109
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:108-111
    // self.committee_votes = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:114
    // key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    bytec 10 // 0x766f7465645f6d656d62657273
    // smart_contracts/proposal/contract.py:113
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:112-115
    // self.voted_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:118
    // key=prop_cfg.GS_KEY_APPROVALS,
    bytec 11 // 0x617070726f76616c73
    // smart_contracts/proposal/contract.py:117
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:116-119
    // self.approvals = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_APPROVALS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:122
    // key=prop_cfg.GS_KEY_REJECTIONS,
    bytec 12 // 0x72656a656374696f6e73
    // smart_contracts/proposal/contract.py:121
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:120-123
    // self.rejections = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REJECTIONS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:126
    // key=prop_cfg.GS_KEY_NULLS,
    bytec 15 // 0x6e756c6c73
    // smart_contracts/proposal/contract.py:125
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:124-127
    // self.nulls = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_NULLS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:132
    // self.voters_count = UInt64(0)
    bytec 8 // "voters_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:133
    // self.assigned_votes = UInt64(0)
    bytec 13 // "assigned_votes"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn NumAppArgs
    bz main_after_if_else@21
    pushbytess 0xcc694eaa 0x1ec3853f 0x7143994f 0x7371321a 0x23d8b7ce 0x74e6557e 0x0d9ab0d7 0x1841a0d2 0x734dbecc 0x212d9f07 0x8a5e4c80 0x2ac19b05 0x69ecf4a2 0x24378d3c 0x9a7067fa 0xdbd83dd9 // method "create(address)void", method "submit(pay,string,uint64,uint64,uint8)void", method "upload_metadata(byte[],bool)void", method "drop()string", method "finalize()void", method "assign_voter(address,uint64)void", method "assign_voters((address,uint64)[])void", method "vote(address,uint64,uint64)string", method "scrutiny()void", method "review(bool)void", method "fund()string", method "unassign_voters(address[])void", method "decommission()string", method "delete()void", method "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)", method "op_up()void"
    txna ApplicationArgs 0
    match main_create_route@5 main_submit_route@6 main_upload_metadata_route@7 main_drop_route@8 main_finalize_route@9 main_assign_voter_route@10 main_assign_voters_route@11 main_vote_route@12 main_scrutiny_route@13 main_review_route@14 main_fund_route@15 main_unassign_voters_route@16 main_decommission_route@17 main_delete_route@18 main_get_state_route@19 main_op_up_route@20

main_after_if_else@21:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    intc_0 // 0
    return

main_op_up_route@20:
    // smart_contracts/proposal/contract.py:1028
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_get_state_route@19:
    // smart_contracts/proposal/contract.py:998
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_state
    bytec 16 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_delete_route@18:
    // smart_contracts/proposal/contract.py:986
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub delete
    intc_1 // 1
    return

main_decommission_route@17:
    // smart_contracts/proposal/contract.py:948
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub decommission
    bytec 16 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_unassign_voters_route@16:
    // smart_contracts/proposal/contract.py:917
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:917
    // @arc4.abimethod()
    callsub unassign_voters
    intc_1 // 1
    return

main_fund_route@15:
    // smart_contracts/proposal/contract.py:895
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub fund
    bytec 16 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_review_route@14:
    // smart_contracts/proposal/contract.py:868
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    intc_0 // 0
    getbit
    // smart_contracts/proposal/contract.py:868
    // @arc4.abimethod()
    callsub review
    intc_1 // 1
    return

main_scrutiny_route@13:
    // smart_contracts/proposal/contract.py:824
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub scrutiny
    intc_1 // 1
    return

main_vote_route@12:
    // smart_contracts/proposal/contract.py:776
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/proposal/contract.py:776
    // @arc4.abimethod()
    callsub vote
    bytec 16 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_assign_voters_route@11:
    // smart_contracts/proposal/contract.py:741
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:741
    // @arc4.abimethod()
    callsub assign_voters
    intc_1 // 1
    return

main_assign_voter_route@10:
    // smart_contracts/proposal/contract.py:720
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/proposal/contract.py:720
    // @arc4.abimethod()
    callsub assign_voter
    intc_1 // 1
    return

main_finalize_route@9:
    // smart_contracts/proposal/contract.py:655
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub finalize
    intc_1 // 1
    return

main_drop_route@8:
    // smart_contracts/proposal/contract.py:632
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub drop
    bytec 16 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_upload_metadata_route@7:
    // smart_contracts/proposal/contract.py:600
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/proposal/contract.py:600
    // @arc4.abimethod()
    callsub upload_metadata
    intc_1 // 1
    return

main_submit_route@6:
    // smart_contracts/proposal/contract.py:547
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/proposal/contract.py:547
    // @arc4.abimethod()
    callsub submit
    intc_1 // 1
    return

main_create_route@5:
    // smart_contracts/proposal/contract.py:533
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:533
    // @arc4.abimethod(create="require")
    callsub create
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.is_voting_open() -> uint64, bytes:
is_voting_open:
    // smart_contracts/proposal/contract.py:139-140
    // @subroutine
    // def is_voting_open(self) -> tuple[bool, typ.Error]:
    proto 0 2
    intc_0 // 0
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:141
    // voting_duration = Global.latest_timestamp - self.vote_open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 18 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    -
    // smart_contracts/proposal/contract.py:143
    // self.funding_category.value
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:269
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz is_voting_open_else_body@5
    // smart_contracts/proposal/contract.py:271
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    pushbytes 0x766f74696e675f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:270-272
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1

is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8:
    // smart_contracts/proposal/contract.py:145
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz is_voting_open_after_if_else@2
    // smart_contracts/proposal/contract.py:146
    // return False, error
    intc_0 // 0
    frame_dig 0
    frame_bury 1
    frame_bury 0
    retsub

is_voting_open_after_if_else@2:
    // smart_contracts/proposal/contract.py:148
    // return voting_duration <= maximum_voting_duration, typ.Error("")
    frame_dig 2
    frame_dig 1
    <=
    bytec_0 // 0x0000
    frame_bury 1
    frame_bury 0
    retsub

is_voting_open_else_body@5:
    // smart_contracts/proposal/contract.py:273
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 3
    intc_3 // 20
    ==
    bz is_voting_open_else_body@7
    // smart_contracts/proposal/contract.py:275
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    pushbytes 0x766f74696e675f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:274-276
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:142-144
    // maximum_voting_duration, error = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8

is_voting_open_else_body@7:
    // smart_contracts/proposal/contract.py:279
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    pushbytes 0x766f74696e675f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:278-280
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:142-144
    // maximum_voting_duration, error = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8


// smart_contracts.proposal.contract.Proposal.assign_voter_check_authorization() -> void:
assign_voter_check_authorization:
    // smart_contracts/proposal/contract.py:240
    // assert self.is_xgov_backend(), err.UNAUTHORIZED
    callsub is_xgov_backend
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:241
    // assert self.status.value == enm.STATUS_FINAL, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 20
    ==
    assert // Wrong Proposal Status
    retsub


// smart_contracts.proposal.contract.Proposal.assert_draft_and_proposer() -> void:
assert_draft_and_proposer:
    // smart_contracts/proposal/contract.py:342
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:343
    // assert self.status.value == enm.STATUS_DRAFT, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    assert // Wrong Proposal Status
    retsub


// smart_contracts.proposal.contract.Proposal.get_expected_locked_amount(requested_amount: uint64) -> uint64:
get_expected_locked_amount:
    // smart_contracts/proposal/contract.py:414-415
    // @subroutine
    // def get_expected_locked_amount(self, requested_amount: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/proposal/contract.py:417
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    pushbytes 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    // smart_contracts/proposal/contract.py:416-418
    // proposal_commitment_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:419
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:412
    // return amount * fraction_in_bps // const.BPS
    frame_dig -1
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:420-423
    // return self.relative_to_absolute_amount(
    //     requested_amount,
    //     proposal_commitment_bps,
    // )
    retsub


// smart_contracts.proposal.contract.Proposal.get_uint_from_registry_config(global_state_key: bytes) -> uint64, bytes:
get_uint_from_registry_config:
    // smart_contracts/proposal/contract.py:456-459
    // @subroutine
    // def get_uint_from_registry_config(
    //     self, global_state_key: Bytes
    // ) -> tuple[UInt64, typ.Error]:
    proto 1 2
    // smart_contracts/proposal/contract.py:461
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:460-462
    // value, exists = AppGlobal.get_ex_uint64(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:463
    // error = typ.Error("")
    bytec_0 // 0x0000
    swap
    // smart_contracts/proposal/contract.py:464
    // if not exists:
    bnz get_uint_from_registry_config_after_if_else@2
    // smart_contracts/proposal/contract.py:465
    // error = typ.Error(err.ARC_65_PREFIX + err.MISSING_CONFIG)
    pushbytes 0x00124552523a4d697373696e6720436f6e666967
    frame_bury 1

get_uint_from_registry_config_after_if_else@2:
    // smart_contracts/proposal/contract.py:466
    // return value, error
    frame_dig 0
    frame_dig 1
    uncover 3
    uncover 3
    retsub


// smart_contracts.proposal.contract.Proposal.get_bytes_from_registry_config(global_state_key: bytes) -> bytes:
get_bytes_from_registry_config:
    // smart_contracts/proposal/contract.py:468-469
    // @subroutine
    // def get_bytes_from_registry_config(self, global_state_key: Bytes) -> Bytes:
    proto 1 1
    // smart_contracts/proposal/contract.py:471
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:470-472
    // value, exists = AppGlobal.get_ex_bytes(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:473
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:474
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.check_registry_not_paused() -> void:
check_registry_not_paused:
    // smart_contracts/proposal/contract.py:479
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    pushbytes 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:478-480
    // registry_paused, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:482
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:483
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    retsub


// smart_contracts.proposal.contract.Proposal.is_proposer() -> uint64:
is_proposer:
    // smart_contracts/proposal/contract.py:491
    // return Txn.sender == self.proposer.value
    txn Sender
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_xgov_backend() -> uint64:
is_xgov_backend:
    // smart_contracts/proposal/contract.py:501
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:503
    // Bytes(reg_cfg.GS_KEY_XGOV_BACKEND)
    bytec 28 // 0x78676f765f6261636b656e64
    // smart_contracts/proposal/contract.py:502-504
    // self.get_bytes_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_XGOV_BACKEND)
    // )
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:501-505
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(
    //         Bytes(reg_cfg.GS_KEY_XGOV_BACKEND)
    //     )
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_registry_call() -> uint64:
is_registry_call:
    // smart_contracts/proposal/contract.py:509
    // return Global.caller_application_id == self.registry_app_id.value
    global CallerApplicationID
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.pay(receiver: bytes, amount: uint64) -> void:
pay:
    // smart_contracts/proposal/contract.py:511-512
    // @subroutine
    // def pay(self, receiver: Account, amount: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:513-517
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_begin
    frame_dig -1
    itxn_field Amount
    frame_dig -2
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:513
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:516
    // fee=UInt64(0),  # enforces the sender to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:513-517
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.proposal.contract.Proposal.transfer_locked_amount(receiver: bytes) -> void:
transfer_locked_amount:
    // smart_contracts/proposal/contract.py:519-520
    // @subroutine
    // def transfer_locked_amount(self, receiver: Account) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:521
    // self.pay(receiver, self.locked_amount.value)
    intc_0 // 0
    bytec 14 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    frame_dig -1
    swap
    callsub pay
    // smart_contracts/proposal/contract.py:522
    // self.locked_amount.value = UInt64(0)
    bytec 14 // 0x6c6f636b65645f616d6f756e74
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.assert_same_app_and_method(group_index: uint64) -> void:
assert_same_app_and_method:
    // smart_contracts/proposal/contract.py:524-525
    // @subroutine
    // def assert_same_app_and_method(self, group_index: UInt64) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:527
    // GTxn.application_id(group_index) == Global.current_application_id
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/proposal/contract.py:526-528
    // assert (
    //     GTxn.application_id(group_index) == Global.current_application_id
    // ), err.WRONG_APP_ID
    assert // Wrong App ID
    // smart_contracts/proposal/contract.py:529
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    frame_dig -1
    gtxnsa ApplicationArgs 0
    // smart_contracts/proposal/contract.py:529-531
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    //     0
    // ), err.WRONG_METHOD_CALL
    txna ApplicationArgs 0
    ==
    assert // Wrong Method Call
    retsub


// smart_contracts.proposal.contract.Proposal.create(proposer: bytes) -> void:
create:
    // smart_contracts/proposal/contract.py:533-534
    // @arc4.abimethod(create="require")
    // def create(self, proposer: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:541
    // Global.caller_application_id != 0
    global CallerApplicationID
    // smart_contracts/proposal/contract.py:540-542
    // assert (
    //     Global.caller_application_id != 0
    // ), err.UNAUTHORIZED  # Only callable by another contract
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:544
    // self.proposer.value = proposer.native
    bytec_3 // 0x70726f706f736572
    frame_dig -1
    app_global_put
    // smart_contracts/proposal/contract.py:545
    // self.registry_app_id.value = Global.caller_application_id
    bytec 6 // 0x72656769737472795f6170705f6964
    global CallerApplicationID
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.submit(payment: uint64, title: bytes, funding_type: bytes, requested_amount: bytes, focus: bytes) -> void:
submit:
    // smart_contracts/proposal/contract.py:547-555
    // @arc4.abimethod()
    // def submit(
    //     self,
    //     payment: gtxn.PaymentTransaction,
    //     title: arc4.String,
    //     funding_type: arc4.UInt64,
    //     requested_amount: arc4.UInt64,
    //     focus: arc4.UInt8,
    // ) -> None:
    proto 5 0
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:580
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:374
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:375
    // assert self.status.value == enm.STATUS_EMPTY, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    !
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:585
    // title.native, funding_type.native, requested_amount.native
    frame_dig -4
    extract 2 0
    frame_bury -4
    frame_dig -3
    btoi
    dup
    frame_dig -2
    btoi
    swap
    // smart_contracts/proposal/contract.py:385
    // assert title.bytes.length <= const.TITLE_MAX_BYTES, err.WRONG_TITLE_LENGTH
    frame_dig -4
    len
    pushint 123 // 123
    <=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:386
    // assert title != "", err.WRONG_TITLE_LENGTH
    frame_dig -4
    bytec_2 // ""
    !=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:389
    // funding_type == enm.FUNDING_PROACTIVE
    intc_2 // 10
    ==
    // smart_contracts/proposal/contract.py:389-390
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bnz submit_bool_true@5
    // smart_contracts/proposal/contract.py:390
    // or funding_type == enm.FUNDING_RETROACTIVE
    frame_dig 1
    intc_3 // 20
    ==
    // smart_contracts/proposal/contract.py:389-390
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bz submit_bool_false@6

submit_bool_true@5:
    intc_1 // 1

submit_bool_merge@7:
    // smart_contracts/proposal/contract.py:388-391
    // assert (
    //     funding_type == enm.FUNDING_PROACTIVE
    //     or funding_type == enm.FUNDING_RETROACTIVE
    // ), err.WRONG_FUNDING_TYPE
    assert // Wrong Funding Type
    // smart_contracts/proposal/contract.py:394
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    pushbytes 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:393-395
    // min_requested_amount, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:396
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:399
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:398-400
    // max_requested_amount_large, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:401
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:403
    // assert requested_amount >= min_requested_amount, err.WRONG_MIN_REQUESTED_AMOUNT
    frame_dig 2
    dup
    uncover 3
    >=
    assert // Requested amount is less than the minimum requested amount
    // smart_contracts/proposal/contract.py:405
    // requested_amount <= max_requested_amount_large
    dup
    uncover 2
    <=
    // smart_contracts/proposal/contract.py:404-406
    // assert (
    //     requested_amount <= max_requested_amount_large
    // ), err.WRONG_MAX_REQUESTED_AMOUNT
    assert // Requested amount is more than the maximum requested amount
    // smart_contracts/proposal/contract.py:429
    // expected_lock_amount = self.get_expected_locked_amount(requested_amount)
    dup
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:431
    // assert payment.sender == self.proposer.value, err.WRONG_SENDER
    frame_dig -5
    gtxns Sender
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    assert // Wrong Sender
    // smart_contracts/proposal/contract.py:433
    // payment.receiver == Global.current_application_address
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/proposal/contract.py:432-434
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/proposal/contract.py:435
    // assert payment.amount == expected_lock_amount, err.WRONG_LOCKED_AMOUNT
    frame_dig -5
    gtxns Amount
    ==
    assert // Locked amount is incorrect
    // smart_contracts/proposal/contract.py:589
    // self.title.value = title.native
    bytec 22 // 0x7469746c65
    frame_dig -4
    app_global_put
    // smart_contracts/proposal/contract.py:440
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    // smart_contracts/proposal/contract.py:439-441
    // max_requested_amount_small, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:442
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:445
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    // smart_contracts/proposal/contract.py:444-446
    // max_requested_amount_medium, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    swap
    frame_bury 0
    // smart_contracts/proposal/contract.py:447
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:449
    // if requested_amount <= max_requested_amount_small:
    <=
    bz submit_else_body@13
    // smart_contracts/proposal/contract.py:450
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_SMALL)
    bytec 4 // 0x66756e64696e675f63617465676f7279
    intc_2 // 10
    app_global_put

submit_after_if_else@16:
    // smart_contracts/proposal/contract.py:591
    // self.funding_type.value = funding_type.native
    bytec 25 // 0x66756e64696e675f74797065
    frame_dig 1
    app_global_put
    // smart_contracts/proposal/contract.py:592
    // self.requested_amount.value = requested_amount.native
    bytec 26 // 0x7265717565737465645f616d6f756e74
    frame_dig 2
    dup
    cover 2
    app_global_put
    // smart_contracts/proposal/contract.py:593
    // self.focus.value = focus.native
    frame_dig -1
    btoi
    bytec 24 // 0x666f637573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:594-596
    // self.locked_amount.value = self.get_expected_locked_amount(
    //     requested_amount.native
    // )
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:594
    // self.locked_amount.value = self.get_expected_locked_amount(
    bytec 14 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:594-596
    // self.locked_amount.value = self.get_expected_locked_amount(
    //     requested_amount.native
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:597
    // self.submission_ts.value = Global.latest_timestamp
    bytec 17 // 0x7375626d697373696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:598
    // self.status.value = UInt64(enm.STATUS_DRAFT)
    bytec_1 // 0x737461747573
    intc_2 // 10
    app_global_put
    retsub

submit_else_body@13:
    // smart_contracts/proposal/contract.py:451
    // elif requested_amount <= max_requested_amount_medium:
    frame_dig 2
    frame_dig 0
    <=
    bz submit_else_body@15
    // smart_contracts/proposal/contract.py:452
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_MEDIUM)
    bytec 4 // 0x66756e64696e675f63617465676f7279
    intc_3 // 20
    app_global_put
    b submit_after_if_else@16

submit_else_body@15:
    // smart_contracts/proposal/contract.py:454
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_LARGE)
    bytec 4 // 0x66756e64696e675f63617465676f7279
    pushint 33 // 33
    app_global_put
    b submit_after_if_else@16

submit_bool_false@6:
    intc_0 // 0
    b submit_bool_merge@7


// smart_contracts.proposal.contract.Proposal.upload_metadata(payload: bytes, is_first_in_group: bytes) -> void:
upload_metadata:
    // smart_contracts/proposal/contract.py:600-603
    // @arc4.abimethod()
    // def upload_metadata(
    //     self, payload: arc4.DynamicBytes, is_first_in_group: arc4.Bool
    // ) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:617
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:366
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:370
    // assert payload.length > 0, err.EMPTY_PAYLOAD
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    assert // Empty payload
    // smart_contracts/proposal/contract.py:622
    // if is_first_in_group:
    frame_dig -1
    bytec 20 // 0x00
    !=
    bz upload_metadata_else_body@2
    // smart_contracts/proposal/contract.py:623-624
    // # clear and write the metadata to the box
    // self.metadata.delete()
    bytec 5 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:625
    // self.metadata.put(payload.native)
    frame_dig -2
    extract 2 0
    bytec 5 // "M"
    swap
    box_put
    retsub

upload_metadata_else_body@2:
    // smart_contracts/proposal/contract.py:627-628
    // # append the metadata to the box
    // old_size = self.metadata.length
    bytec 5 // "M"
    box_len
    assert // check self.metadata exists
    // smart_contracts/proposal/contract.py:629
    // self.metadata.resize(self.metadata.length + payload.length)
    bytec 5 // "M"
    box_len
    assert // check self.metadata exists
    frame_dig 0
    +
    bytec 5 // "M"
    swap
    box_resize
    // smart_contracts/proposal/contract.py:630
    // self.metadata.replace(old_size, payload.native)
    frame_dig -2
    extract 2 0
    bytec 5 // "M"
    cover 2
    box_replace
    retsub


// smart_contracts.proposal.contract.Proposal.drop() -> bytes:
drop:
    // smart_contracts/proposal/contract.py:632-633
    // @arc4.abimethod()
    // def drop(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:359
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:360
    // if self.status.value != enm.STATUS_DRAFT:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    !=
    bz drop_after_if_else@5
    // smart_contracts/proposal/contract.py:361
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 21 // 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0

drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@6:
    // smart_contracts/proposal/contract.py:643
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz drop_after_if_else@2
    // smart_contracts/proposal/contract.py:644
    // return error
    frame_dig 0
    swap
    retsub

drop_after_if_else@2:
    // smart_contracts/proposal/contract.py:647
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:646-648
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:650
    // self.metadata.delete()
    bytec 5 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:651
    // self.status.value = UInt64(enm.STATUS_DECOMMISSIONED)
    bytec_1 // 0x737461747573
    pushint 70 // 70
    app_global_put
    // smart_contracts/proposal/contract.py:653
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub

drop_after_if_else@5:
    // smart_contracts/proposal/contract.py:362
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:642
    // error = self.drop_check_authorization()
    b drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@6


// smart_contracts.proposal.contract.Proposal.finalize() -> void:
finalize:
    // smart_contracts/proposal/contract.py:655-656
    // @arc4.abimethod()
    // def finalize(self) -> None:
    proto 0 0
    intc_0 // 0
    // smart_contracts/proposal/contract.py:671
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:348
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:350
    // discussion_duration = Global.latest_timestamp - self.submission_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 17 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    -
    // smart_contracts/proposal/contract.py:352
    // self.funding_category.value
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:252
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz finalize_else_body@3
    // smart_contracts/proposal/contract.py:254
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:253-255
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

finalize_after_if_else@7:
    // smart_contracts/proposal/contract.py:264
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:355
    // assert discussion_duration >= minimum_discussion_duration, err.TOO_EARLY
    frame_dig 1
    <=
    assert // Too early
    // smart_contracts/proposal/contract.py:320
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    bytec 19 // 0x636f6d6d69747465655f6964
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:322
    // assert committee_id != typ.Bytes32.from_bytes(b""), err.EMPTY_COMMITTEE_ID
    dup
    bytec_2 // 0x
    !=
    assert // Empty Committee ID
    // smart_contracts/proposal/contract.py:325
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:324-326
    // committee_members, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:327
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:328
    // assert committee_members > UInt64(0), err.WRONG_COMMITTEE_MEMBERS
    dup
    assert // Wrong Committee Members
    // smart_contracts/proposal/contract.py:331
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 9 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:330-332
    // committee_votes, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:333
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:334
    // assert committee_votes > UInt64(0), err.WRONG_COMMITTEE_VOTES
    dup
    assert // Wrong Committee Votes
    // smart_contracts/proposal/contract.py:336
    // self.committee_id.value = committee_id.copy()
    bytec 19 // 0x636f6d6d69747465655f6964
    uncover 3
    app_global_put
    // smart_contracts/proposal/contract.py:337
    // self.committee_members.value = committee_members
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    uncover 2
    app_global_put
    // smart_contracts/proposal/contract.py:338
    // self.committee_votes.value = committee_votes
    bytec 9 // 0x636f6d6d69747465655f766f746573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:677
    // self.status.value = UInt64(enm.STATUS_FINAL)
    bytec_1 // 0x737461747573
    intc_3 // 20
    app_global_put
    // smart_contracts/proposal/contract.py:678
    // self.finalization_ts.value = Global.latest_timestamp
    bytec 23 // 0x66696e616c697a6174696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:681
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_FEE)
    pushbytes 0x70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:680-682
    // proposal_fee, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_FEE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:683
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:685
    // assert self.metadata, err.MISSING_METADATA
    bytec 5 // "M"
    box_len
    bury 1
    assert // Missing Metadata
    // smart_contracts/proposal/contract.py:688
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_PUBLISHING_BPS)
    pushbytes 0x70726f706f73616c5f7075626c697368696e675f627073
    // smart_contracts/proposal/contract.py:687-689
    // publishing_fee_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_PUBLISHING_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:690
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:695
    // Bytes(reg_cfg.GS_KEY_XGOV_BACKEND)
    bytec 28 // 0x78676f765f6261636b656e64
    // smart_contracts/proposal/contract.py:694-696
    // self.get_bytes_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_XGOV_BACKEND)
    // )
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:693-697
    // receiver=Account(
    //     self.get_bytes_from_registry_config(
    //         Bytes(reg_cfg.GS_KEY_XGOV_BACKEND)
    //     )
    // ),
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:412
    // return amount * fraction_in_bps // const.BPS
    cover 2
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:692-699
    // self.pay(
    //     receiver=Account(
    //         self.get_bytes_from_registry_config(
    //             Bytes(reg_cfg.GS_KEY_XGOV_BACKEND)
    //         )
    //     ),
    //     amount=self.relative_to_absolute_amount(proposal_fee, publishing_fee_bps),
    // )
    callsub pay
    retsub

finalize_else_body@3:
    // smart_contracts/proposal/contract.py:256
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 2
    intc_3 // 20
    ==
    bz finalize_else_body@5
    // smart_contracts/proposal/contract.py:258
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:257-259
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b finalize_after_if_else@7

finalize_else_body@5:
    // smart_contracts/proposal/contract.py:262
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:261-263
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b finalize_after_if_else@7


// smart_contracts.proposal.contract.Proposal._assign_voter(voter: bytes, voting_power: uint64) -> void:
_assign_voter:
    // smart_contracts/proposal/contract.py:701-702
    // @subroutine
    // def _assign_voter(self, voter: Account, voting_power: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:247
    // assert voter not in self.voters, err.VOTER_ALREADY_ASSIGNED
    bytec 27 // "V"
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    !
    assert // Voter Already Assigned
    // smart_contracts/proposal/contract.py:248
    // assert voting_power > 0, err.INVALID_VOTING_POWER
    frame_dig -1
    assert // Invalid Voting Power
    // smart_contracts/proposal/contract.py:706
    // votes=arc4.UInt64(voting_power),
    frame_dig -1
    itob
    // smart_contracts/proposal/contract.py:707
    // voted=arc4.Bool(False),  # noqa: FBT003
    bytec 20 // 0x00
    // smart_contracts/proposal/contract.py:705-708
    // self.voters[voter] = typ.VoterBox(
    //     votes=arc4.UInt64(voting_power),
    //     voted=arc4.Bool(False),  # noqa: FBT003
    // )
    concat
    box_put
    // smart_contracts/proposal/contract.py:710
    // self.voters_count += 1
    intc_0 // 0
    bytec 8 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    +
    bytec 8 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:711
    // self.assigned_votes += voting_power
    intc_0 // 0
    bytec 13 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    frame_dig -1
    +
    bytec 13 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:713
    // if self.voters_count == self.committee_members.value:
    intc_0 // 0
    bytec 8 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_0 // 0
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    bz _assign_voter_after_if_else@2
    // smart_contracts/proposal/contract.py:715
    // self.assigned_votes == self.committee_votes.value
    intc_0 // 0
    bytec 13 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    intc_0 // 0
    bytec 9 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    ==
    // smart_contracts/proposal/contract.py:714-716
    // assert (
    //     self.assigned_votes == self.committee_votes.value
    // ), err.VOTING_POWER_MISMATCH
    assert // Voting Power Mismatch
    // smart_contracts/proposal/contract.py:717
    // self.status.value = UInt64(enm.STATUS_VOTING)
    bytec_1 // 0x737461747573
    pushint 25 // 25
    app_global_put
    // smart_contracts/proposal/contract.py:718
    // self.vote_open_ts.value = Global.latest_timestamp
    bytec 18 // 0x766f74655f6f70656e696e675f74696d657374616d70
    global LatestTimestamp
    app_global_put

_assign_voter_after_if_else@2:
    retsub


// smart_contracts.proposal.contract.Proposal.assign_voter(voter: bytes, voting_power: bytes) -> void:
assign_voter:
    // smart_contracts/proposal/contract.py:720-721
    // @arc4.abimethod()
    // def assign_voter(self, voter: arc4.Address, voting_power: arc4.UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:737
    // self.assign_voter_check_authorization()
    callsub assign_voter_check_authorization
    // smart_contracts/proposal/contract.py:739
    // self._assign_voter(voter.native, voting_power.native)
    frame_dig -1
    btoi
    frame_dig -2
    swap
    callsub _assign_voter
    retsub


// smart_contracts.proposal.contract.Proposal.assign_voters(voters: bytes) -> void:
assign_voters:
    // smart_contracts/proposal/contract.py:741-745
    // @arc4.abimethod()
    // def assign_voters(
    //     self,
    //     voters: arc4.DynamicArray[CommitteeMember],
    // ) -> None:
    proto 1 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:763
    // self.assign_voter_check_authorization()
    callsub assign_voter_check_authorization
    // smart_contracts/proposal/contract.py:765
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz assign_voters_else_body@6
    // smart_contracts/proposal/contract.py:766-767
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    frame_bury 1
    intc_1 // 1
    frame_bury 0

assign_voters_for_header@2:
    // smart_contracts/proposal/contract.py:766-767
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    frame_dig 0
    frame_dig 1
    <
    bz assign_voters_after_if_else@7
    // smart_contracts/proposal/contract.py:768
    // self.assert_same_app_and_method(i)
    frame_dig 0
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:766-767
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    frame_bury 0
    b assign_voters_for_header@2

assign_voters_after_if_else@7:
    // smart_contracts/proposal/contract.py:773
    // for i in urange(voters.length):
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 2
    intc_0 // 0
    frame_bury 0

assign_voters_for_header@8:
    // smart_contracts/proposal/contract.py:773
    // for i in urange(voters.length):
    frame_dig 0
    frame_dig 2
    <
    bz assign_voters_after_for@11
    // smart_contracts/proposal/contract.py:774
    // self._assign_voter(voters[i].address.native, voters[i].voting_power.native)
    frame_dig -1
    extract 2 0
    frame_dig 0
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    pushint 32 // 32
    extract_uint64
    callsub _assign_voter
    // smart_contracts/proposal/contract.py:773
    // for i in urange(voters.length):
    intc_1 // 1
    +
    frame_bury 0
    b assign_voters_for_header@8

assign_voters_after_for@11:
    retsub

assign_voters_else_body@6:
    // smart_contracts/proposal/contract.py:770-771
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b assign_voters_after_if_else@7


// smart_contracts.proposal.contract.Proposal.vote(voter: bytes, approvals: bytes, rejections: bytes) -> bytes:
vote:
    // smart_contracts/proposal/contract.py:776-779
    // @arc4.abimethod()
    // def vote(
    //     self, voter: arc4.Address, approvals: arc4.UInt64, rejections: arc4.UInt64
    // ) -> typ.Error:
    proto 3 1
    intc_0 // 0
    dupn 2
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:195
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:197
    // if self.status.value != enm.STATUS_VOTING:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    !=
    bz vote_after_if_else@15
    // smart_contracts/proposal/contract.py:198
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 21 // 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20:
    // smart_contracts/proposal/contract.py:799
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@2
    // smart_contracts/proposal/contract.py:800
    // return error
    retsub

vote_after_if_else@2:
    // smart_contracts/proposal/contract.py:803
    // voter.native, approvals.native, rejections.native
    frame_dig -2
    btoi
    frame_bury 3
    frame_dig -1
    btoi
    frame_bury 5
    // smart_contracts/proposal/contract.py:213
    // if voter not in self.voters:
    bytec 27 // "V"
    frame_dig -3
    concat
    dup
    frame_bury 1
    box_len
    bury 1
    bnz vote_after_if_else@7
    // smart_contracts/proposal/contract.py:214
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_NOT_FOUND)
    pushbytes 0x00134552523a566f746572206e6f7420666f756e64
    frame_bury 0

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12:
    // smart_contracts/proposal/contract.py:805
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@4
    // smart_contracts/proposal/contract.py:806
    // return error
    retsub

vote_after_if_else@4:
    // smart_contracts/proposal/contract.py:808
    // voter_box = self.voters[voter.native].copy()
    frame_dig 1
    dup
    box_get
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:810
    // votes=voter_box.votes,
    dup
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/proposal/contract.py:811
    // voted=arc4.Bool(True),  # noqa: FBT003
    pushbytes 0x80
    // smart_contracts/proposal/contract.py:809-812
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=voter_box.votes,
    //     voted=arc4.Bool(True),  # noqa: FBT003
    // )
    concat
    uncover 2
    swap
    box_put
    // smart_contracts/proposal/contract.py:814
    // self.voted_members.value += 1
    intc_0 // 0
    bytec 10 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_1 // 1
    +
    bytec 10 // 0x766f7465645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:816
    // nulls = voter_box.votes.native - approvals.native - rejections.native
    intc_0 // 0
    extract_uint64
    frame_dig 3
    dup
    cover 2
    -
    frame_dig 5
    dup
    cover 3
    -
    // smart_contracts/proposal/contract.py:818
    // self.approvals.value += approvals.native
    intc_0 // 0
    bytec 11 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    uncover 2
    +
    bytec 11 // 0x617070726f76616c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:819
    // self.rejections.value += rejections.native
    intc_0 // 0
    bytec 12 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    uncover 2
    +
    bytec 12 // 0x72656a656374696f6e73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:820
    // self.nulls.value += nulls
    intc_0 // 0
    bytec 15 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    bytec 15 // 0x6e756c6c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:822
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    retsub

vote_after_if_else@7:
    // smart_contracts/proposal/contract.py:216
    // voter_box = self.voters[voter].copy()
    frame_dig 1
    box_get
    swap
    dup
    cover 2
    frame_bury 2
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:217
    // if voter_box.voted:
    pushint 64 // 64
    getbit
    bytec 20 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 20 // 0x00
    !=
    bz vote_after_if_else@9
    // smart_contracts/proposal/contract.py:218
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_ALREADY_VOTED)
    pushbytes 0x00174552523a566f74657220616c726561647920766f746564
    frame_bury 0
    // smart_contracts/proposal/contract.py:802-804
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@9:
    // smart_contracts/proposal/contract.py:220
    // if approvals + rejections > voter_box.votes:
    frame_dig 2
    extract 0 8 // on error: Index access is out of bounds
    frame_dig 3
    frame_dig 5
    +
    itob
    b<
    bz vote_after_if_else@11
    // smart_contracts/proposal/contract.py:221
    // return typ.Error(err.ARC_65_PREFIX + err.VOTES_EXCEEDED)
    pushbytes 0x00124552523a566f746573206578636565646564
    frame_bury 0
    // smart_contracts/proposal/contract.py:802-804
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@11:
    // smart_contracts/proposal/contract.py:223
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:802-804
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@15:
    // smart_contracts/proposal/contract.py:200
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    dup
    cover 2
    frame_bury 0
    frame_bury 4
    // smart_contracts/proposal/contract.py:201
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    !=
    bnz vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20
    // smart_contracts/proposal/contract.py:204
    // if not is_voting_open:
    frame_dig 4
    bnz vote_after_if_else@19
    // smart_contracts/proposal/contract.py:205
    // return typ.Error(err.ARC_65_PREFIX + err.VOTING_PERIOD_EXPIRED)
    pushbytes 0x00194552523a566f74696e6720506572696f642045787069726564
    frame_bury 0
    // smart_contracts/proposal/contract.py:798
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20

vote_after_if_else@19:
    // smart_contracts/proposal/contract.py:207
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:798
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20


// smart_contracts.proposal.contract.Proposal.scrutiny() -> void:
scrutiny:
    // smart_contracts/proposal/contract.py:824-825
    // @arc4.abimethod()
    // def scrutiny(self) -> None:
    proto 0 0
    intc_0 // 0
    bytec_2 // ""
    dupn 3
    // smart_contracts/proposal/contract.py:835
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:227
    // assert self.status.value == enm.STATUS_VOTING, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    ==
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:229
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    // smart_contracts/proposal/contract.py:230
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:233
    // not is_voting_open  # voting period has ended
    bz scrutiny_bool_true@8
    // smart_contracts/proposal/contract.py:234
    // or self.voted_members.value
    intc_0 // 0
    bytec 10 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    // smart_contracts/proposal/contract.py:235
    // == self.committee_members.value  # all committee members have voted
    intc_0 // 0
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:234-235
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    ==
    // smart_contracts/proposal/contract.py:233-235
    // not is_voting_open  # voting period has ended
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    bz scrutiny_bool_false@9

scrutiny_bool_true@8:
    intc_1 // 1

scrutiny_bool_merge@10:
    // smart_contracts/proposal/contract.py:232-236
    // assert (
    //     not is_voting_open  # voting period has ended
    //     or self.voted_members.value
    //     == self.committee_members.value  # all committee members have voted
    // ), err.VOTING_ONGOING
    assert // Voting Ongoing
    // smart_contracts/proposal/contract.py:839-841
    // # A category dependent quorum of all xGov Voting Committee (1 xGov, 1 vote) is reached.
    // # Null votes affect this quorum.
    // quorum_bps = self.get_quorum(self.funding_category.value)
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:284
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz scrutiny_else_body@14
    // smart_contracts/proposal/contract.py:286
    // Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    pushbytes 0x71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:285-287
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

scrutiny_after_if_else@18:
    // smart_contracts/proposal/contract.py:296
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:843
    // self.committee_members.value, quorum_bps
    intc_0 // 0
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:412
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    frame_bury 2
    // smart_contracts/proposal/contract.py:846-848
    // # A category dependent weighted quorum of all xGov Voting Committee voting power (1 vote) is reached.
    // # Null votes affect this quorum.
    // weighted_quorum_bps = self.get_weighted_quorum(self.funding_category.value)
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:301
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz scrutiny_else_body@22
    // smart_contracts/proposal/contract.py:303
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    pushbytes 0x77656967687465645f71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:302-304
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

scrutiny_after_if_else@26:
    // smart_contracts/proposal/contract.py:313
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:849
    // total_votes = self.approvals.value + self.rejections.value + self.nulls.value
    intc_0 // 0
    bytec 11 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 12 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    +
    intc_0 // 0
    bytec 15 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    frame_bury 4
    // smart_contracts/proposal/contract.py:851
    // self.committee_votes.value, weighted_quorum_bps
    intc_0 // 0
    bytec 9 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/proposal/contract.py:412
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    frame_bury 3
    // smart_contracts/proposal/contract.py:855
    // self.voted_members.value >= minimum_voters_required
    intc_0 // 0
    bytec 10 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    frame_dig 2
    >=
    // smart_contracts/proposal/contract.py:855-859
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:856
    // and total_votes >= minimum_votes_required
    frame_dig 4
    frame_dig 3
    >=
    // smart_contracts/proposal/contract.py:855-859
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:857-859
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    intc_0 // 0
    bytec 11 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 12 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    >
    // smart_contracts/proposal/contract.py:855-859
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:861
    // self.status.value = UInt64(enm.STATUS_APPROVED)
    bytec_1 // 0x737461747573
    pushint 30 // 30
    app_global_put
    retsub

scrutiny_else_body@4:
    // smart_contracts/proposal/contract.py:863
    // self.status.value = UInt64(enm.STATUS_REJECTED)
    bytec_1 // 0x737461747573
    pushint 40 // 40
    app_global_put
    // smart_contracts/proposal/contract.py:865
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:864-866
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    retsub

scrutiny_else_body@22:
    // smart_contracts/proposal/contract.py:305
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 1
    intc_3 // 20
    ==
    bz scrutiny_else_body@24
    // smart_contracts/proposal/contract.py:307
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    pushbytes 0x77656967687465645f71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:306-308
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@26

scrutiny_else_body@24:
    // smart_contracts/proposal/contract.py:311
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    pushbytes 0x77656967687465645f71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:310-312
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@26

scrutiny_else_body@14:
    // smart_contracts/proposal/contract.py:288
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 1
    intc_3 // 20
    ==
    bz scrutiny_else_body@16
    // smart_contracts/proposal/contract.py:290
    // Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    pushbytes 0x71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:289-291
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@18

scrutiny_else_body@16:
    // smart_contracts/proposal/contract.py:294
    // Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    pushbytes 0x71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:293-295
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@18

scrutiny_bool_false@9:
    intc_0 // 0
    b scrutiny_bool_merge@10


// smart_contracts.proposal.contract.Proposal.review(block: uint64) -> void:
review:
    // smart_contracts/proposal/contract.py:868-869
    // @arc4.abimethod()
    // def review(self, block: bool) -> None:  # noqa: FBT001
    proto 1 0
    // smart_contracts/proposal/contract.py:495
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:496
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    pushbytes 0x78676f765f636f756e63696c
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:495-497
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    // smart_contracts/proposal/contract.py:152
    // assert self.is_council(), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:153
    // assert self.status.value == enm.STATUS_APPROVED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 30 // 30
    ==
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:883
    // if block:
    frame_dig -1
    bz review_else_body@2
    // smart_contracts/proposal/contract.py:884
    // self.status.value = UInt64(enm.STATUS_BLOCKED)
    bytec_1 // 0x737461747573
    pushint 60 // 60
    app_global_put
    // smart_contracts/proposal/contract.py:886-887
    // # slashing: send locked amount to the registry treasury
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:889
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:888-890
    // self.transfer_locked_amount(
    //     receiver=reg_app.address,
    // )
    callsub transfer_locked_amount
    retsub

review_else_body@2:
    // smart_contracts/proposal/contract.py:893
    // self.status.value = UInt64(enm.STATUS_REVIEWED)
    bytec_1 // 0x737461747573
    pushint 45 // 45
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.fund() -> bytes:
fund:
    // smart_contracts/proposal/contract.py:895-896
    // @arc4.abimethod()
    // def fund(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:157
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:158
    // if self.status.value != enm.STATUS_REVIEWED:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 45 // 45
    !=
    bz fund_after_if_else@5
    // smart_contracts/proposal/contract.py:159
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 21 // 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@6:
    // smart_contracts/proposal/contract.py:905
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz fund_after_if_else@2
    // smart_contracts/proposal/contract.py:906
    // return error
    frame_dig 0
    swap
    retsub

fund_after_if_else@2:
    // smart_contracts/proposal/contract.py:908
    // self.status.value = UInt64(enm.STATUS_FUNDED)
    bytec_1 // 0x737461747573
    pushint 50 // 50
    app_global_put
    // smart_contracts/proposal/contract.py:912
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:910-913
    // # refund the locked amount to the proposer
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:915
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub

fund_after_if_else@5:
    // smart_contracts/proposal/contract.py:161
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:904
    // error = self.fund_check_authorization()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@6


// smart_contracts.proposal.contract.Proposal.unassign_voters(voters: bytes) -> void:
unassign_voters:
    // smart_contracts/proposal/contract.py:917-918
    // @arc4.abimethod()
    // def unassign_voters(self, voters: arc4.DynamicArray[arc4.Address]) -> None:
    proto 1 0
    intc_0 // 0
    bytec_2 // ""
    dupn 3
    // smart_contracts/proposal/contract.py:165
    // assert self.is_xgov_backend(), err.UNAUTHORIZED
    callsub is_xgov_backend
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:167
    // self.status.value == enm.STATUS_FUNDED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    ==
    // smart_contracts/proposal/contract.py:167-170
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    // or self.status.value == enm.STATUS_FINAL
    bnz unassign_voters_bool_true@18
    // smart_contracts/proposal/contract.py:168
    // or self.status.value == enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    ==
    // smart_contracts/proposal/contract.py:167-170
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    // or self.status.value == enm.STATUS_FINAL
    bnz unassign_voters_bool_true@18
    // smart_contracts/proposal/contract.py:169
    // or self.status.value == enm.STATUS_REJECTED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    ==
    // smart_contracts/proposal/contract.py:167-170
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    // or self.status.value == enm.STATUS_FINAL
    bnz unassign_voters_bool_true@18
    // smart_contracts/proposal/contract.py:170
    // or self.status.value == enm.STATUS_FINAL
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 20
    ==
    // smart_contracts/proposal/contract.py:167-170
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    // or self.status.value == enm.STATUS_FINAL
    bz unassign_voters_bool_false@19

unassign_voters_bool_true@18:
    intc_1 // 1

unassign_voters_bool_merge@20:
    // smart_contracts/proposal/contract.py:166-171
    // assert (
    //     self.status.value == enm.STATUS_FUNDED
    //     or self.status.value == enm.STATUS_BLOCKED
    //     or self.status.value == enm.STATUS_REJECTED
    //     or self.status.value == enm.STATUS_FINAL
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:933
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz unassign_voters_else_body@6
    // smart_contracts/proposal/contract.py:934-935
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    frame_bury 4
    intc_1 // 1
    frame_bury 2

unassign_voters_for_header@2:
    // smart_contracts/proposal/contract.py:934-935
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    frame_dig 2
    frame_dig 4
    <
    bz unassign_voters_after_if_else@7
    // smart_contracts/proposal/contract.py:936
    // self.assert_same_app_and_method(i)
    frame_dig 2
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:934-935
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    frame_bury 2
    b unassign_voters_for_header@2

unassign_voters_after_if_else@7:
    // smart_contracts/proposal/contract.py:941-942
    // # remove voters
    // for voter in voters:
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 1
    intc_0 // 0
    frame_bury 3

unassign_voters_for_header@8:
    // smart_contracts/proposal/contract.py:941-942
    // # remove voters
    // for voter in voters:
    frame_dig 3
    frame_dig 1
    <
    bz unassign_voters_after_for@13
    frame_dig -1
    extract 2 0
    frame_dig 3
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: Index access is out of bounds
    // smart_contracts/proposal/contract.py:943
    // if voter.native in self.voters:
    bytec 27 // "V"
    swap
    concat
    dup
    frame_bury 0
    box_len
    bury 1
    bz unassign_voters_after_if_else@11
    // smart_contracts/proposal/contract.py:944
    // self.voters_count -= 1
    intc_0 // 0
    bytec 8 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    -
    bytec 8 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:945
    // self.assigned_votes -= self.voters[voter.native].votes.native
    intc_0 // 0
    bytec 13 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    frame_dig 0
    dup
    cover 2
    box_get
    assert // check self.voters entry exists
    intc_0 // 0
    extract_uint64
    -
    bytec 13 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:946
    // del self.voters[voter.native]
    box_del
    pop

unassign_voters_after_if_else@11:
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b unassign_voters_for_header@8

unassign_voters_after_for@13:
    retsub

unassign_voters_else_body@6:
    // smart_contracts/proposal/contract.py:938-939
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b unassign_voters_after_if_else@7

unassign_voters_bool_false@19:
    intc_0 // 0
    b unassign_voters_bool_merge@20


// smart_contracts.proposal.contract.Proposal.decommission() -> bytes:
decommission:
    // smart_contracts/proposal/contract.py:948-949
    // @arc4.abimethod()
    // def decommission(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:175
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:178
    // self.status.value != enm.STATUS_EMPTY
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    // smart_contracts/proposal/contract.py:178-182
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:179
    // and self.status.value != enm.STATUS_DRAFT
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    !=
    // smart_contracts/proposal/contract.py:178-182
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:180
    // and self.status.value != enm.STATUS_FUNDED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    !=
    // smart_contracts/proposal/contract.py:178-182
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:181
    // and self.status.value != enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    !=
    // smart_contracts/proposal/contract.py:178-182
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:182
    // and self.status.value != enm.STATUS_REJECTED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    !=
    // smart_contracts/proposal/contract.py:178-182
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:184
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 21 // 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0

decommission_after_inlined_smart_contracts.proposal.contract.Proposal.decommission_check_authorization@14:
    // smart_contracts/proposal/contract.py:960
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz decommission_after_if_else@2
    // smart_contracts/proposal/contract.py:961
    // return error
    frame_dig 0
    swap
    retsub

decommission_after_if_else@2:
    // smart_contracts/proposal/contract.py:963-964
    // # check no assigned voters
    // if self.voters_count > UInt64(0):
    intc_0 // 0
    bytec 8 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    bz decommission_after_if_else@4
    // smart_contracts/proposal/contract.py:965
    // return typ.Error(err.ARC_65_PREFIX + err.VOTERS_ASSIGNED)
    pushbytes 0x002e4552523a54686572652061726520766f746572732061737369676e656420746f20746869732070726f706f73616c
    swap
    retsub

decommission_after_if_else@4:
    // smart_contracts/proposal/contract.py:967-968
    // # delete metadata box if it exists
    // self.metadata.delete()
    bytec 5 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:970-973
    // # refund the locked amount for DRAFT proposals
    // # for REJECTED proposals, the locked amount is already refunded in the scrutiny method
    // # for EMPTY, FUNDED, or BLOCKED proposals, the locked amount is not refundable
    // if self.status.value == enm.STATUS_DRAFT:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    bz decommission_after_if_else@6
    // smart_contracts/proposal/contract.py:975
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:974-976
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount

decommission_after_if_else@6:
    // smart_contracts/proposal/contract.py:977
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:979
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:980
    // amount=Global.current_application_address.balance,
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:978-981
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:982
    // self.status.value = UInt64(enm.STATUS_DECOMMISSIONED)
    bytec_1 // 0x737461747573
    pushint 70 // 70
    app_global_put
    // smart_contracts/proposal/contract.py:984
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub

decommission_after_if_else@13:
    // smart_contracts/proposal/contract.py:186
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:959
    // error = self.decommission_check_authorization()
    b decommission_after_inlined_smart_contracts.proposal.contract.Proposal.decommission_check_authorization@14


// smart_contracts.proposal.contract.Proposal.delete() -> void:
delete:
    // smart_contracts/proposal/contract.py:190
    // assert self.is_xgov_backend(), err.UNAUTHORIZED
    callsub is_xgov_backend
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:191
    // assert self.status.value == enm.STATUS_DECOMMISSIONED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 70 // 70
    ==
    assert // Wrong Proposal Status
    retsub


// smart_contracts.proposal.contract.Proposal.get_state() -> bytes:
get_state:
    // smart_contracts/proposal/contract.py:1007
    // proposer=arc4.Address(self.proposer.value),
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:1008
    // registry_app_id=arc4.UInt64(self.registry_app_id.value),
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    itob
    // smart_contracts/proposal/contract.py:1009
    // title=arc4.String(self.title.value),
    intc_0 // 0
    bytec 22 // 0x7469746c65
    app_global_get_ex
    assert // check self.title exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/proposal/contract.py:1010
    // submission_ts=arc4.UInt64(self.submission_ts.value),
    intc_0 // 0
    bytec 17 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    itob
    // smart_contracts/proposal/contract.py:1011
    // finalization_ts=arc4.UInt64(self.finalization_ts.value),
    intc_0 // 0
    bytec 23 // 0x66696e616c697a6174696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.finalization_ts exists
    itob
    // smart_contracts/proposal/contract.py:1012
    // vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    intc_0 // 0
    bytec 18 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    itob
    // smart_contracts/proposal/contract.py:1013
    // status=arc4.UInt64(self.status.value),
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    itob
    // smart_contracts/proposal/contract.py:1014
    // funding_category=arc4.UInt64(self.funding_category.value),
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    assert // check self.funding_category exists
    itob
    // smart_contracts/proposal/contract.py:1015
    // focus=arc4.UInt8(self.focus.value),
    intc_0 // 0
    bytec 24 // 0x666f637573
    app_global_get_ex
    assert // check self.focus exists
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:1016
    // funding_type=arc4.UInt64(self.funding_type.value),
    intc_0 // 0
    bytec 25 // 0x66756e64696e675f74797065
    app_global_get_ex
    assert // check self.funding_type exists
    itob
    // smart_contracts/proposal/contract.py:1017
    // requested_amount=arc4.UInt64(self.requested_amount.value),
    intc_0 // 0
    bytec 26 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    itob
    // smart_contracts/proposal/contract.py:1018
    // locked_amount=arc4.UInt64(self.locked_amount.value),
    intc_0 // 0
    bytec 14 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    itob
    // smart_contracts/proposal/contract.py:1019
    // committee_id=self.committee_id.value.copy(),
    intc_0 // 0
    bytec 19 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    // smart_contracts/proposal/contract.py:1020
    // committee_members=arc4.UInt64(self.committee_members.value),
    intc_0 // 0
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    itob
    // smart_contracts/proposal/contract.py:1021
    // committee_votes=arc4.UInt64(self.committee_votes.value),
    intc_0 // 0
    bytec 9 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    itob
    // smart_contracts/proposal/contract.py:1022
    // voted_members=arc4.UInt64(self.voted_members.value),
    intc_0 // 0
    bytec 10 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    // smart_contracts/proposal/contract.py:1023
    // approvals=arc4.UInt64(self.approvals.value),
    intc_0 // 0
    bytec 11 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    // smart_contracts/proposal/contract.py:1024
    // rejections=arc4.UInt64(self.rejections.value),
    intc_0 // 0
    bytec 12 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    // smart_contracts/proposal/contract.py:1025
    // nulls=arc4.UInt64(self.nulls.value),
    intc_0 // 0
    bytec 15 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    // smart_contracts/proposal/contract.py:1006-1026
    // return typ.ProposalTypedGlobalState(
    //     proposer=arc4.Address(self.proposer.value),
    //     registry_app_id=arc4.UInt64(self.registry_app_id.value),
    //     title=arc4.String(self.title.value),
    //     submission_ts=arc4.UInt64(self.submission_ts.value),
    //     finalization_ts=arc4.UInt64(self.finalization_ts.value),
    //     vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    //     status=arc4.UInt64(self.status.value),
    //     funding_category=arc4.UInt64(self.funding_category.value),
    //     focus=arc4.UInt8(self.focus.value),
    //     funding_type=arc4.UInt64(self.funding_type.value),
    //     requested_amount=arc4.UInt64(self.requested_amount.value),
    //     locked_amount=arc4.UInt64(self.locked_amount.value),
    //     committee_id=self.committee_id.value.copy(),
    //     committee_members=arc4.UInt64(self.committee_members.value),
    //     committee_votes=arc4.UInt64(self.committee_votes.value),
    //     voted_members=arc4.UInt64(self.voted_members.value),
    //     approvals=arc4.UInt64(self.approvals.value),
    //     rejections=arc4.UInt64(self.rejections.value),
    //     nulls=arc4.UInt64(self.nulls.value),
    // )
    uncover 18
    uncover 18
    concat
    pushbytes 0x00bb
    concat
    uncover 16
    concat
    uncover 15
    concat
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    retsub
