#pragma version 10
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 10 20 10000
    bytecblock 0x0000 0x737461747573 0x 0x66696e616c697a6564 0x70726f706f736572 0x72656769737472795f6170705f6964 0x66756e64696e675f63617465676f7279 "M" 0x636f6d6d69747465655f6d656d62657273 "voters_count" 0x151f7c75 0x636f6d6d69747465655f766f746573 0x766f7465645f6d656d62657273 0x617070726f76616c73 0x72656a656374696f6e73 "assigned_votes" 0x00 0x6c6f636b65645f616d6f756e74 0x6e756c6c73 0x6f70656e5f74696d657374616d70 0x766f74655f6f70656e696e675f74696d657374616d70 0x636f6d6d69747465655f6964 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564 "V" 0x7469746c65 0x7375626d697373696f6e5f74696d657374616d70 0x666f637573 0x66756e64696e675f74797065 0x7265717565737465645f616d6f756e74 "metadata_uploaded" 0x78676f765f6461656d6f6e
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/proposal/contract.py:46
    // Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 3 // 3
    ==
    // smart_contracts/proposal/contract.py:44-47
    // # Preconditions
    // assert (
    //     Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    // ), err.WRONG_GLOBAL_BYTES
    assert // Wrong Global Bytes allocation
    // smart_contracts/proposal/contract.py:48
    // assert Txn.global_num_uint == prop_cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    intc_3 // 20
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/proposal/contract.py:49
    // assert Txn.local_num_byte_slice == prop_cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/proposal/contract.py:50
    // assert Txn.local_num_uint == prop_cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/proposal/contract.py:55
    // key=prop_cfg.GS_KEY_PROPOSER,
    bytec 4 // 0x70726f706f736572
    // smart_contracts/proposal/contract.py:54
    // Account(),
    global ZeroAddress
    // smart_contracts/proposal/contract.py:52-56
    // # Global Variables
    // self.proposer = GlobalState(
    //     Account(),
    //     key=prop_cfg.GS_KEY_PROPOSER,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:59
    // key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    bytec 5 // 0x72656769737472795f6170705f6964
    // smart_contracts/proposal/contract.py:58
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:57-60
    // self.registry_app_id = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:63
    // key=prop_cfg.GS_KEY_TITLE,
    bytec 24 // 0x7469746c65
    // smart_contracts/proposal/contract.py:62
    // String(),
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:61-64
    // self.title = GlobalState(
    //     String(),
    //     key=prop_cfg.GS_KEY_TITLE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:67
    // key=prop_cfg.GS_KEY_OPEN_TS,
    bytec 19 // 0x6f70656e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:66
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:65-68
    // self.open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:71
    // key=prop_cfg.GS_KEY_SUBMISSION_TS,
    bytec 25 // 0x7375626d697373696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:70
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:69-72
    // self.submission_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_SUBMISSION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:75
    // key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    bytec 20 // 0x766f74655f6f70656e696e675f74696d657374616d70
    // smart_contracts/proposal/contract.py:74
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:73-76
    // self.vote_open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:79
    // key=prop_cfg.GS_KEY_STATUS,
    bytec_1 // 0x737461747573
    // smart_contracts/proposal/contract.py:78
    // UInt64(enm.STATUS_EMPTY),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:77-80
    // self.status = GlobalState(
    //     UInt64(enm.STATUS_EMPTY),
    //     key=prop_cfg.GS_KEY_STATUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:83
    // key=prop_cfg.GS_KEY_FINALIZED,
    bytec_3 // 0x66696e616c697a6564
    // smart_contracts/proposal/contract.py:82
    // False,  # noqa: FBT003
    intc_0 // 0
    // smart_contracts/proposal/contract.py:81-84
    // self.finalized = GlobalState(
    //     False,  # noqa: FBT003
    //     key=prop_cfg.GS_KEY_FINALIZED,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:87
    // key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    bytec 6 // 0x66756e64696e675f63617465676f7279
    // smart_contracts/proposal/contract.py:86
    // UInt64(enm.FUNDING_CATEGORY_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:85-88
    // self.funding_category = GlobalState(
    //     UInt64(enm.FUNDING_CATEGORY_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:91
    // key=prop_cfg.GS_KEY_FOCUS,
    bytec 26 // 0x666f637573
    // smart_contracts/proposal/contract.py:90
    // UInt64(enm.FOCUS_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:89-92
    // self.focus = GlobalState(
    //     UInt64(enm.FOCUS_NULL),
    //     key=prop_cfg.GS_KEY_FOCUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:95
    // key=prop_cfg.GS_KEY_FUNDING_TYPE,
    bytec 27 // 0x66756e64696e675f74797065
    // smart_contracts/proposal/contract.py:94
    // UInt64(enm.FUNDING_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:93-96
    // self.funding_type = GlobalState(
    //     UInt64(enm.FUNDING_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_TYPE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:99
    // key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    bytec 28 // 0x7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:98
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:97-100
    // self.requested_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:103
    // key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    bytec 17 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:102
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:101-104
    // self.locked_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:107
    // key=prop_cfg.GS_KEY_COMMITTEE_ID,
    bytec 21 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:106
    // typ.Bytes32.from_bytes(b""),
    bytec_2 // 0x
    // smart_contracts/proposal/contract.py:105-108
    // self.committee_id = GlobalState(
    //     typ.Bytes32.from_bytes(b""),
    //     key=prop_cfg.GS_KEY_COMMITTEE_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:111
    // key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:110
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:109-112
    // self.committee_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:115
    // key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    bytec 11 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:114
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:113-116
    // self.committee_votes = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:119
    // key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    bytec 12 // 0x766f7465645f6d656d62657273
    // smart_contracts/proposal/contract.py:118
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:117-120
    // self.voted_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:123
    // key=prop_cfg.GS_KEY_APPROVALS,
    bytec 13 // 0x617070726f76616c73
    // smart_contracts/proposal/contract.py:122
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:121-124
    // self.approvals = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_APPROVALS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:127
    // key=prop_cfg.GS_KEY_REJECTIONS,
    bytec 14 // 0x72656a656374696f6e73
    // smart_contracts/proposal/contract.py:126
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:125-128
    // self.rejections = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REJECTIONS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:131
    // key=prop_cfg.GS_KEY_NULLS,
    bytec 18 // 0x6e756c6c73
    // smart_contracts/proposal/contract.py:130
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:129-132
    // self.nulls = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_NULLS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:133
    // self.voters_count = UInt64(0)
    bytec 9 // "voters_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:134
    // self.assigned_votes = UInt64(0)
    bytec 15 // "assigned_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:135
    // self.metadata_uploaded = False
    bytec 29 // "metadata_uploaded"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x24378d3c // method "delete()void"
    txna ApplicationArgs 0
    match main_delete_route@4

main_switch_case_next@5:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@22
    pushbytess 0xedaeb9ca 0x7143994f 0x7371321a 0x34e613ca 0x0d9ab0d7 0x1841a0d2 0x734dbecc 0x212d9f07 0x8a5e4c80 0x2ac19b05 0x802069b4 0xa8c6f80a 0xba8828a2 0xdbd83dd9 // method "open(pay,string,uint64,uint64,uint8)void", method "upload_metadata(byte[],bool)void", method "drop()string", method "submit()void", method "assign_voters((address,uint64)[])void", method "vote(address,uint64,uint64)string", method "scrutiny()void", method "review(bool)void", method "fund()string", method "unassign_voters(address[])void", method "finalize()string", method "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)", method "get_voter_box(address)((uint64,bool),bool)", method "op_up()void"
    txna ApplicationArgs 0
    match open upload_metadata drop submit assign_voters vote scrutiny review fund unassign_voters finalize get_state get_voter_box main_op_up_route@20
    err

main_op_up_route@20:
    // smart_contracts/proposal/contract.py:1061
    // @arc4.abimethod()
    intc_1 // 1
    return

main_create_NoOp@22:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x216b1e07 // method "create(address)string"
    txna ApplicationArgs 0
    match create
    err

main_delete_route@4:
    // smart_contracts/proposal/contract.py:989
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be DeleteApplication && can only call when not creating
    b delete


// smart_contracts.proposal.contract.Proposal.create[routing]() -> void:
create:
    intc_0 // 0
    dup
    bytec_2 // ""
    dup
    // smart_contracts/proposal/contract.py:550
    // @arc4.abimethod(create="require")
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/proposal/contract.py:565
    // Global.caller_application_id != 0
    global CallerApplicationID
    // smart_contracts/proposal/contract.py:564-566
    // assert (
    //     Global.caller_application_id != 0
    // ), err.UNAUTHORIZED  # Only callable by another contract
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:568
    // self.proposer.value = proposer.native
    bytec 4 // 0x70726f706f736572
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:569
    // self.registry_app_id.value = Global.caller_application_id
    bytec 5 // 0x72656769737472795f6170705f6964
    global CallerApplicationID
    app_global_put
    // smart_contracts/proposal/contract.py:328
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    bytec 21 // 0x636f6d6d69747465655f6964
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:327-329
    // committee_id = typ.Bytes32.from_bytes(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    // )
    dup
    // smart_contracts/proposal/contract.py:330
    // if committee_id == typ.Bytes32.from_bytes(b""):
    bytec_2 // 0x
    ==
    bz create_after_if_else@3
    // smart_contracts/proposal/contract.py:331
    // return typ.Error(err.ARC_65_PREFIX + err.EMPTY_COMMITTEE_ID)
    pushbytes 0x00164552523a456d70747920436f6d6d6974746565204944

create_after_inlined_smart_contracts.proposal.contract.Proposal.verify_and_set_committee@12:
    // smart_contracts/proposal/contract.py:550
    // @arc4.abimethod(create="require")
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

create_after_if_else@3:
    // smart_contracts/proposal/contract.py:334
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:333-335
    // committee_members, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    callsub get_uint_from_registry_config
    dup
    cover 2
    bury 6
    bury 4
    // smart_contracts/proposal/contract.py:336
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    bury 6
    bytec_0 // 0x0000
    !=
    bz create_after_if_else@5
    dig 3
    // smart_contracts/proposal/contract.py:571
    // return self.verify_and_set_committee()
    b create_after_inlined_smart_contracts.proposal.contract.Proposal.verify_and_set_committee@12

create_after_if_else@5:
    // smart_contracts/proposal/contract.py:338
    // if committee_members <= UInt64(0):
    dig 2
    intc_0 // 0
    <=
    bz create_after_if_else@7
    // smart_contracts/proposal/contract.py:339
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_COMMITTEE_MEMBERS)
    pushbytes 0x001b4552523a57726f6e6720436f6d6d6974746565204d656d62657273
    // smart_contracts/proposal/contract.py:571
    // return self.verify_and_set_committee()
    b create_after_inlined_smart_contracts.proposal.contract.Proposal.verify_and_set_committee@12

create_after_if_else@7:
    // smart_contracts/proposal/contract.py:342
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 11 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:341-343
    // committee_votes, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    callsub get_uint_from_registry_config
    dup
    cover 2
    bury 6
    bury 3
    // smart_contracts/proposal/contract.py:336
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:344
    // if error != typ.Error(""):
    !=
    bz create_after_if_else@9
    dig 3
    // smart_contracts/proposal/contract.py:571
    // return self.verify_and_set_committee()
    b create_after_inlined_smart_contracts.proposal.contract.Proposal.verify_and_set_committee@12

create_after_if_else@9:
    // smart_contracts/proposal/contract.py:346
    // if committee_votes <= UInt64(0):
    dig 1
    intc_0 // 0
    <=
    bz create_after_if_else@11
    // smart_contracts/proposal/contract.py:347
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_COMMITTEE_VOTES)
    pushbytes 0x00194552523a57726f6e6720436f6d6d697474656520566f746573
    // smart_contracts/proposal/contract.py:571
    // return self.verify_and_set_committee()
    b create_after_inlined_smart_contracts.proposal.contract.Proposal.verify_and_set_committee@12

create_after_if_else@11:
    // smart_contracts/proposal/contract.py:349
    // self.committee_id.value = committee_id.copy()
    bytec 21 // 0x636f6d6d69747465655f6964
    dig 1
    app_global_put
    // smart_contracts/proposal/contract.py:350
    // self.committee_members.value = committee_members
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    dig 3
    app_global_put
    // smart_contracts/proposal/contract.py:351
    // self.committee_votes.value = committee_votes
    bytec 11 // 0x636f6d6d69747465655f766f746573
    dig 2
    app_global_put
    dig 4
    // smart_contracts/proposal/contract.py:571
    // return self.verify_and_set_committee()
    b create_after_inlined_smart_contracts.proposal.contract.Proposal.verify_and_set_committee@12


// smart_contracts.proposal.contract.Proposal.open[routing]() -> void:
open:
    intc_0 // 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:573
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    // smart_contracts/proposal/contract.py:606
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:391
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:393
    // self.status.value == enm.STATUS_EMPTY and not self.finalized.value
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    bnz open_bool_false@4
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz open_bool_false@4
    intc_1 // 1

open_bool_merge@5:
    // smart_contracts/proposal/contract.py:392-394
    // assert (
    //     self.status.value == enm.STATUS_EMPTY and not self.finalized.value
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:611
    // title.native, funding_type.as_uint64(), requested_amount.as_uint64()
    dig 3
    extract 2 0
    dup
    bury 10
    dig 3
    btoi
    dup
    cover 2
    bury 10
    dig 3
    btoi
    bury 8
    // smart_contracts/proposal/contract.py:404
    // assert title.bytes.length <= const.TITLE_MAX_BYTES, err.WRONG_TITLE_LENGTH
    dup
    len
    pushint 123 // 123
    <=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:405
    // assert title != "", err.WRONG_TITLE_LENGTH
    bytec_2 // ""
    !=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:408
    // funding_type == enm.FUNDING_PROACTIVE
    intc_2 // 10
    ==
    // smart_contracts/proposal/contract.py:408-409
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bnz open_bool_true@9
    // smart_contracts/proposal/contract.py:409
    // or funding_type == enm.FUNDING_RETROACTIVE
    dig 7
    intc_3 // 20
    ==
    // smart_contracts/proposal/contract.py:408-409
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bz open_bool_false@10

open_bool_true@9:
    intc_1 // 1

open_bool_merge@11:
    // smart_contracts/proposal/contract.py:407-410
    // assert (
    //     funding_type == enm.FUNDING_PROACTIVE
    //     or funding_type == enm.FUNDING_RETROACTIVE
    // ), err.WRONG_FUNDING_TYPE
    assert // Wrong Funding Type
    // smart_contracts/proposal/contract.py:413
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    pushbytes 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:412-414
    // min_requested_amount, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:415
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:418
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:417-419
    // max_requested_amount_large, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:415
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:420
    // assert error == typ.Error(""), err.MISSING_CONFIG
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:422
    // assert requested_amount >= min_requested_amount, err.WRONG_MIN_REQUESTED_AMOUNT
    dig 7
    dup
    uncover 3
    >=
    assert // Requested amount is less than the minimum requested amount
    // smart_contracts/proposal/contract.py:424
    // requested_amount <= max_requested_amount_large
    dup
    uncover 2
    <=
    // smart_contracts/proposal/contract.py:423-425
    // assert (
    //     requested_amount <= max_requested_amount_large
    // ), err.WRONG_MAX_REQUESTED_AMOUNT
    assert // Requested amount is more than the maximum requested amount
    // smart_contracts/proposal/contract.py:448
    // expected_lock_amount = self.get_expected_locked_amount(requested_amount)
    dup
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:450
    // assert payment.sender == self.proposer.value, err.WRONG_SENDER
    dig 6
    dup
    gtxns Sender
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    assert // Wrong Sender
    // smart_contracts/proposal/contract.py:452
    // payment.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/proposal/contract.py:451-453
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/proposal/contract.py:454
    // assert payment.amount == expected_lock_amount, err.WRONG_LOCKED_AMOUNT
    gtxns Amount
    ==
    assert // Locked amount is incorrect
    // smart_contracts/proposal/contract.py:615
    // self.title.value = title.native
    bytec 24 // 0x7469746c65
    dig 10
    app_global_put
    // smart_contracts/proposal/contract.py:459
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    // smart_contracts/proposal/contract.py:458-460
    // max_requested_amount_small, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:415
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:461
    // assert error == typ.Error(""), err.MISSING_CONFIG
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:464
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    // smart_contracts/proposal/contract.py:463-465
    // max_requested_amount_medium, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    swap
    bury 10
    // smart_contracts/proposal/contract.py:415
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:466
    // assert error == typ.Error(""), err.MISSING_CONFIG
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:468
    // if requested_amount <= max_requested_amount_small:
    <=
    bz open_else_body@17
    // smart_contracts/proposal/contract.py:469
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_SMALL)
    bytec 6 // 0x66756e64696e675f63617465676f7279
    intc_2 // 10
    app_global_put

open_after_if_else@20:
    // smart_contracts/proposal/contract.py:617
    // self.funding_type.value = funding_type.as_uint64()
    bytec 27 // 0x66756e64696e675f74797065
    dig 8
    app_global_put
    // smart_contracts/proposal/contract.py:618
    // self.requested_amount.value = requested_amount.as_uint64()
    bytec 28 // 0x7265717565737465645f616d6f756e74
    dig 6
    dup
    cover 2
    app_global_put
    // smart_contracts/proposal/contract.py:619
    // self.focus.value = focus.as_uint64()
    dig 1
    btoi
    bytec 26 // 0x666f637573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:620-622
    // self.locked_amount.value = self.get_expected_locked_amount(
    //     requested_amount.as_uint64()
    // )
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:620
    // self.locked_amount.value = self.get_expected_locked_amount(
    bytec 17 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:620-622
    // self.locked_amount.value = self.get_expected_locked_amount(
    //     requested_amount.as_uint64()
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:623
    // self.open_ts.value = Global.latest_timestamp
    bytec 19 // 0x6f70656e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:624
    // self.status.value = UInt64(enm.STATUS_DRAFT)
    bytec_1 // 0x737461747573
    intc_2 // 10
    app_global_put
    // smart_contracts/proposal/contract.py:573
    // @arc4.abimethod()
    intc_1 // 1
    return

open_else_body@17:
    // smart_contracts/proposal/contract.py:470
    // elif requested_amount <= max_requested_amount_medium:
    dig 5
    dig 7
    <=
    bz open_else_body@19
    // smart_contracts/proposal/contract.py:471
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_MEDIUM)
    bytec 6 // 0x66756e64696e675f63617465676f7279
    intc_3 // 20
    app_global_put
    b open_after_if_else@20

open_else_body@19:
    // smart_contracts/proposal/contract.py:473
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_LARGE)
    bytec 6 // 0x66756e64696e675f63617465676f7279
    pushint 33 // 33
    app_global_put
    b open_after_if_else@20

open_bool_false@10:
    intc_0 // 0
    b open_bool_merge@11

open_bool_false@4:
    intc_0 // 0
    b open_bool_merge@5


// smart_contracts.proposal.contract.Proposal.upload_metadata[routing]() -> void:
upload_metadata:
    // smart_contracts/proposal/contract.py:626
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    dup
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    // smart_contracts/proposal/contract.py:643
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:383
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:387
    // assert payload.length > 0, err.EMPTY_PAYLOAD
    swap
    assert // Empty payload
    // smart_contracts/proposal/contract.py:648
    // self.metadata_uploaded = True
    bytec 29 // "metadata_uploaded"
    intc_1 // 1
    app_global_put
    // smart_contracts/proposal/contract.py:650
    // if is_first_in_group:
    bytec 16 // 0x00
    !=
    bz upload_metadata_else_body@3
    // smart_contracts/proposal/contract.py:651-652
    // # clear and write the metadata to the box
    // del self.metadata.value
    bytec 7 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:653
    // self.metadata.value = payload.native
    extract 2 0
    bytec 7 // "M"
    box_del
    pop
    bytec 7 // "M"
    swap
    box_put

upload_metadata_after_if_else@4:
    // smart_contracts/proposal/contract.py:626
    // @arc4.abimethod()
    intc_1 // 1
    return

upload_metadata_else_body@3:
    // smart_contracts/proposal/contract.py:655-656
    // # append the metadata to the box
    // old_size = self.metadata.length
    bytec 7 // "M"
    box_len
    assert // check self.metadata exists
    // smart_contracts/proposal/contract.py:657
    // self.metadata.resize(self.metadata.length + payload.length)
    dup
    dig 3
    +
    bytec 7 // "M"
    swap
    box_resize
    // smart_contracts/proposal/contract.py:658
    // self.metadata.replace(old_size, payload.native)
    swap
    extract 2 0
    bytec 7 // "M"
    cover 2
    box_replace
    b upload_metadata_after_if_else@4


// smart_contracts.proposal.contract.Proposal.drop[routing]() -> void:
drop:
    intc_0 // 0
    dup
    // smart_contracts/proposal/contract.py:376
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:377
    // if self.status.value != enm.STATUS_DRAFT or self.finalized.value:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    !=
    bnz drop_if_body@7
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bz drop_after_if_else@8

drop_if_body@7:
    // smart_contracts/proposal/contract.py:378
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    bury 1

drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@9:
    // smart_contracts/proposal/contract.py:671
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    bury 2
    dup
    bytec_0 // 0x0000
    !=
    bz drop_after_if_else@3
    dup

drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop@4:
    // smart_contracts/proposal/contract.py:660
    // @arc4.abimethod()
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

drop_after_if_else@3:
    // smart_contracts/proposal/contract.py:675
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:674-676
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:678
    // del self.metadata.value
    bytec 7 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:679
    // self.finalized.value = True
    bytec_3 // 0x66696e616c697a6564
    intc_1 // 1
    app_global_put
    dig 1
    // smart_contracts/proposal/contract.py:660
    // @arc4.abimethod()
    b drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop@4

drop_after_if_else@8:
    // smart_contracts/proposal/contract.py:379
    // return typ.Error("")
    bytec_0 // 0x0000
    bury 1
    // smart_contracts/proposal/contract.py:670
    // error = self.drop_check_authorization()
    b drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@9


// smart_contracts.proposal.contract.Proposal.submit[routing]() -> void:
submit:
    intc_0 // 0
    // smart_contracts/proposal/contract.py:695
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:365
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:367
    // discussion_duration = Global.latest_timestamp - self.open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 19 // 0x6f70656e5f74696d657374616d70
    app_global_get_ex
    assert // check self.open_ts exists
    -
    // smart_contracts/proposal/contract.py:369
    // self.funding_category.value
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:260
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz submit_else_body@3
    // smart_contracts/proposal/contract.py:262
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:261-263
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    bury 4

submit_after_if_else@7:
    // smart_contracts/proposal/contract.py:272
    // assert error == typ.Error(""), err.MISSING_CONFIG
    dig 3
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:372
    // assert discussion_duration >= minimum_discussion_duration, err.TOO_EARLY
    dig 2
    <=
    assert // Too early
    // smart_contracts/proposal/contract.py:699
    // self.status.value = UInt64(enm.STATUS_SUBMITTED)
    bytec_1 // 0x737461747573
    intc_3 // 20
    app_global_put
    // smart_contracts/proposal/contract.py:700
    // self.submission_ts.value = Global.latest_timestamp
    bytec 25 // 0x7375626d697373696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:703
    // Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    pushbytes 0x6f70656e5f70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:702-704
    // open_proposal_fee, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:272
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:705
    // assert error == typ.Error(""), err.MISSING_CONFIG
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:707
    // assert self.metadata_uploaded, err.MISSING_METADATA
    intc_0 // 0
    bytec 29 // "metadata_uploaded"
    app_global_get_ex
    assert // check self.metadata_uploaded exists
    assert // Missing Metadata
    // smart_contracts/proposal/contract.py:710
    // Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    pushbytes 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    // smart_contracts/proposal/contract.py:709-711
    // daemon_ops_funding_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:272
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:712
    // assert error == typ.Error(""), err.MISSING_CONFIG
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:716
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    bytec 30 // 0x78676f765f6461656d6f6e
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:715-717
    // receiver=Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    // ),
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:431
    // return amount * fraction_in_bps // const.BPS
    cover 2
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:714-721
    // self.pay(
    //     receiver=Account(
    //         self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    //     ),
    //     amount=self.relative_to_absolute_amount(
    //         open_proposal_fee, daemon_ops_funding_bps
    //     ),
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:683
    // @arc4.abimethod()
    intc_1 // 1
    return

submit_else_body@3:
    // smart_contracts/proposal/contract.py:264
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dup
    intc_3 // 20
    ==
    bz submit_else_body@5
    // smart_contracts/proposal/contract.py:266
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:265-267
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    bury 4
    b submit_after_if_else@7

submit_else_body@5:
    // smart_contracts/proposal/contract.py:270
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:269-271
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    bury 4
    b submit_after_if_else@7


// smart_contracts.proposal.contract.Proposal.assign_voters[routing]() -> void:
assign_voters:
    bytec_2 // ""
    dup
    // smart_contracts/proposal/contract.py:735
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts.common.abi_types.CommitteeMember>
    // smart_contracts/proposal/contract.py:248
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:249
    // assert self.status.value == enm.STATUS_SUBMITTED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 20
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:759
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz assign_voters_else_body@7
    // smart_contracts/proposal/contract.py:760-761
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    bury 3
    intc_1 // 1
    bury 4

assign_voters_for_header@3:
    // smart_contracts/proposal/contract.py:760-761
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    dig 3
    dig 3
    <
    bz assign_voters_after_if_else@8
    // smart_contracts/proposal/contract.py:762
    // self.assert_same_app_and_method(i)
    dig 3
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:760-761
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    bury 4
    b assign_voters_for_header@3

assign_voters_after_if_else@8:
    // smart_contracts/proposal/contract.py:767
    // for i in urange(voters.length):
    intc_0 // 0
    bury 4

assign_voters_for_header@9:
    // smart_contracts/proposal/contract.py:767
    // for i in urange(voters.length):
    dig 3
    dig 1
    <
    bz assign_voters_after_for@12
    // smart_contracts/proposal/contract.py:769
    // voters[i].address.native, voters[i].voting_power.as_uint64()
    dig 1
    extract 2 0
    dig 4
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dig 1
    extract 32 8
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/proposal/contract.py:255
    // assert voter not in self.voters, err.VOTER_ALREADY_ASSIGNED
    bytec 23 // "V"
    uncover 3
    concat
    dup
    box_len
    bury 1
    !
    assert // Voter Already Assigned
    // smart_contracts/proposal/contract.py:256
    // assert voting_power > 0, err.INVALID_VOTING_POWER
    dig 1
    assert // Invalid Voting Power
    // smart_contracts/proposal/contract.py:727-730
    // self.voters[voter] = typ.VoterBox(
    //     votes=arc4.UInt64(voting_power),
    //     voted=arc4.Bool(False),  # noqa: FBT003
    // )
    uncover 2
    // smart_contracts/proposal/contract.py:729
    // voted=arc4.Bool(False),  # noqa: FBT003
    bytec 16 // 0x00
    // smart_contracts/proposal/contract.py:727-730
    // self.voters[voter] = typ.VoterBox(
    //     votes=arc4.UInt64(voting_power),
    //     voted=arc4.Bool(False),  # noqa: FBT003
    // )
    concat
    box_put
    // smart_contracts/proposal/contract.py:732
    // self.voters_count += 1
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    +
    bytec 9 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:733
    // self.assigned_votes += voting_power
    intc_0 // 0
    bytec 15 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    +
    bytec 15 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:767
    // for i in urange(voters.length):
    intc_1 // 1
    +
    bury 4
    b assign_voters_for_header@9

assign_voters_after_for@12:
    // smart_contracts/proposal/contract.py:772
    // if self.voters_count == self.committee_members.value:
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    bz assign_voters_after_if_else@14
    // smart_contracts/proposal/contract.py:774
    // self.assigned_votes == self.committee_votes.value
    intc_0 // 0
    bytec 15 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    intc_0 // 0
    bytec 11 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    ==
    // smart_contracts/proposal/contract.py:773-775
    // assert (
    //     self.assigned_votes == self.committee_votes.value
    // ), err.VOTING_POWER_MISMATCH
    assert // Voting Power Mismatch
    // smart_contracts/proposal/contract.py:776
    // self.status.value = UInt64(enm.STATUS_VOTING)
    bytec_1 // 0x737461747573
    pushint 25 // 25
    app_global_put
    // smart_contracts/proposal/contract.py:777
    // self.vote_open_ts.value = Global.latest_timestamp
    bytec 20 // 0x766f74655f6f70656e696e675f74696d657374616d70
    global LatestTimestamp
    app_global_put

assign_voters_after_if_else@14:
    // smart_contracts/proposal/contract.py:735
    // @arc4.abimethod()
    intc_1 // 1
    return

assign_voters_else_body@7:
    // smart_contracts/proposal/contract.py:764-765
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b assign_voters_after_if_else@8


// smart_contracts.proposal.contract.Proposal.vote[routing]() -> void:
vote:
    intc_0 // 0
    dupn 4
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:779
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/proposal/contract.py:203
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:205
    // if self.status.value != enm.STATUS_VOTING:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    !=
    bz vote_after_if_else@17
    // smart_contracts/proposal/contract.py:206
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    bury 8

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@22:
    // smart_contracts/proposal/contract.py:802
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    bury 10
    dig 7
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@3
    dig 7

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@6:
    // smart_contracts/proposal/contract.py:779
    // @arc4.abimethod()
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

vote_after_if_else@3:
    // smart_contracts/proposal/contract.py:806
    // voter.native, approvals.as_uint64(), rejections.as_uint64()
    dig 1
    btoi
    bury 6
    dup
    btoi
    bury 4
    // smart_contracts/proposal/contract.py:221
    // if voter not in self.voters:
    bytec 23 // "V"
    dig 3
    concat
    dup
    bury 10
    box_len
    bury 1
    bnz vote_after_if_else@9
    // smart_contracts/proposal/contract.py:222
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_NOT_FOUND)
    pushbytes 0x00134552523a566f746572206e6f7420666f756e64
    bury 8

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@14:
    // smart_contracts/proposal/contract.py:808
    // if error != typ.Error(""):
    dig 7
    // smart_contracts/proposal/contract.py:802
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:808
    // if error != typ.Error(""):
    !=
    bz vote_after_if_else@5
    dig 7
    // smart_contracts/proposal/contract.py:779
    // @arc4.abimethod()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@6

vote_after_if_else@5:
    // smart_contracts/proposal/contract.py:811
    // voter_box = self.voters[voter.native].copy()
    dig 8
    dup
    box_get
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:813
    // votes=voter_box.votes,
    dup
    extract 0 8
    // smart_contracts/proposal/contract.py:814
    // voted=arc4.Bool(True),  # noqa: FBT003
    pushbytes 0x80
    // smart_contracts/proposal/contract.py:812-815
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=voter_box.votes,
    //     voted=arc4.Bool(True),  # noqa: FBT003
    // )
    concat
    uncover 2
    swap
    box_put
    // smart_contracts/proposal/contract.py:817
    // self.voted_members.value += 1
    intc_0 // 0
    bytec 12 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_1 // 1
    +
    bytec 12 // 0x766f7465645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:813
    // votes=voter_box.votes,
    intc_0 // 0
    // smart_contracts/proposal/contract.py:820
    // voter_box.votes.as_uint64() - approvals.as_uint64() - rejections.as_uint64()
    extract_uint64
    dig 6
    dup
    cover 2
    -
    dig 5
    dup
    cover 3
    -
    // smart_contracts/proposal/contract.py:823
    // self.approvals.value += approvals.as_uint64()
    intc_0 // 0
    bytec 13 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    uncover 2
    +
    bytec 13 // 0x617070726f76616c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:824
    // self.rejections.value += rejections.as_uint64()
    intc_0 // 0
    bytec 14 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    uncover 2
    +
    bytec 14 // 0x72656a656374696f6e73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:825
    // self.nulls.value += nulls
    intc_0 // 0
    bytec 18 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    bytec 18 // 0x6e756c6c73
    swap
    app_global_put
    dig 9
    // smart_contracts/proposal/contract.py:779
    // @arc4.abimethod()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@6

vote_after_if_else@9:
    // smart_contracts/proposal/contract.py:224
    // voter_box = self.voters[voter].copy()
    dig 8
    box_get
    swap
    dup
    cover 2
    bury 9
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:225
    // if voter_box.voted:
    pushint 64 // 64
    getbit
    bytec 16 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 16 // 0x00
    !=
    bz vote_after_if_else@11
    // smart_contracts/proposal/contract.py:226
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_ALREADY_VOTED)
    pushbytes 0x00174552523a566f74657220616c726561647920766f746564
    bury 8
    // smart_contracts/proposal/contract.py:805-807
    // error = self.vote_input_validation(
    //     voter.native, approvals.as_uint64(), rejections.as_uint64()
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@14

vote_after_if_else@11:
    // smart_contracts/proposal/contract.py:228
    // if approvals + rejections > voter_box.votes:
    dig 6
    extract 0 8
    dig 6
    dig 5
    +
    itob
    b<
    bz vote_after_if_else@13
    // smart_contracts/proposal/contract.py:229
    // return typ.Error(err.ARC_65_PREFIX + err.VOTES_EXCEEDED)
    pushbytes 0x00124552523a566f746573206578636565646564
    bury 8
    // smart_contracts/proposal/contract.py:805-807
    // error = self.vote_input_validation(
    //     voter.native, approvals.as_uint64(), rejections.as_uint64()
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@14

vote_after_if_else@13:
    dig 9
    bury 8
    // smart_contracts/proposal/contract.py:805-807
    // error = self.vote_input_validation(
    //     voter.native, approvals.as_uint64(), rejections.as_uint64()
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@14

vote_after_if_else@17:
    // smart_contracts/proposal/contract.py:208
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    dup
    cover 2
    bury 10
    bury 6
    // smart_contracts/proposal/contract.py:209
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    bury 12
    bytec_0 // 0x0000
    !=
    bnz vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@22
    // smart_contracts/proposal/contract.py:212
    // if not is_voting_open:
    dig 4
    bnz vote_after_if_else@21
    // smart_contracts/proposal/contract.py:213
    // return typ.Error(err.ARC_65_PREFIX + err.VOTING_PERIOD_EXPIRED)
    pushbytes 0x00194552523a566f74696e6720506572696f642045787069726564
    bury 8
    // smart_contracts/proposal/contract.py:801
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@22

vote_after_if_else@21:
    dig 10
    bury 8
    // smart_contracts/proposal/contract.py:801
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@22


// smart_contracts.proposal.contract.Proposal.scrutiny[routing]() -> void:
scrutiny:
    intc_0 // 0
    bytec_2 // ""
    dupn 3
    // smart_contracts/proposal/contract.py:840
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:235
    // assert self.status.value == enm.STATUS_VOTING, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:237
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    // smart_contracts/proposal/contract.py:238
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:241
    // not is_voting_open  # voting period has ended
    bz scrutiny_bool_true@9
    // smart_contracts/proposal/contract.py:242
    // or self.voted_members.value
    intc_0 // 0
    bytec 12 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    // smart_contracts/proposal/contract.py:243
    // == self.committee_members.value  # all committee members have voted
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:242-243
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    ==
    // smart_contracts/proposal/contract.py:241-243
    // not is_voting_open  # voting period has ended
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    bz scrutiny_bool_false@10

scrutiny_bool_true@9:
    intc_1 // 1

scrutiny_bool_merge@11:
    // smart_contracts/proposal/contract.py:240-244
    // assert (
    //     not is_voting_open  # voting period has ended
    //     or self.voted_members.value
    //     == self.committee_members.value  # all committee members have voted
    // ), err.VOTING_ONGOING
    assert // Voting Ongoing
    // smart_contracts/proposal/contract.py:844-846
    // # A category dependent quorum of all xGov Voting Committee (1 xGov, 1 vote) is reached.
    // # Null votes affect this quorum.
    // quorum_bps = self.get_quorum(self.funding_category.value)
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    bury 6
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:292
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz scrutiny_else_body@15
    // smart_contracts/proposal/contract.py:294
    // Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    pushbytes 0x71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:293-295
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    bury 6

scrutiny_after_if_else@19:
    // smart_contracts/proposal/contract.py:304
    // assert error == typ.Error(""), err.MISSING_CONFIG
    dig 5
    // smart_contracts/proposal/contract.py:238
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:304
    // assert error == typ.Error(""), err.MISSING_CONFIG
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:848
    // self.committee_members.value, quorum_bps
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:431
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    bury 3
    // smart_contracts/proposal/contract.py:851-853
    // # A category dependent weighted quorum of all xGov Voting Committee voting power (1 vote) is reached.
    // # Null votes affect this quorum.
    // weighted_quorum_bps = self.get_weighted_quorum(self.funding_category.value)
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    bury 6
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:309
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz scrutiny_else_body@23
    // smart_contracts/proposal/contract.py:311
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    pushbytes 0x77656967687465645f71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:310-312
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    bury 6

scrutiny_after_if_else@27:
    // smart_contracts/proposal/contract.py:321
    // assert error == typ.Error(""), err.MISSING_CONFIG
    dig 5
    // smart_contracts/proposal/contract.py:238
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:321
    // assert error == typ.Error(""), err.MISSING_CONFIG
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:854
    // total_votes = self.approvals.value + self.rejections.value + self.nulls.value
    intc_0 // 0
    bytec 13 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 14 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    +
    intc_0 // 0
    bytec 18 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    bury 2
    // smart_contracts/proposal/contract.py:856
    // self.committee_votes.value, weighted_quorum_bps
    intc_0 // 0
    bytec 11 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/proposal/contract.py:431
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    bury 2
    // smart_contracts/proposal/contract.py:860
    // self.voted_members.value >= minimum_voters_required
    intc_0 // 0
    bytec 12 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    dig 3
    >=
    // smart_contracts/proposal/contract.py:860-864
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@5
    // smart_contracts/proposal/contract.py:861
    // and total_votes >= minimum_votes_required
    dup
    dig 2
    >=
    // smart_contracts/proposal/contract.py:860-864
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@5
    // smart_contracts/proposal/contract.py:862-864
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    intc_0 // 0
    bytec 13 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 14 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    >
    // smart_contracts/proposal/contract.py:860-864
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@5
    // smart_contracts/proposal/contract.py:866
    // self.status.value = UInt64(enm.STATUS_APPROVED)
    bytec_1 // 0x737461747573
    pushint 30 // 30
    app_global_put

scrutiny_after_if_else@6:
    // smart_contracts/proposal/contract.py:829
    // @arc4.abimethod()
    intc_1 // 1
    return

scrutiny_else_body@5:
    // smart_contracts/proposal/contract.py:868
    // self.status.value = UInt64(enm.STATUS_REJECTED)
    bytec_1 // 0x737461747573
    pushint 40 // 40
    app_global_put
    // smart_contracts/proposal/contract.py:870
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:869-871
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    b scrutiny_after_if_else@6

scrutiny_else_body@23:
    // smart_contracts/proposal/contract.py:313
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dig 3
    intc_3 // 20
    ==
    bz scrutiny_else_body@25
    // smart_contracts/proposal/contract.py:315
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    pushbytes 0x77656967687465645f71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:314-316
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    bury 6
    b scrutiny_after_if_else@27

scrutiny_else_body@25:
    // smart_contracts/proposal/contract.py:319
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    pushbytes 0x77656967687465645f71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:318-320
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    bury 6
    b scrutiny_after_if_else@27

scrutiny_else_body@15:
    // smart_contracts/proposal/contract.py:296
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dig 3
    intc_3 // 20
    ==
    bz scrutiny_else_body@17
    // smart_contracts/proposal/contract.py:298
    // Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    pushbytes 0x71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:297-299
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    bury 6
    b scrutiny_after_if_else@19

scrutiny_else_body@17:
    // smart_contracts/proposal/contract.py:302
    // Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    pushbytes 0x71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:301-303
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    bury 6
    b scrutiny_after_if_else@19

scrutiny_bool_false@10:
    intc_0 // 0
    b scrutiny_bool_merge@11


// smart_contracts.proposal.contract.Proposal.review[routing]() -> void:
review:
    // smart_contracts/proposal/contract.py:873
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    // smart_contracts/proposal/contract.py:514
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:515
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    pushbytes 0x78676f765f636f756e63696c
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:514-516
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    // smart_contracts/proposal/contract.py:159
    // assert self.is_council(), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:160
    // assert self.status.value == enm.STATUS_APPROVED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 30 // 30
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:888
    // if block:
    bz review_else_body@3
    // smart_contracts/proposal/contract.py:889
    // self.status.value = UInt64(enm.STATUS_BLOCKED)
    bytec_1 // 0x737461747573
    pushint 60 // 60
    app_global_put
    // smart_contracts/proposal/contract.py:891-892
    // # slashing: send locked amount to the registry treasury
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:894
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:893-895
    // self.transfer_locked_amount(
    //     receiver=reg_app.address,
    // )
    callsub transfer_locked_amount

review_after_if_else@4:
    // smart_contracts/proposal/contract.py:873
    // @arc4.abimethod()
    intc_1 // 1
    return

review_else_body@3:
    // smart_contracts/proposal/contract.py:898
    // self.status.value = UInt64(enm.STATUS_REVIEWED)
    bytec_1 // 0x737461747573
    pushint 45 // 45
    app_global_put
    // smart_contracts/proposal/contract.py:902
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:900-903
    // # refund the locked amount to the proposer
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    b review_after_if_else@4


// smart_contracts.proposal.contract.Proposal.fund[routing]() -> void:
fund:
    intc_0 // 0
    dup
    // smart_contracts/proposal/contract.py:164
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:165
    // if self.status.value != enm.STATUS_REVIEWED:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 45 // 45
    !=
    bz fund_after_if_else@7
    // smart_contracts/proposal/contract.py:166
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    bury 1

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@8:
    // smart_contracts/proposal/contract.py:915
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    bury 2
    dup
    bytec_0 // 0x0000
    !=
    bz fund_after_if_else@3
    dup

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund@4:
    // smart_contracts/proposal/contract.py:905
    // @arc4.abimethod()
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

fund_after_if_else@3:
    // smart_contracts/proposal/contract.py:918
    // self.status.value = UInt64(enm.STATUS_FUNDED)
    bytec_1 // 0x737461747573
    pushint 50 // 50
    app_global_put
    dig 1
    // smart_contracts/proposal/contract.py:905
    // @arc4.abimethod()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund@4

fund_after_if_else@7:
    // smart_contracts/proposal/contract.py:168
    // return typ.Error("")
    bytec_0 // 0x0000
    bury 1
    // smart_contracts/proposal/contract.py:914
    // error = self.fund_check_authorization()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@8


// smart_contracts.proposal.contract.Proposal.unassign_voters[routing]() -> void:
unassign_voters:
    intc_0 // 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:922
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.static_array<arc4.uint8, 32>>
    // smart_contracts/proposal/contract.py:172
    // if self.status.value == enm.STATUS_SUBMITTED:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 20
    ==
    bz unassign_voters_else_body@17
    // smart_contracts/proposal/contract.py:173
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized

unassign_voters_after_if_else@24:
    // smart_contracts/proposal/contract.py:938
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz unassign_voters_else_body@7
    // smart_contracts/proposal/contract.py:939-940
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    bury 3
    intc_1 // 1
    bury 5

unassign_voters_for_header@3:
    // smart_contracts/proposal/contract.py:939-940
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    dig 4
    dig 3
    <
    bz unassign_voters_after_if_else@8
    // smart_contracts/proposal/contract.py:941
    // self.assert_same_app_and_method(i)
    dig 4
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:939-940
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    bury 5
    b unassign_voters_for_header@3

unassign_voters_after_if_else@8:
    intc_0 // 0
    bury 4

unassign_voters_for_header@9:
    // smart_contracts/proposal/contract.py:946-947
    // # remove voters
    // for voter in voters:
    dig 3
    dig 1
    <
    bz unassign_voters_after_for@14
    dig 1
    extract 2 0
    dig 4
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/proposal/contract.py:948
    // if voter.native in self.voters:
    bytec 23 // "V"
    swap
    concat
    dup
    bury 7
    box_len
    bury 1
    bz unassign_voters_after_if_else@12
    // smart_contracts/proposal/contract.py:949
    // self.voters_count -= 1
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    -
    bytec 9 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:950
    // self.assigned_votes -= self.voters[voter.native].votes.native
    intc_0 // 0
    bytec 15 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    dig 6
    dup
    cover 2
    box_get
    assert // check self.voters entry exists
    intc_0 // 0
    extract_uint64
    -
    bytec 15 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:951
    // del self.voters[voter.native]
    box_del
    pop

unassign_voters_after_if_else@12:
    dig 3
    intc_1 // 1
    +
    bury 4
    b unassign_voters_for_header@9

unassign_voters_after_for@14:
    // smart_contracts/proposal/contract.py:922
    // @arc4.abimethod()
    intc_1 // 1
    return

unassign_voters_else_body@7:
    // smart_contracts/proposal/contract.py:943-944
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b unassign_voters_after_if_else@8

unassign_voters_else_body@17:
    // smart_contracts/proposal/contract.py:176
    // self.status.value == enm.STATUS_FUNDED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    ==
    // smart_contracts/proposal/contract.py:176-178
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bnz unassign_voters_and_contd@20
    // smart_contracts/proposal/contract.py:177
    // or self.status.value == enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    ==
    // smart_contracts/proposal/contract.py:176-178
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bnz unassign_voters_and_contd@20
    // smart_contracts/proposal/contract.py:178
    // or self.status.value == enm.STATUS_REJECTED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    ==
    // smart_contracts/proposal/contract.py:176-178
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bz unassign_voters_bool_false@22

unassign_voters_and_contd@20:
    // smart_contracts/proposal/contract.py:179
    // ) and not self.finalized.value, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz unassign_voters_bool_false@22
    intc_1 // 1

unassign_voters_bool_merge@23:
    // smart_contracts/proposal/contract.py:175-179
    // assert (
    //     self.status.value == enm.STATUS_FUNDED
    //     or self.status.value == enm.STATUS_BLOCKED
    //     or self.status.value == enm.STATUS_REJECTED
    // ) and not self.finalized.value, err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    b unassign_voters_after_if_else@24

unassign_voters_bool_false@22:
    intc_0 // 0
    b unassign_voters_bool_merge@23


// smart_contracts.proposal.contract.Proposal.finalize[routing]() -> void:
finalize:
    intc_0 // 0
    dup
    // smart_contracts/proposal/contract.py:183
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:185
    // if self.finalized.value or (
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    // smart_contracts/proposal/contract.py:185-191
    // if self.finalized.value or (
    //     self.status.value != enm.STATUS_EMPTY
    //     and self.status.value != enm.STATUS_DRAFT
    //     and self.status.value != enm.STATUS_FUNDED
    //     and self.status.value != enm.STATUS_BLOCKED
    //     and self.status.value != enm.STATUS_REJECTED
    // ):
    bnz finalize_if_body@15
    // smart_contracts/proposal/contract.py:186
    // self.status.value != enm.STATUS_EMPTY
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    // smart_contracts/proposal/contract.py:186-190
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:187
    // and self.status.value != enm.STATUS_DRAFT
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    !=
    // smart_contracts/proposal/contract.py:186-190
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:188
    // and self.status.value != enm.STATUS_FUNDED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    !=
    // smart_contracts/proposal/contract.py:186-190
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:189
    // and self.status.value != enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    !=
    // smart_contracts/proposal/contract.py:186-190
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:190
    // and self.status.value != enm.STATUS_REJECTED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    !=
    // smart_contracts/proposal/contract.py:186-190
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16

finalize_if_body@15:
    // smart_contracts/proposal/contract.py:192
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    bury 1

finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize_check_authorization@17:
    // smart_contracts/proposal/contract.py:965
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    bury 2
    dup
    bytec_0 // 0x0000
    !=
    bz finalize_after_if_else@3
    dup

finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8:
    // smart_contracts/proposal/contract.py:953
    // @arc4.abimethod()
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

finalize_after_if_else@3:
    // smart_contracts/proposal/contract.py:968-969
    // # check no assigned voters
    // if self.voters_count > UInt64(0):
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    bz finalize_after_if_else@5
    // smart_contracts/proposal/contract.py:970
    // return typ.Error(err.ARC_65_PREFIX + err.VOTERS_ASSIGNED)
    pushbytes 0x002e4552523a54686572652061726520766f746572732061737369676e656420746f20746869732070726f706f73616c
    // smart_contracts/proposal/contract.py:953
    // @arc4.abimethod()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8

finalize_after_if_else@5:
    // smart_contracts/proposal/contract.py:972-975
    // # refund the locked amount for DRAFT proposals
    // # for REJECTED proposals, the locked amount is already refunded in the scrutiny method
    // # for EMPTY, FUNDED, or BLOCKED proposals, the locked amount is not refundable
    // if self.status.value == enm.STATUS_DRAFT:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    bz finalize_after_if_else@7
    // smart_contracts/proposal/contract.py:977
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:976-978
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount

finalize_after_if_else@7:
    // smart_contracts/proposal/contract.py:979
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:981
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:982
    // amount=Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:983
    // - Global.current_application_address.min_balance,
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:982-983
    // amount=Global.current_application_address.balance
    // - Global.current_application_address.min_balance,
    -
    // smart_contracts/proposal/contract.py:980-984
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance
    //     - Global.current_application_address.min_balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:985
    // self.finalized.value = True
    bytec_3 // 0x66696e616c697a6564
    intc_1 // 1
    app_global_put
    dig 1
    // smart_contracts/proposal/contract.py:953
    // @arc4.abimethod()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8

finalize_after_if_else@16:
    // smart_contracts/proposal/contract.py:194
    // return typ.Error("")
    bytec_0 // 0x0000
    bury 1
    // smart_contracts/proposal/contract.py:964
    // error = self.finalize_check_authorization()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize_check_authorization@17


// smart_contracts.proposal.contract.Proposal.delete[routing]() -> void:
delete:
    // smart_contracts/proposal/contract.py:198
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:199
    // assert self.finalized.value, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:1001-1002
    // # delete metadata box if it exists
    // del self.metadata.value
    bytec 7 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:1004
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:1006
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:1007
    // amount=Global.current_application_address.balance,
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:1005-1008
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:989
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.get_state[routing]() -> void:
get_state:
    // smart_contracts/proposal/contract.py:1019
    // proposer=arc4.Address(self.proposer.value),
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:1020
    // registry_app_id=arc4.UInt64(self.registry_app_id.value),
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    itob
    // smart_contracts/proposal/contract.py:1021
    // title=arc4.String(self.title.value),
    intc_0 // 0
    bytec 24 // 0x7469746c65
    app_global_get_ex
    assert // check self.title exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/proposal/contract.py:1022
    // open_ts=arc4.UInt64(self.open_ts.value),
    intc_0 // 0
    bytec 19 // 0x6f70656e5f74696d657374616d70
    app_global_get_ex
    assert // check self.open_ts exists
    itob
    // smart_contracts/proposal/contract.py:1023
    // submission_ts=arc4.UInt64(self.submission_ts.value),
    intc_0 // 0
    bytec 25 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    itob
    // smart_contracts/proposal/contract.py:1024
    // vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    intc_0 // 0
    bytec 20 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    itob
    // smart_contracts/proposal/contract.py:1025
    // status=arc4.UInt64(self.status.value),
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    itob
    // smart_contracts/proposal/contract.py:1026
    // finalized=arc4.Bool(self.finalized.value),
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bytec 16 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:1027
    // funding_category=arc4.UInt64(self.funding_category.value),
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    assert // check self.funding_category exists
    itob
    // smart_contracts/proposal/contract.py:1028
    // focus=arc4.UInt8(self.focus.value),
    intc_0 // 0
    bytec 26 // 0x666f637573
    app_global_get_ex
    assert // check self.focus exists
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:1029
    // funding_type=arc4.UInt64(self.funding_type.value),
    intc_0 // 0
    bytec 27 // 0x66756e64696e675f74797065
    app_global_get_ex
    assert // check self.funding_type exists
    itob
    // smart_contracts/proposal/contract.py:1030
    // requested_amount=arc4.UInt64(self.requested_amount.value),
    intc_0 // 0
    bytec 28 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    itob
    // smart_contracts/proposal/contract.py:1031
    // locked_amount=arc4.UInt64(self.locked_amount.value),
    intc_0 // 0
    bytec 17 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    itob
    // smart_contracts/proposal/contract.py:1032
    // committee_id=self.committee_id.value.copy(),
    intc_0 // 0
    bytec 21 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    // smart_contracts/proposal/contract.py:1033
    // committee_members=arc4.UInt64(self.committee_members.value),
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    itob
    // smart_contracts/proposal/contract.py:1034
    // committee_votes=arc4.UInt64(self.committee_votes.value),
    intc_0 // 0
    bytec 11 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    itob
    // smart_contracts/proposal/contract.py:1035
    // voted_members=arc4.UInt64(self.voted_members.value),
    intc_0 // 0
    bytec 12 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    // smart_contracts/proposal/contract.py:1036
    // approvals=arc4.UInt64(self.approvals.value),
    intc_0 // 0
    bytec 13 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    // smart_contracts/proposal/contract.py:1037
    // rejections=arc4.UInt64(self.rejections.value),
    intc_0 // 0
    bytec 14 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    // smart_contracts/proposal/contract.py:1038
    // nulls=arc4.UInt64(self.nulls.value),
    intc_0 // 0
    bytec 18 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    // smart_contracts/proposal/contract.py:1018-1039
    // return typ.ProposalTypedGlobalState(
    //     proposer=arc4.Address(self.proposer.value),
    //     registry_app_id=arc4.UInt64(self.registry_app_id.value),
    //     title=arc4.String(self.title.value),
    //     open_ts=arc4.UInt64(self.open_ts.value),
    //     submission_ts=arc4.UInt64(self.submission_ts.value),
    //     vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    //     status=arc4.UInt64(self.status.value),
    //     finalized=arc4.Bool(self.finalized.value),
    //     funding_category=arc4.UInt64(self.funding_category.value),
    //     focus=arc4.UInt8(self.focus.value),
    //     funding_type=arc4.UInt64(self.funding_type.value),
    //     requested_amount=arc4.UInt64(self.requested_amount.value),
    //     locked_amount=arc4.UInt64(self.locked_amount.value),
    //     committee_id=self.committee_id.value.copy(),
    //     committee_members=arc4.UInt64(self.committee_members.value),
    //     committee_votes=arc4.UInt64(self.committee_votes.value),
    //     voted_members=arc4.UInt64(self.voted_members.value),
    //     approvals=arc4.UInt64(self.approvals.value),
    //     rejections=arc4.UInt64(self.rejections.value),
    //     nulls=arc4.UInt64(self.nulls.value),
    // )
    uncover 19
    uncover 19
    concat
    pushbytes 0x00bc
    concat
    uncover 17
    concat
    uncover 16
    concat
    uncover 15
    concat
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:1010
    // @arc4.abimethod(readonly=True)
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.get_voter_box[routing]() -> void:
get_voter_box:
    // smart_contracts/proposal/contract.py:1041
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/proposal/contract.py:1053
    // exists = voter_address.native in self.voters
    bytec 23 // "V"
    swap
    concat
    dup
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/proposal/contract.py:1054
    // if exists:
    bz get_voter_box_else_body@3
    // smart_contracts/proposal/contract.py:1055
    // val = self.voters[voter_address.native].copy()
    dig 1
    box_get
    assert // check self.voters entry exists

get_voter_box_after_if_else@4:
    // smart_contracts/proposal/contract.py:1041
    // @arc4.abimethod(readonly=True)
    bytec 16 // 0x00
    intc_0 // 0
    dig 3
    setbit
    concat
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_voter_box_else_body@3:
    // smart_contracts/proposal/contract.py:1057
    // val = typ.VoterBox(votes=arc4.UInt64(0), voted=arc4.Bool())
    pushbytes 0x000000000000000000
    b get_voter_box_after_if_else@4


// smart_contracts.proposal.contract.Proposal.is_voting_open() -> uint64, bytes:
is_voting_open:
    // smart_contracts/proposal/contract.py:146-147
    // @subroutine
    // def is_voting_open(self) -> tuple[bool, typ.Error]:
    proto 0 2
    intc_0 // 0
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:148
    // voting_duration = Global.latest_timestamp - self.vote_open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 20 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    -
    // smart_contracts/proposal/contract.py:150
    // self.funding_category.value
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:277
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz is_voting_open_else_body@5
    // smart_contracts/proposal/contract.py:279
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    pushbytes 0x766f74696e675f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:278-280
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1

is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8:
    // smart_contracts/proposal/contract.py:152
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz is_voting_open_after_if_else@2
    // smart_contracts/proposal/contract.py:153
    // return False, error
    intc_0 // 0
    frame_dig 0
    frame_bury 1
    frame_bury 0
    retsub

is_voting_open_after_if_else@2:
    // smart_contracts/proposal/contract.py:155
    // return voting_duration <= maximum_voting_duration, typ.Error("")
    frame_dig 2
    frame_dig 1
    <=
    // smart_contracts/proposal/contract.py:152
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    // smart_contracts/proposal/contract.py:155
    // return voting_duration <= maximum_voting_duration, typ.Error("")
    frame_bury 1
    frame_bury 0
    retsub

is_voting_open_else_body@5:
    // smart_contracts/proposal/contract.py:281
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 3
    intc_3 // 20
    ==
    bz is_voting_open_else_body@7
    // smart_contracts/proposal/contract.py:283
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    pushbytes 0x766f74696e675f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:282-284
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:149-151
    // maximum_voting_duration, error = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8

is_voting_open_else_body@7:
    // smart_contracts/proposal/contract.py:287
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    pushbytes 0x766f74696e675f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:286-288
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:149-151
    // maximum_voting_duration, error = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8


// smart_contracts.proposal.contract.Proposal.assert_draft_and_proposer() -> void:
assert_draft_and_proposer:
    // smart_contracts/proposal/contract.py:357
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:359
    // self.status.value == enm.STATUS_DRAFT and not self.finalized.value
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    bz assert_draft_and_proposer_bool_false@3
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz assert_draft_and_proposer_bool_false@3
    intc_1 // 1

assert_draft_and_proposer_bool_merge@4:
    // smart_contracts/proposal/contract.py:358-360
    // assert (
    //     self.status.value == enm.STATUS_DRAFT and not self.finalized.value
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    retsub

assert_draft_and_proposer_bool_false@3:
    intc_0 // 0
    b assert_draft_and_proposer_bool_merge@4


// smart_contracts.proposal.contract.Proposal.get_expected_locked_amount(requested_amount: uint64) -> uint64:
get_expected_locked_amount:
    // smart_contracts/proposal/contract.py:433-434
    // @subroutine
    // def get_expected_locked_amount(self, requested_amount: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/proposal/contract.py:436
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    pushbytes 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    // smart_contracts/proposal/contract.py:435-437
    // proposal_commitment_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:438
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:431
    // return amount * fraction_in_bps // const.BPS
    frame_dig -1
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:439-442
    // return self.relative_to_absolute_amount(
    //     requested_amount,
    //     proposal_commitment_bps,
    // )
    retsub


// smart_contracts.proposal.contract.Proposal.get_uint_from_registry_config(global_state_key: bytes) -> uint64, bytes:
get_uint_from_registry_config:
    // smart_contracts/proposal/contract.py:475-478
    // @subroutine
    // def get_uint_from_registry_config(
    //     self, global_state_key: Bytes
    // ) -> tuple[UInt64, typ.Error]:
    proto 1 2
    // smart_contracts/proposal/contract.py:480
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:479-481
    // value, exists = AppGlobal.get_ex_uint64(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:482
    // error = typ.Error("")
    bytec_0 // 0x0000
    swap
    // smart_contracts/proposal/contract.py:483
    // if not exists:
    bnz get_uint_from_registry_config_after_if_else@2
    // smart_contracts/proposal/contract.py:484
    // error = typ.Error(err.ARC_65_PREFIX + err.MISSING_CONFIG)
    pushbytes 0x00124552523a4d697373696e6720436f6e666967
    frame_bury 1

get_uint_from_registry_config_after_if_else@2:
    // smart_contracts/proposal/contract.py:485
    // return value, error
    frame_dig 0
    frame_dig 1
    uncover 3
    uncover 3
    retsub


// smart_contracts.proposal.contract.Proposal.get_bytes_from_registry_config(global_state_key: bytes) -> bytes:
get_bytes_from_registry_config:
    // smart_contracts/proposal/contract.py:487-488
    // @subroutine
    // def get_bytes_from_registry_config(self, global_state_key: Bytes) -> Bytes:
    proto 1 1
    // smart_contracts/proposal/contract.py:490
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:489-491
    // value, exists = AppGlobal.get_ex_bytes(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:492
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:493
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.check_registry_not_paused() -> void:
check_registry_not_paused:
    // smart_contracts/proposal/contract.py:498
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    pushbytes 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:497-499
    // registry_paused, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:501
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:502
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    retsub


// smart_contracts.proposal.contract.Proposal.is_proposer() -> uint64:
is_proposer:
    // smart_contracts/proposal/contract.py:510
    // return Txn.sender == self.proposer.value
    txn Sender
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_xgov_daemon() -> uint64:
is_xgov_daemon:
    // smart_contracts/proposal/contract.py:520
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:521
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    bytec 30 // 0x78676f765f6461656d6f6e
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:520-522
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_registry_call() -> uint64:
is_registry_call:
    // smart_contracts/proposal/contract.py:526
    // return Global.caller_application_id == self.registry_app_id.value
    global CallerApplicationID
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.pay(receiver: bytes, amount: uint64) -> void:
pay:
    // smart_contracts/proposal/contract.py:528-529
    // @subroutine
    // def pay(self, receiver: Account, amount: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:530-534
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_begin
    frame_dig -1
    itxn_field Amount
    frame_dig -2
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:530
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:533
    // fee=UInt64(0),  # enforces the sender to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:530-534
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.proposal.contract.Proposal.transfer_locked_amount(receiver: bytes) -> void:
transfer_locked_amount:
    // smart_contracts/proposal/contract.py:536-537
    // @subroutine
    // def transfer_locked_amount(self, receiver: Account) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:538
    // self.pay(receiver, self.locked_amount.value)
    intc_0 // 0
    bytec 17 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    frame_dig -1
    swap
    callsub pay
    // smart_contracts/proposal/contract.py:539
    // self.locked_amount.value = UInt64(0)
    bytec 17 // 0x6c6f636b65645f616d6f756e74
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.assert_same_app_and_method(group_index: uint64) -> void:
assert_same_app_and_method:
    // smart_contracts/proposal/contract.py:541-542
    // @subroutine
    // def assert_same_app_and_method(self, group_index: UInt64) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:544
    // GTxn.application_id(group_index) == Global.current_application_id
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/proposal/contract.py:543-545
    // assert (
    //     GTxn.application_id(group_index) == Global.current_application_id
    // ), err.WRONG_APP_ID
    assert // Wrong App ID
    // smart_contracts/proposal/contract.py:546
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    frame_dig -1
    gtxnsa ApplicationArgs 0
    // smart_contracts/proposal/contract.py:546-548
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    //     0
    // ), err.WRONG_METHOD_CALL
    txna ApplicationArgs 0
    ==
    assert // Wrong Method Call
    retsub
