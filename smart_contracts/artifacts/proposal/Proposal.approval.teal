#pragma version 10
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 10 10000
    bytecblock 0x737461747573 0x0000 0x66696e616c697a6564 0x70726f706f736572 0x72656769737472795f6170705f6964 0x00 0x66756e64696e675f63617465676f7279 0x61737369676e65645f6d656d62657273 0x766f7465645f6d656d62657273 0x617070726f76616c73 0x72656a656374696f6e73 0x151f7c75 "M" 0x636f6d6d69747465655f6d656d62657273 0x6e756c6c73 0x636f6d6d69747465655f766f746573 0x61737369676e65645f766f746573 0x636f6d6d69747465655f6964 0x6c6f636b65645f616d6f756e74 0x71756f72756d5f7468726573686f6c64 0x77656967687465645f71756f72756d5f7468726573686f6c64 "V" 0x6f70656e5f70726f706f73616c5f666565 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073 0x6f70656e5f74696d657374616d70 0x766f74655f6f70656e696e675f74696d657374616d70 0x66756e64696e675f74797065 0x7265717565737465645f616d6f756e74 0x766f74696e675f6475726174696f6e 0x7061757365645f7265676973747279 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564 0x7375626d697373696f6e5f74696d657374616d70 0x6d657461646174615f75706c6f61646564 0x7469746c65 0x666f637573 0x64697363757373696f6e5f6475726174696f6e 0x78676f765f6461656d6f6e
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/proposal/contract.py:46
    // Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 3 // 3
    ==
    // smart_contracts/proposal/contract.py:44-47
    // # Preconditions
    // assert (
    //     Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    // ), err.WRONG_GLOBAL_BYTES
    assert // Wrong Global Bytes allocation
    // smart_contracts/proposal/contract.py:48
    // assert Txn.global_num_uint == prop_cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    pushint 26 // 26
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/proposal/contract.py:49
    // assert Txn.local_num_byte_slice == prop_cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/proposal/contract.py:50
    // assert Txn.local_num_uint == prop_cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/proposal/contract.py:55
    // key=prop_cfg.GS_KEY_PROPOSER,
    bytec_3 // 0x70726f706f736572
    // smart_contracts/proposal/contract.py:54
    // Account(),
    global ZeroAddress
    // smart_contracts/proposal/contract.py:52-56
    // # Base State
    // self.proposer = GlobalState(
    //     Account(),
    //     key=prop_cfg.GS_KEY_PROPOSER,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:59
    // key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    bytec 4 // 0x72656769737472795f6170705f6964
    // smart_contracts/proposal/contract.py:58
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:57-60
    // self.registry_app_id = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:65
    // key=reg_cfg.GS_KEY_COMMITTEE_ID,
    bytec 17 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:64
    // typ.Bytes32.from_bytes(b""),
    pushbytes 0x
    // smart_contracts/proposal/contract.py:62-66
    // # From xGov Registry
    // self.committee_id = GlobalState(
    //     typ.Bytes32.from_bytes(b""),
    //     key=reg_cfg.GS_KEY_COMMITTEE_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:69
    // key=reg_cfg.GS_KEY_COMMITTEE_MEMBERS,
    bytec 13 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:68
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:67-70
    // self.committee_members = GlobalState(
    //     UInt64(),
    //     key=reg_cfg.GS_KEY_COMMITTEE_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:73
    // key=reg_cfg.GS_KEY_COMMITTEE_VOTES,
    bytec 15 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:72
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:71-74
    // self.committee_votes = GlobalState(
    //     UInt64(),
    //     key=reg_cfg.GS_KEY_COMMITTEE_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:77
    // key=reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE,
    bytec 22 // 0x6f70656e5f70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:76
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:75-78
    // self.open_proposal_fee = GlobalState(
    //     UInt64(),
    //     key=reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:81
    // key=reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS,
    bytec 23 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    // smart_contracts/proposal/contract.py:80
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:79-82
    // self.daemon_ops_funding_bps = GlobalState(
    //     UInt64(),
    //     key=reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:87
    // key=prop_cfg.GS_KEY_OPEN_TS,
    bytec 24 // 0x6f70656e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:86
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:84-88
    // # Time Anchors
    // self.open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:91
    // key=prop_cfg.GS_KEY_SUBMISSION_TS,
    bytec 31 // 0x7375626d697373696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:90
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:89-92
    // self.submission_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_SUBMISSION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:95
    // key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    bytec 25 // 0x766f74655f6f70656e696e675f74696d657374616d70
    // smart_contracts/proposal/contract.py:94
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:93-96
    // self.vote_open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:101
    // key=prop_cfg.GS_KEY_STATUS,
    bytec_0 // 0x737461747573
    // smart_contracts/proposal/contract.py:100
    // UInt64(enm.STATUS_EMPTY),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:98-102
    // # Proposal State
    // self.status = GlobalState(
    //     UInt64(enm.STATUS_EMPTY),
    //     key=prop_cfg.GS_KEY_STATUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:105
    // key=prop_cfg.GS_KEY_FINALIZED,
    bytec_2 // 0x66696e616c697a6564
    // smart_contracts/proposal/contract.py:104
    // False,  # noqa: FBT003
    intc_0 // 0
    // smart_contracts/proposal/contract.py:103-106
    // self.finalized = GlobalState(
    //     False,  # noqa: FBT003
    //     key=prop_cfg.GS_KEY_FINALIZED,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:109
    // key=prop_cfg.GS_KEY_METADATA_UPLOADED,
    bytec 32 // 0x6d657461646174615f75706c6f61646564
    // smart_contracts/proposal/contract.py:108
    // False,  # noqa: FBT003
    intc_0 // 0
    // smart_contracts/proposal/contract.py:107-110
    // self.metadata_uploaded = GlobalState(
    //     False,  # noqa: FBT003
    //     key=prop_cfg.GS_KEY_METADATA_UPLOADED,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:115
    // key=prop_cfg.GS_KEY_TITLE,
    bytec 33 // 0x7469746c65
    // smart_contracts/proposal/contract.py:114
    // String(),
    pushbytes ""
    // smart_contracts/proposal/contract.py:112-116
    // # Proposal Configuration
    // self.title = GlobalState(
    //     String(),
    //     key=prop_cfg.GS_KEY_TITLE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:119
    // key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    bytec 6 // 0x66756e64696e675f63617465676f7279
    // smart_contracts/proposal/contract.py:118
    // UInt64(enm.FUNDING_CATEGORY_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:117-120
    // self.funding_category = GlobalState(
    //     UInt64(enm.FUNDING_CATEGORY_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:123
    // key=prop_cfg.GS_KEY_FOCUS,
    bytec 34 // 0x666f637573
    // smart_contracts/proposal/contract.py:122
    // UInt64(enm.FOCUS_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:121-124
    // self.focus = GlobalState(
    //     UInt64(enm.FOCUS_NULL),
    //     key=prop_cfg.GS_KEY_FOCUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:127
    // key=prop_cfg.GS_KEY_FUNDING_TYPE,
    bytec 26 // 0x66756e64696e675f74797065
    // smart_contracts/proposal/contract.py:126
    // UInt64(enm.FUNDING_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:125-128
    // self.funding_type = GlobalState(
    //     UInt64(enm.FUNDING_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_TYPE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:131
    // key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    bytec 27 // 0x7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:130
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:129-132
    // self.requested_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:135
    // key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    bytec 18 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:134
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:133-136
    // self.locked_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:139
    // key=prop_cfg.GS_KEY_DISCUSSION_DURATION,
    bytec 35 // 0x64697363757373696f6e5f6475726174696f6e
    // smart_contracts/proposal/contract.py:138
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:137-140
    // self.discussion_duration = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_DISCUSSION_DURATION,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:143
    // key=prop_cfg.GS_KEY_VOTING_DURATION,
    bytec 28 // 0x766f74696e675f6475726174696f6e
    // smart_contracts/proposal/contract.py:142
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:141-144
    // self.voting_duration = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTING_DURATION,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:147
    // key=prop_cfg.GS_KEY_QUORUM_THRESHOLD,
    bytec 19 // 0x71756f72756d5f7468726573686f6c64
    // smart_contracts/proposal/contract.py:146
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:145-148
    // self.quorum_threshold = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_QUORUM_THRESHOLD,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:151
    // key=prop_cfg.GS_KEY_WEIGHTED_QUORUM_THRESHOLD,
    bytec 20 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    // smart_contracts/proposal/contract.py:150
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:149-152
    // self.weighted_quorum_threshold = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_WEIGHTED_QUORUM_THRESHOLD,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:157
    // key=prop_cfg.GS_KEY_ASSIGNED_MEMBERS,
    bytec 7 // 0x61737369676e65645f6d656d62657273
    // smart_contracts/proposal/contract.py:156
    // UInt64(0),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:154-158
    // # Proposal Vote
    // self.assigned_members = GlobalState(
    //     UInt64(0),
    //     key=prop_cfg.GS_KEY_ASSIGNED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:161
    // key=prop_cfg.GS_KEY_ASSIGNED_VOTES,
    bytec 16 // 0x61737369676e65645f766f746573
    // smart_contracts/proposal/contract.py:160
    // UInt64(0),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:159-162
    // self.assigned_votes = GlobalState(
    //     UInt64(0),
    //     key=prop_cfg.GS_KEY_ASSIGNED_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:165
    // key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    bytec 8 // 0x766f7465645f6d656d62657273
    // smart_contracts/proposal/contract.py:164
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:163-166
    // self.voted_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:169
    // key=prop_cfg.GS_KEY_APPROVALS,
    bytec 9 // 0x617070726f76616c73
    // smart_contracts/proposal/contract.py:168
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:167-170
    // self.approvals = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_APPROVALS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:173
    // key=prop_cfg.GS_KEY_REJECTIONS,
    bytec 10 // 0x72656a656374696f6e73
    // smart_contracts/proposal/contract.py:172
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:171-174
    // self.rejections = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REJECTIONS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:177
    // key=prop_cfg.GS_KEY_NULLS,
    bytec 14 // 0x6e756c6c73
    // smart_contracts/proposal/contract.py:176
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:175-178
    // self.nulls = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_NULLS,
    // )
    app_global_put

main_after_if_else@2:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x24378d3c // method "delete()void"
    txna ApplicationArgs 0
    match main_delete_route@4

main_switch_case_next@5:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@23
    pushbytess 0xedaeb9ca 0x7143994f 0x7371321a 0x34e613ca 0x0d9ab0d7 0x1841a0d2 0x734dbecc 0x212d9f07 0x8a5e4c80 0x2ac19b05 0x802069b4 0xa8c6f80a 0x24615f90 0xea2363f4 0xdbd83dd9 // method "open(pay,string,uint64,uint64,uint8)void", method "upload_metadata(byte[],bool)void", method "drop()string", method "submit()void", method "assign_voters((address,uint64)[])void", method "vote(address,uint64,uint64)string", method "scrutiny()void", method "review(bool)void", method "fund()string", method "unassign_voters(address[])void", method "finalize()string", method "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)", method "get_voter_box(address)(uint64,bool)", method "get_voting_state()(uint32,uint32,uint32,uint32,uint32,uint32,bool,bool,bool,bool)", method "op_up()void"
    txna ApplicationArgs 0
    match open upload_metadata drop submit assign_voters vote scrutiny review fund unassign_voters finalize get_state get_voter_box get_voting_state main_op_up_route@21
    err

main_op_up_route@21:
    // smart_contracts/proposal/contract.py:1167
    // @arc4.abimethod()
    intc_1 // 1
    return

main_create_NoOp@23:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x216b1e07 // method "create(address)string"
    txna ApplicationArgs 0
    match create
    err

main_delete_route@4:
    // smart_contracts/proposal/contract.py:1064
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be DeleteApplication && can only call when not creating
    b delete


// smart_contracts.proposal.contract.Proposal.create[routing]() -> void:
create:
    // smart_contracts/proposal/contract.py:579
    // @arc4.abimethod(create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/proposal/contract.py:592
    // Global.caller_application_id != 0
    global CallerApplicationID
    // smart_contracts/proposal/contract.py:591-593
    // assert (
    //     Global.caller_application_id != 0
    // ), err.UNAUTHORIZED  # Only callable by another contract
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:595-596
    // # Set Proposal Base State
    // self.proposer.value = proposer.native
    bytec_3 // 0x70726f706f736572
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:597
    // self.registry_app_id.value = Global.caller_application_id
    bytec 4 // 0x72656769737472795f6170705f6964
    global CallerApplicationID
    app_global_put
    // smart_contracts/proposal/contract.py:601
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    bytec 17 // 0x636f6d6d69747465655f6964
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:599-600
    // # Set values from xGov Registry
    // self.committee_id.value = typ.Bytes32.from_bytes(
    bytec 17 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:599-602
    // # Set values from xGov Registry
    // self.committee_id.value = typ.Bytes32.from_bytes(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:604
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 13 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:603-605
    // self.committee_members.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:603
    // self.committee_members.value = self.get_uint_from_registry_config(
    bytec 13 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:603-605
    // self.committee_members.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:607
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 15 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:606-608
    // self.committee_votes.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:606
    // self.committee_votes.value = self.get_uint_from_registry_config(
    bytec 15 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:606-608
    // self.committee_votes.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:610
    // Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    bytec 22 // 0x6f70656e5f70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:609-611
    // self.open_proposal_fee.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:609
    // self.open_proposal_fee.value = self.get_uint_from_registry_config(
    bytec 22 // 0x6f70656e5f70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:609-611
    // self.open_proposal_fee.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:613
    // Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    bytec 23 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    // smart_contracts/proposal/contract.py:612-614
    // self.daemon_ops_funding_bps.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:612
    // self.daemon_ops_funding_bps.value = self.get_uint_from_registry_config(
    bytec 23 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    // smart_contracts/proposal/contract.py:612-614
    // self.daemon_ops_funding_bps.value = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:616-617
    // # Post validation
    // if self.committee_id.value == typ.Bytes32.from_bytes(b""):
    intc_0 // 0
    bytec 17 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    pushbytes 0x
    ==
    bz create_after_if_else@3
    // smart_contracts/proposal/contract.py:618
    // return typ.Error(err.ARC_65_PREFIX + err.EMPTY_COMMITTEE_ID)
    pushbytes 0x00164552523a456d70747920436f6d6d6974746565204944

create_after_inlined_smart_contracts.proposal.contract.Proposal.create@4:
    // smart_contracts/proposal/contract.py:579
    // @arc4.abimethod(create="require")
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

create_after_if_else@3:
    // smart_contracts/proposal/contract.py:620
    // return typ.Error("")
    bytec_1 // 0x0000
    // smart_contracts/proposal/contract.py:579
    // @arc4.abimethod(create="require")
    b create_after_inlined_smart_contracts.proposal.contract.Proposal.create@4


// smart_contracts.proposal.contract.Proposal.open[routing]() -> void:
open:
    intc_0 // 0
    pushbytes ""
    dupn 5
    // smart_contracts/proposal/contract.py:622
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    // smart_contracts/proposal/contract.py:481
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    bytec 29 // 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:480-482
    // registry_paused = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:483
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/proposal/contract.py:401
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:403
    // self.status.value == enm.STATUS_EMPTY and not self.finalized.value
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    bnz open_bool_false@4
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz open_bool_false@4
    intc_1 // 1

open_bool_merge@5:
    // smart_contracts/proposal/contract.py:402-404
    // assert (
    //     self.status.value == enm.STATUS_EMPTY and not self.finalized.value
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:660
    // title.native, funding_type.as_uint64(), requested_amount.as_uint64()
    dig 3
    extract 2 0
    dup
    bury 13
    dig 3
    btoi
    dup
    cover 2
    bury 11
    dig 3
    btoi
    bury 9
    // smart_contracts/proposal/contract.py:414
    // assert title.bytes.length <= const.TITLE_MAX_BYTES, err.WRONG_TITLE_LENGTH
    dup
    len
    pushint 123 // 123
    <=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:415
    // assert title != "", err.WRONG_TITLE_LENGTH
    pushbytes ""
    !=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:418
    // funding_type == enm.FUNDING_PROACTIVE
    intc_3 // 10
    ==
    // smart_contracts/proposal/contract.py:418-419
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bnz open_bool_true@9
    // smart_contracts/proposal/contract.py:419
    // or funding_type == enm.FUNDING_RETROACTIVE
    dig 8
    pushint 20 // 20
    ==
    // smart_contracts/proposal/contract.py:418-419
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bz open_bool_false@10

open_bool_true@9:
    intc_1 // 1

open_bool_merge@11:
    // smart_contracts/proposal/contract.py:417-420
    // assert (
    //     funding_type == enm.FUNDING_PROACTIVE
    //     or funding_type == enm.FUNDING_RETROACTIVE
    // ), err.WRONG_FUNDING_TYPE
    assert // Wrong Funding Type
    // smart_contracts/proposal/contract.py:423
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    pushbytes 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:422-424
    // min_requested_amount = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:427
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:426-428
    // max_requested_amount_large = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:430
    // assert requested_amount >= min_requested_amount, err.WRONG_MIN_REQUESTED_AMOUNT
    dig 8
    dup
    cover 2
    uncover 3
    >=
    assert // Requested amount is less than the minimum requested amount
    // smart_contracts/proposal/contract.py:432
    // requested_amount <= max_requested_amount_large
    dig 1
    >=
    // smart_contracts/proposal/contract.py:431-433
    // assert (
    //     requested_amount <= max_requested_amount_large
    // ), err.WRONG_MAX_REQUESTED_AMOUNT
    assert // Requested amount is more than the maximum requested amount
    // smart_contracts/proposal/contract.py:444
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    pushbytes 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    // smart_contracts/proposal/contract.py:443-445
    // proposal_commitment_bps = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:439
    // return amount * fraction_in_bps // const.BPS
    dig 1
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:457
    // assert payment.sender == self.proposer.value, err.WRONG_SENDER
    dig 6
    dup
    gtxns Sender
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    assert // Wrong Sender
    // smart_contracts/proposal/contract.py:459
    // payment.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/proposal/contract.py:458-460
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/proposal/contract.py:461
    // assert payment.amount == expected_lock_amount, err.WRONG_LOCKED_AMOUNT
    gtxns Amount
    dup
    bury 9
    ==
    assert // Locked amount is incorrect
    // smart_contracts/proposal/contract.py:664-665
    // # Configure Proposal
    // self.title.value = title.native
    bytec 33 // 0x7469746c65
    dig 13
    app_global_put
    // smart_contracts/proposal/contract.py:466
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    // smart_contracts/proposal/contract.py:465-467
    // max_requested_amount_small = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:469
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    // smart_contracts/proposal/contract.py:468-470
    // max_requested_amount_medium = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    bury 10
    // smart_contracts/proposal/contract.py:471
    // if requested_amount <= max_requested_amount_small:
    <=
    bz open_else_body@17
    // smart_contracts/proposal/contract.py:472
    // return UInt64(enm.FUNDING_CATEGORY_SMALL)
    intc_3 // 10

open_after_inlined_smart_contracts.proposal.contract.Proposal.get_category@20:
    // smart_contracts/proposal/contract.py:666
    // self.funding_category.value = self.get_category(requested_amount.as_uint64())
    bytec 6 // 0x66756e64696e675f63617465676f7279
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:667
    // self.funding_type.value = funding_type.as_uint64()
    bytec 26 // 0x66756e64696e675f74797065
    dig 9
    app_global_put
    // smart_contracts/proposal/contract.py:668
    // self.requested_amount.value = requested_amount.as_uint64()
    bytec 27 // 0x7265717565737465645f616d6f756e74
    dig 7
    app_global_put
    // smart_contracts/proposal/contract.py:669
    // self.focus.value = focus.as_uint64()
    dup
    btoi
    bytec 34 // 0x666f637573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:670
    // self.locked_amount.value = payment.amount  # The amount is validated
    bytec 18 // 0x6c6f636b65645f616d6f756e74
    dig 6
    app_global_put
    // smart_contracts/proposal/contract.py:674
    // self.funding_category.value
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    bury 13
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:307
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_3 // 10
    ==
    bz open_else_body@23
    // smart_contracts/proposal/contract.py:309
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:308-310
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config

open_after_inlined_smart_contracts.proposal.contract.Proposal.get_discussion_duration@26:
    // smart_contracts/proposal/contract.py:672-673
    // # Configure category dependent values
    // self.discussion_duration.value = self.get_discussion_duration(
    bytec 35 // 0x64697363757373696f6e5f6475726174696f6e
    // smart_contracts/proposal/contract.py:672-675
    // # Configure category dependent values
    // self.discussion_duration.value = self.get_discussion_duration(
    //     self.funding_category.value
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:677
    // self.funding_category.value
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    bury 13
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:322
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_3 // 10
    ==
    bz open_else_body@29
    // smart_contracts/proposal/contract.py:324
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    pushbytes 0x766f74696e675f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:323-325
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config

open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@32:
    // smart_contracts/proposal/contract.py:676
    // self.voting_duration.value = self.get_voting_duration(
    bytec 28 // 0x766f74696e675f6475726174696f6e
    // smart_contracts/proposal/contract.py:676-678
    // self.voting_duration.value = self.get_voting_duration(
    //     self.funding_category.value
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:680
    // self.funding_category.value
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    bury 12
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:337
    // if category == enm.FUNDING_CATEGORY_NULL:
    bnz open_else_body@35
    // smart_contracts/proposal/contract.py:338
    // return UInt64(0)
    intc_0 // 0

open_after_inlined_smart_contracts.proposal.contract.Proposal.get_quorum@40:
    // smart_contracts/proposal/contract.py:535
    // self.committee_members.value, quorum_bps
    intc_0 // 0
    bytec 13 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:439
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:679
    // self.quorum_threshold.value = self.compute_quorum_threshold(
    bytec 19 // 0x71756f72756d5f7468726573686f6c64
    // smart_contracts/proposal/contract.py:679-681
    // self.quorum_threshold.value = self.compute_quorum_threshold(
    //     self.funding_category.value
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:683
    // self.funding_category.value
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    bury 12
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:354
    // if category == enm.FUNDING_CATEGORY_NULL:
    bnz open_else_body@44
    // smart_contracts/proposal/contract.py:355
    // return UInt64(0)
    intc_0 // 0

open_after_inlined_smart_contracts.proposal.contract.Proposal.get_weighted_quorum@49:
    // smart_contracts/proposal/contract.py:542
    // self.committee_votes.value, weighted_quorum_bps
    intc_0 // 0
    bytec 15 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/proposal/contract.py:439
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:682
    // self.weighted_quorum_threshold.value = self.compute_weighted_quorum_threshold(
    bytec 20 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    // smart_contracts/proposal/contract.py:682-684
    // self.weighted_quorum_threshold.value = self.compute_weighted_quorum_threshold(
    //     self.funding_category.value
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:686-687
    // # Update Proposal State and time anchors
    // self.status.value = UInt64(enm.STATUS_DRAFT)
    bytec_0 // 0x737461747573
    intc_3 // 10
    app_global_put
    // smart_contracts/proposal/contract.py:688
    // self.open_ts.value = Global.latest_timestamp
    bytec 24 // 0x6f70656e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:692
    // funding_type=arc4.UInt8(self.funding_type.value),
    intc_0 // 0
    bytec 26 // 0x66756e64696e675f74797065
    app_global_get_ex
    assert // check self.funding_type exists
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:693
    // requested_amount=arc4.UInt64(self.requested_amount.value),
    intc_0 // 0
    bytec 27 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    itob
    // smart_contracts/proposal/contract.py:694
    // category=arc4.UInt8(self.funding_category.value),
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    assert // check self.funding_category exists
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:691-695
    // typ.Opened(
    //     funding_type=arc4.UInt8(self.funding_type.value),
    //     requested_amount=arc4.UInt64(self.requested_amount.value),
    //     category=arc4.UInt8(self.funding_category.value),
    // )
    cover 2
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:690-696
    // arc4.emit(
    //     typ.Opened(
    //         funding_type=arc4.UInt8(self.funding_type.value),
    //         requested_amount=arc4.UInt64(self.requested_amount.value),
    //         category=arc4.UInt8(self.funding_category.value),
    //     )
    // )
    pushbytes 0x371243f5 // method "Opened(uint8,uint64,uint8)"
    swap
    concat
    log
    // smart_contracts/proposal/contract.py:622
    // @arc4.abimethod()
    intc_1 // 1
    return

open_else_body@44:
    // smart_contracts/proposal/contract.py:356
    // elif category == enm.FUNDING_CATEGORY_SMALL:
    dig 9
    intc_3 // 10
    ==
    bz open_else_body@46
    // smart_contracts/proposal/contract.py:358
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    pushbytes 0x77656967687465645f71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:357-359
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:540
    // weighted_quorum_bps = self.get_weighted_quorum(funding_category)
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_weighted_quorum@49

open_else_body@46:
    // smart_contracts/proposal/contract.py:360
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dig 9
    pushint 20 // 20
    ==
    bz open_else_body@48
    // smart_contracts/proposal/contract.py:362
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    pushbytes 0x77656967687465645f71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:361-363
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:540
    // weighted_quorum_bps = self.get_weighted_quorum(funding_category)
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_weighted_quorum@49

open_else_body@48:
    // smart_contracts/proposal/contract.py:366
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    pushbytes 0x77656967687465645f71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:365-367
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:540
    // weighted_quorum_bps = self.get_weighted_quorum(funding_category)
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_weighted_quorum@49

open_else_body@35:
    // smart_contracts/proposal/contract.py:339
    // elif category == enm.FUNDING_CATEGORY_SMALL:
    dig 9
    intc_3 // 10
    ==
    bz open_else_body@37
    // smart_contracts/proposal/contract.py:341
    // Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    pushbytes 0x71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:340-342
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:533
    // quorum_bps = self.get_quorum(funding_category)
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_quorum@40

open_else_body@37:
    // smart_contracts/proposal/contract.py:343
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dig 9
    pushint 20 // 20
    ==
    bz open_else_body@39
    // smart_contracts/proposal/contract.py:345
    // Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    pushbytes 0x71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:344-346
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:533
    // quorum_bps = self.get_quorum(funding_category)
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_quorum@40

open_else_body@39:
    // smart_contracts/proposal/contract.py:349
    // Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    pushbytes 0x71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:348-350
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:533
    // quorum_bps = self.get_quorum(funding_category)
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_quorum@40

open_else_body@29:
    // smart_contracts/proposal/contract.py:326
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dig 10
    pushint 20 // 20
    ==
    bz open_else_body@31
    // smart_contracts/proposal/contract.py:328
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    pushbytes 0x766f74696e675f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:327-329
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:676-678
    // self.voting_duration.value = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@32

open_else_body@31:
    // smart_contracts/proposal/contract.py:332
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    pushbytes 0x766f74696e675f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:331-333
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:676-678
    // self.voting_duration.value = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@32

open_else_body@23:
    // smart_contracts/proposal/contract.py:311
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    dig 10
    pushint 20 // 20
    ==
    bz open_else_body@25
    // smart_contracts/proposal/contract.py:313
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:312-314
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:672-675
    // # Configure category dependent values
    // self.discussion_duration.value = self.get_discussion_duration(
    //     self.funding_category.value
    // )
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_discussion_duration@26

open_else_body@25:
    // smart_contracts/proposal/contract.py:317
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:316-318
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:672-675
    // # Configure category dependent values
    // self.discussion_duration.value = self.get_discussion_duration(
    //     self.funding_category.value
    // )
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_discussion_duration@26

open_else_body@17:
    // smart_contracts/proposal/contract.py:473
    // elif requested_amount <= max_requested_amount_medium:
    dig 6
    dig 8
    <=
    bz open_else_body@19
    // smart_contracts/proposal/contract.py:474
    // return UInt64(enm.FUNDING_CATEGORY_MEDIUM)
    pushint 20 // 20
    // smart_contracts/proposal/contract.py:666
    // self.funding_category.value = self.get_category(requested_amount.as_uint64())
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_category@20

open_else_body@19:
    // smart_contracts/proposal/contract.py:476
    // return UInt64(enm.FUNDING_CATEGORY_LARGE)
    pushint 30 // 30
    // smart_contracts/proposal/contract.py:666
    // self.funding_category.value = self.get_category(requested_amount.as_uint64())
    b open_after_inlined_smart_contracts.proposal.contract.Proposal.get_category@20

open_bool_false@10:
    intc_0 // 0
    b open_bool_merge@11

open_bool_false@4:
    intc_0 // 0
    b open_bool_merge@5


// smart_contracts.proposal.contract.Proposal.upload_metadata[routing]() -> void:
upload_metadata:
    // smart_contracts/proposal/contract.py:698
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    dup
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    // smart_contracts/proposal/contract.py:481
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    bytec 29 // 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:480-482
    // registry_paused = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:483
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/proposal/contract.py:393
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:397
    // assert payload.length > 0, err.EMPTY_PAYLOAD
    swap
    assert // Empty payload
    // smart_contracts/proposal/contract.py:720
    // self.metadata_uploaded.value = True
    bytec 32 // 0x6d657461646174615f75706c6f61646564
    intc_1 // 1
    app_global_put
    // smart_contracts/proposal/contract.py:722
    // if is_first_in_group:
    bytec 5 // 0x00
    !=
    bz upload_metadata_else_body@3
    // smart_contracts/proposal/contract.py:723-724
    // # clear and write the metadata to the box
    // del self.metadata.value
    bytec 12 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:725
    // self.metadata.value = payload.native
    extract 2 0
    bytec 12 // "M"
    box_del
    pop
    bytec 12 // "M"
    swap
    box_put

upload_metadata_after_if_else@4:
    // smart_contracts/proposal/contract.py:698
    // @arc4.abimethod()
    intc_1 // 1
    return

upload_metadata_else_body@3:
    // smart_contracts/proposal/contract.py:727-728
    // # append the metadata to the box
    // old_size = self.metadata.length
    bytec 12 // "M"
    box_len
    assert // check self.metadata exists
    // smart_contracts/proposal/contract.py:729
    // self.metadata.resize(self.metadata.length + payload.length)
    dup
    dig 3
    +
    bytec 12 // "M"
    swap
    box_resize
    // smart_contracts/proposal/contract.py:730
    // self.metadata.replace(old_size, payload.native)
    swap
    extract 2 0
    bytec 12 // "M"
    cover 2
    box_replace
    b upload_metadata_after_if_else@4


// smart_contracts.proposal.contract.Proposal.drop[routing]() -> void:
drop:
    intc_0 // 0
    dup
    // smart_contracts/proposal/contract.py:386
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:387
    // if self.status.value != enm.STATUS_DRAFT or self.finalized.value:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 10
    !=
    bnz drop_if_body@7
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bz drop_after_if_else@8

drop_if_body@7:
    // smart_contracts/proposal/contract.py:388
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 30 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    bury 1

drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@9:
    // smart_contracts/proposal/contract.py:743
    // if error != typ.Error(""):
    bytec_1 // 0x0000
    bury 2
    dup
    bytec_1 // 0x0000
    !=
    bz drop_after_if_else@3
    dup

drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop@4:
    // smart_contracts/proposal/contract.py:732
    // @arc4.abimethod()
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

drop_after_if_else@3:
    // smart_contracts/proposal/contract.py:747
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:746-748
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:750
    // del self.metadata.value
    bytec 12 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:751
    // self.finalized.value = True
    bytec_2 // 0x66696e616c697a6564
    intc_1 // 1
    app_global_put
    dig 1
    // smart_contracts/proposal/contract.py:732
    // @arc4.abimethod()
    b drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop@4

drop_after_if_else@8:
    // smart_contracts/proposal/contract.py:389
    // return typ.Error("")
    bytec_1 // 0x0000
    bury 1
    // smart_contracts/proposal/contract.py:742
    // error = self.drop_check_authorization()
    b drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@9


// smart_contracts.proposal.contract.Proposal.submit[routing]() -> void:
submit:
    // smart_contracts/proposal/contract.py:481
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    bytec 29 // 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:480-482
    // registry_paused = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:483
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/proposal/contract.py:378
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:379
    // elapsed_discussion_duration = Global.latest_timestamp - self.open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 24 // 0x6f70656e5f74696d657374616d70
    app_global_get_ex
    assert // check self.open_ts exists
    -
    // smart_contracts/proposal/contract.py:381
    // elapsed_discussion_duration >= self.discussion_duration.value
    intc_0 // 0
    bytec 35 // 0x64697363757373696f6e5f6475726174696f6e
    app_global_get_ex
    assert // check self.discussion_duration exists
    >=
    // smart_contracts/proposal/contract.py:380-382
    // assert (
    //     elapsed_discussion_duration >= self.discussion_duration.value
    // ), err.TOO_EARLY
    assert // Too early
    // smart_contracts/proposal/contract.py:771
    // assert self.metadata_uploaded.value, err.MISSING_METADATA
    intc_0 // 0
    bytec 32 // 0x6d657461646174615f75706c6f61646564
    app_global_get_ex
    assert // check self.metadata_uploaded exists
    assert // Missing Metadata
    // smart_contracts/proposal/contract.py:775
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    bytec 36 // 0x78676f765f6461656d6f6e
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:774-776
    // receiver=Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    // ),
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:778
    // self.open_proposal_fee.value, self.daemon_ops_funding_bps.value
    intc_0 // 0
    bytec 22 // 0x6f70656e5f70726f706f73616c5f666565
    app_global_get_ex
    assert // check self.open_proposal_fee exists
    intc_0 // 0
    bytec 23 // 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    app_global_get_ex
    assert // check self.daemon_ops_funding_bps exists
    // smart_contracts/proposal/contract.py:439
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:773-780
    // self.pay(
    //     receiver=Account(
    //         self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    //     ),
    //     amount=self.relative_to_absolute_amount(
    //         self.open_proposal_fee.value, self.daemon_ops_funding_bps.value
    //     ),
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:781
    // self.status.value = UInt64(enm.STATUS_SUBMITTED)
    bytec_0 // 0x737461747573
    pushint 20 // 20
    app_global_put
    // smart_contracts/proposal/contract.py:782
    // self.submission_ts.value = Global.latest_timestamp
    bytec 31 // 0x7375626d697373696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:755
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.assign_voters[routing]() -> void:
assign_voters:
    pushbytes ""
    dup
    // smart_contracts/proposal/contract.py:798
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts.common.abi_types.CommitteeMember>
    // smart_contracts/proposal/contract.py:295
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:296
    // assert self.status.value == enm.STATUS_SUBMITTED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 20 // 20
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:822
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz assign_voters_else_body@7
    // smart_contracts/proposal/contract.py:823-824
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    bury 3
    intc_1 // 1
    bury 4

assign_voters_for_header@3:
    // smart_contracts/proposal/contract.py:823-824
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    dig 3
    dig 3
    <
    bz assign_voters_after_if_else@8
    // smart_contracts/proposal/contract.py:825
    // self.assert_same_app_and_method(i)
    dig 3
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:823-824
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    bury 4
    b assign_voters_for_header@3

assign_voters_after_if_else@8:
    // smart_contracts/proposal/contract.py:830
    // for i in urange(voters.length):
    intc_0 // 0
    bury 4

assign_voters_for_header@9:
    // smart_contracts/proposal/contract.py:830
    // for i in urange(voters.length):
    dig 3
    dig 1
    <
    bz assign_voters_after_for@12
    // smart_contracts/proposal/contract.py:832
    // voters[i].address.native, voters[i].voting_power.as_uint64()
    dig 1
    extract 2 0
    dig 4
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    swap
    intc_2 // 32
    extract_uint64
    // smart_contracts/proposal/contract.py:302
    // assert voter not in self.voters, err.VOTER_ALREADY_ASSIGNED
    bytec 21 // "V"
    uncover 2
    concat
    dup
    box_len
    bury 1
    !
    assert // Voter Already Assigned
    // smart_contracts/proposal/contract.py:303
    // assert voting_power > 0, err.INVALID_VOTING_POWER
    dig 1
    assert // Invalid Voting Power
    // smart_contracts/proposal/contract.py:788
    // self.voters[voter] = voting_power
    dig 1
    itob
    box_put
    // smart_contracts/proposal/contract.py:789
    // self.assigned_members.value += 1
    intc_0 // 0
    bytec 7 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    intc_1 // 1
    +
    bytec 7 // 0x61737369676e65645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:790
    // self.assigned_votes.value += voting_power
    intc_0 // 0
    bytec 16 // 0x61737369676e65645f766f746573
    app_global_get_ex
    assert // check self.assigned_votes exists
    +
    bytec 16 // 0x61737369676e65645f766f746573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:830
    // for i in urange(voters.length):
    intc_1 // 1
    +
    bury 4
    b assign_voters_for_header@9

assign_voters_after_for@12:
    // smart_contracts/proposal/contract.py:835
    // if self.assigned_members.value == self.committee_members.value:
    intc_0 // 0
    bytec 7 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    intc_0 // 0
    bytec 13 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    bz assign_voters_after_if_else@14
    // smart_contracts/proposal/contract.py:837
    // self.assigned_votes.value == self.committee_votes.value
    intc_0 // 0
    bytec 16 // 0x61737369676e65645f766f746573
    app_global_get_ex
    assert // check self.assigned_votes exists
    intc_0 // 0
    bytec 15 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    ==
    // smart_contracts/proposal/contract.py:836-838
    // assert (
    //     self.assigned_votes.value == self.committee_votes.value
    // ), err.VOTING_POWER_MISMATCH
    assert // Voting Power Mismatch
    // smart_contracts/proposal/contract.py:839
    // self.status.value = UInt64(enm.STATUS_VOTING)
    bytec_0 // 0x737461747573
    pushint 25 // 25
    app_global_put
    // smart_contracts/proposal/contract.py:840
    // self.vote_open_ts.value = Global.latest_timestamp
    global LatestTimestamp
    bytec 25 // 0x766f74655f6f70656e696e675f74696d657374616d70
    dig 1
    app_global_put
    // smart_contracts/proposal/contract.py:844
    // vote_opening=arc4.UInt64(self.vote_open_ts.value),
    dup
    itob
    // smart_contracts/proposal/contract.py:846
    // self.vote_open_ts.value + self.voting_duration.value
    intc_0 // 0
    bytec 28 // 0x766f74696e675f6475726174696f6e
    app_global_get_ex
    assert // check self.voting_duration exists
    uncover 2
    +
    // smart_contracts/proposal/contract.py:845-847
    // vote_closing=arc4.UInt64(
    //     self.vote_open_ts.value + self.voting_duration.value
    // ),
    itob
    // smart_contracts/proposal/contract.py:848
    // quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    intc_0 // 0
    bytec 19 // 0x71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.quorum_threshold exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:850
    // self.weighted_quorum_threshold.value
    intc_0 // 0
    bytec 20 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.weighted_quorum_threshold exists
    // smart_contracts/proposal/contract.py:849-851
    // weighted_quorum_votes=arc4.UInt32(
    //     self.weighted_quorum_threshold.value
    // ),
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:843-852
    // typ.Submitted(
    //     vote_opening=arc4.UInt64(self.vote_open_ts.value),
    //     vote_closing=arc4.UInt64(
    //         self.vote_open_ts.value + self.voting_duration.value
    //     ),
    //     quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    //     weighted_quorum_votes=arc4.UInt32(
    //         self.weighted_quorum_threshold.value
    //     ),
    // )
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:842-853
    // arc4.emit(
    //     typ.Submitted(
    //         vote_opening=arc4.UInt64(self.vote_open_ts.value),
    //         vote_closing=arc4.UInt64(
    //             self.vote_open_ts.value + self.voting_duration.value
    //         ),
    //         quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    //         weighted_quorum_votes=arc4.UInt32(
    //             self.weighted_quorum_threshold.value
    //         ),
    //     )
    // )
    pushbytes 0x980fd5de // method "Submitted(uint64,uint64,uint32,uint32)"
    swap
    concat
    log

assign_voters_after_if_else@14:
    // smart_contracts/proposal/contract.py:798
    // @arc4.abimethod()
    intc_1 // 1
    return

assign_voters_else_body@7:
    // smart_contracts/proposal/contract.py:827-828
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b assign_voters_after_if_else@8


// smart_contracts.proposal.contract.Proposal.vote[routing]() -> void:
vote:
    intc_0 // 0
    dupn 2
    pushbytes ""
    dup
    // smart_contracts/proposal/contract.py:855
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/proposal/contract.py:257
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:259
    // if self.status.value != enm.STATUS_VOTING:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    !=
    bz vote_after_if_else@15
    // smart_contracts/proposal/contract.py:260
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 30 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    bury 6

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@18:
    // smart_contracts/proposal/contract.py:878
    // if error != typ.Error(""):
    bytec_1 // 0x0000
    bury 8
    dig 5
    bytec_1 // 0x0000
    !=
    bz vote_after_if_else@3
    dig 5

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@6:
    // smart_contracts/proposal/contract.py:855
    // @arc4.abimethod()
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

vote_after_if_else@3:
    // smart_contracts/proposal/contract.py:882
    // voter.native, approvals.as_uint64(), rejections.as_uint64()
    dig 1
    btoi
    bury 5
    dup
    btoi
    bury 4
    // smart_contracts/proposal/contract.py:271
    // if voter not in self.voters:
    bytec 21 // "V"
    dig 3
    concat
    dup
    bury 8
    box_len
    bury 1
    bnz vote_after_if_else@9
    // smart_contracts/proposal/contract.py:272
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_NOT_FOUND)
    pushbytes 0x00134552523a566f746572206e6f7420666f756e64
    bury 6

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12:
    // smart_contracts/proposal/contract.py:884
    // if error != typ.Error(""):
    dig 5
    // smart_contracts/proposal/contract.py:878
    // if error != typ.Error(""):
    bytec_1 // 0x0000
    // smart_contracts/proposal/contract.py:884
    // if error != typ.Error(""):
    !=
    bz vote_after_if_else@5
    dig 5
    // smart_contracts/proposal/contract.py:855
    // @arc4.abimethod()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@6

vote_after_if_else@5:
    // smart_contracts/proposal/contract.py:887
    // votes = self.voters[voter.native]
    dig 6
    dup
    box_get
    assert // check self.voters entry exists
    btoi
    // smart_contracts/proposal/contract.py:889
    // self.voted_members.value += 1
    intc_0 // 0
    bytec 8 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_1 // 1
    +
    bytec 8 // 0x766f7465645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:891
    // nulls = votes - approvals.as_uint64() - rejections.as_uint64()
    dup
    dig 7
    dup
    cover 2
    -
    dig 7
    dup
    cover 3
    -
    // smart_contracts/proposal/contract.py:893
    // self.approvals.value += approvals.as_uint64()
    intc_0 // 0
    bytec 9 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    uncover 2
    +
    bytec 9 // 0x617070726f76616c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:894
    // self.rejections.value += rejections.as_uint64()
    intc_0 // 0
    bytec 10 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    uncover 2
    +
    bytec 10 // 0x72656a656374696f6e73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:895
    // self.nulls.value += nulls
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    bytec 14 // 0x6e756c6c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:897
    // self._unassign_voter(voter.native, votes)
    dig 4
    swap
    callsub _unassign_voter
    // smart_contracts/proposal/contract.py:901
    // xgov=arc4.Address(self.voters.box(voter.native).key[1:]),
    dup
    len
    intc_1 // 1
    dig 1
    >=
    intc_1 // 1
    dig 2
    uncover 2
    select
    swap
    substring3
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:902
    // total_voters=arc4.UInt32(self.voted_members.value),
    intc_0 // 0
    bytec 8 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:903
    // total_approvals=arc4.UInt32(self.approvals.value),
    intc_0 // 0
    bytec 9 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:904
    // total_rejections=arc4.UInt32(self.rejections.value),
    intc_0 // 0
    bytec 10 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:905
    // total_nulls=arc4.UInt32(self.nulls.value),
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:900-906
    // typ.Vote(
    //     xgov=arc4.Address(self.voters.box(voter.native).key[1:]),
    //     total_voters=arc4.UInt32(self.voted_members.value),
    //     total_approvals=arc4.UInt32(self.approvals.value),
    //     total_rejections=arc4.UInt32(self.rejections.value),
    //     total_nulls=arc4.UInt32(self.nulls.value),
    // )
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:899-907
    // arc4.emit(
    //     typ.Vote(
    //         xgov=arc4.Address(self.voters.box(voter.native).key[1:]),
    //         total_voters=arc4.UInt32(self.voted_members.value),
    //         total_approvals=arc4.UInt32(self.approvals.value),
    //         total_rejections=arc4.UInt32(self.rejections.value),
    //         total_nulls=arc4.UInt32(self.nulls.value),
    //     )
    // )
    pushbytes 0x1577f6e7 // method "Vote(address,uint32,uint32,uint32,uint32)"
    swap
    concat
    log
    dig 7
    // smart_contracts/proposal/contract.py:855
    // @arc4.abimethod()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote@6

vote_after_if_else@9:
    // smart_contracts/proposal/contract.py:274
    // votes = self.voters[voter]
    dig 6
    box_get
    assert // check self.voters entry exists
    btoi
    // smart_contracts/proposal/contract.py:276
    // if approvals + rejections > votes:
    dig 5
    dig 5
    +
    <
    bz vote_after_if_else@11
    // smart_contracts/proposal/contract.py:277
    // return typ.Error(err.ARC_65_PREFIX + err.VOTES_EXCEEDED)
    pushbytes 0x00124552523a566f746573206578636565646564
    bury 6
    // smart_contracts/proposal/contract.py:881-883
    // error = self.vote_input_validation(
    //     voter.native, approvals.as_uint64(), rejections.as_uint64()
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@11:
    dig 7
    bury 6
    // smart_contracts/proposal/contract.py:881-883
    // error = self.vote_input_validation(
    //     voter.native, approvals.as_uint64(), rejections.as_uint64()
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@15:
    // smart_contracts/proposal/contract.py:262
    // if not self.is_voting_open():
    callsub is_voting_open
    bnz vote_after_if_else@17
    // smart_contracts/proposal/contract.py:263
    // return typ.Error(err.ARC_65_PREFIX + err.VOTING_PERIOD_EXPIRED)
    pushbytes 0x00194552523a566f74696e6720506572696f642045787069726564
    bury 6
    // smart_contracts/proposal/contract.py:877
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@18

vote_after_if_else@17:
    // smart_contracts/proposal/contract.py:265
    // return typ.Error("")
    bytec_1 // 0x0000
    bury 6
    // smart_contracts/proposal/contract.py:877
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@18


// smart_contracts.proposal.contract.Proposal.scrutiny[routing]() -> void:
scrutiny:
    pushbytes ""
    // smart_contracts/proposal/contract.py:481
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    bytec 29 // 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:480-482
    // registry_paused = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:483
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    // smart_contracts/proposal/contract.py:287
    // assert self.status.value == enm.STATUS_VOTING, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:289
    // not self.is_voting_open()  # voting period has ended
    callsub is_voting_open
    bz scrutiny_bool_true@7
    // smart_contracts/proposal/contract.py:290
    // or self.is_plebiscite()  # all committee members already voted
    callsub is_plebiscite
    // smart_contracts/proposal/contract.py:289-290
    // not self.is_voting_open()  # voting period has ended
    // or self.is_plebiscite()  # all committee members already voted
    bz scrutiny_bool_false@8

scrutiny_bool_true@7:
    intc_1 // 1

scrutiny_bool_merge@9:
    // smart_contracts/proposal/contract.py:288-291
    // assert (
    //     not self.is_voting_open()  # voting period has ended
    //     or self.is_plebiscite()  # all committee members already voted
    // ), err.VOTING_ONGOING
    assert // Voting Ongoing
    // smart_contracts/proposal/contract.py:574
    // self.is_quorum_voters_reached()
    callsub is_quorum_voters_reached
    // smart_contracts/proposal/contract.py:574-576
    // self.is_quorum_voters_reached()
    // and self.is_weighted_quorum_votes_reached()
    // and self.has_majority_approved()
    bz scrutiny_bool_false@15
    // smart_contracts/proposal/contract.py:575
    // and self.is_weighted_quorum_votes_reached()
    callsub is_weighted_quorum_votes_reached
    // smart_contracts/proposal/contract.py:574-576
    // self.is_quorum_voters_reached()
    // and self.is_weighted_quorum_votes_reached()
    // and self.has_majority_approved()
    bz scrutiny_bool_false@15
    // smart_contracts/proposal/contract.py:576
    // and self.has_majority_approved()
    callsub has_majority_approved
    // smart_contracts/proposal/contract.py:574-576
    // self.is_quorum_voters_reached()
    // and self.is_weighted_quorum_votes_reached()
    // and self.has_majority_approved()
    bz scrutiny_bool_false@15
    intc_1 // 1
    bury 1

scrutiny_bool_merge@16:
    // smart_contracts/proposal/contract.py:928
    // if is_approved:
    dup
    bz scrutiny_else_body@3
    // smart_contracts/proposal/contract.py:929
    // self.status.value = UInt64(enm.STATUS_APPROVED)
    bytec_0 // 0x737461747573
    pushint 30 // 30
    app_global_put

scrutiny_after_if_else@4:
    // smart_contracts/proposal/contract.py:938
    // approved=arc4.Bool(is_approved),
    bytec 5 // 0x00
    intc_0 // 0
    dig 2
    setbit
    // smart_contracts/proposal/contract.py:939
    // plebiscite=arc4.Bool(self.is_plebiscite()),
    callsub is_plebiscite
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:937-940
    // typ.Scrutiny(
    //     approved=arc4.Bool(is_approved),
    //     plebiscite=arc4.Bool(self.is_plebiscite()),
    // )
    intc_0 // 0
    getbit
    intc_1 // 1
    swap
    setbit
    // smart_contracts/proposal/contract.py:936-941
    // arc4.emit(
    //     typ.Scrutiny(
    //         approved=arc4.Bool(is_approved),
    //         plebiscite=arc4.Bool(self.is_plebiscite()),
    //     )
    // )
    pushbytes 0x2bd99ae4 // method "Scrutiny(bool,bool)"
    swap
    concat
    log
    // smart_contracts/proposal/contract.py:911
    // @arc4.abimethod()
    intc_1 // 1
    return

scrutiny_else_body@3:
    // smart_contracts/proposal/contract.py:931
    // self.status.value = UInt64(enm.STATUS_REJECTED)
    bytec_0 // 0x737461747573
    pushint 40 // 40
    app_global_put
    // smart_contracts/proposal/contract.py:933
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:932-934
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    b scrutiny_after_if_else@4

scrutiny_bool_false@15:
    intc_0 // 0
    bury 1
    b scrutiny_bool_merge@16

scrutiny_bool_false@8:
    intc_0 // 0
    b scrutiny_bool_merge@9


// smart_contracts.proposal.contract.Proposal.review[routing]() -> void:
review:
    // smart_contracts/proposal/contract.py:943
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    // smart_contracts/proposal/contract.py:495
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:496
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    pushbytes 0x78676f765f636f756e63696c
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:495-497
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    // )
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    ==
    // smart_contracts/proposal/contract.py:214
    // assert self.is_council(), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:215
    // assert self.status.value == enm.STATUS_APPROVED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 30 // 30
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:959-960
    // # check no assigned voters
    // assert self.assigned_members.value == 0, err.VOTERS_ASSIGNED
    intc_0 // 0
    bytec 7 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    !
    assert // There are voters assigned to this proposal
    // smart_contracts/proposal/contract.py:962
    // if block:
    bz review_else_body@3
    // smart_contracts/proposal/contract.py:963
    // self.status.value = UInt64(enm.STATUS_BLOCKED)
    bytec_0 // 0x737461747573
    pushint 60 // 60
    app_global_put
    // smart_contracts/proposal/contract.py:965-966
    // # slashing: send locked amount to the registry treasury
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:968
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:967-969
    // self.transfer_locked_amount(
    //     receiver=reg_app.address,
    // )
    callsub transfer_locked_amount

review_after_if_else@4:
    // smart_contracts/proposal/contract.py:979
    // arc4.emit(typ.Review(veto=arc4.Bool(block)))
    pushbytes 0xd9939644 // method "Review(bool)"
    dig 1
    concat
    log
    // smart_contracts/proposal/contract.py:943
    // @arc4.abimethod()
    intc_1 // 1
    return

review_else_body@3:
    // smart_contracts/proposal/contract.py:972
    // self.status.value = UInt64(enm.STATUS_REVIEWED)
    bytec_0 // 0x737461747573
    pushint 45 // 45
    app_global_put
    // smart_contracts/proposal/contract.py:976
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:974-977
    // # refund the locked amount to the proposer
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    b review_after_if_else@4


// smart_contracts.proposal.contract.Proposal.fund[routing]() -> void:
fund:
    intc_0 // 0
    dup
    // smart_contracts/proposal/contract.py:219
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:220
    // if self.status.value != enm.STATUS_REVIEWED:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 45 // 45
    !=
    bz fund_after_if_else@7
    // smart_contracts/proposal/contract.py:221
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 30 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    bury 1

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@8:
    // smart_contracts/proposal/contract.py:991
    // if error != typ.Error(""):
    bytec_1 // 0x0000
    bury 2
    dup
    bytec_1 // 0x0000
    !=
    bz fund_after_if_else@3
    dup

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund@4:
    // smart_contracts/proposal/contract.py:981
    // @arc4.abimethod()
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

fund_after_if_else@3:
    // smart_contracts/proposal/contract.py:994
    // self.status.value = UInt64(enm.STATUS_FUNDED)
    bytec_0 // 0x737461747573
    pushint 50 // 50
    app_global_put
    dig 1
    // smart_contracts/proposal/contract.py:981
    // @arc4.abimethod()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund@4

fund_after_if_else@7:
    // smart_contracts/proposal/contract.py:223
    // return typ.Error("")
    bytec_1 // 0x0000
    bury 1
    // smart_contracts/proposal/contract.py:990
    // error = self.fund_check_authorization()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@8


// smart_contracts.proposal.contract.Proposal.unassign_voters[routing]() -> void:
unassign_voters:
    intc_0 // 0
    dup
    pushbytes ""
    dupn 2
    // smart_contracts/proposal/contract.py:998
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.static_array<arc4.uint8, 32>>
    // smart_contracts/proposal/contract.py:227
    // if self.status.value == enm.STATUS_SUBMITTED:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 20 // 20
    ==
    bz unassign_voters_else_body@17
    // smart_contracts/proposal/contract.py:228
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized

unassign_voters_after_if_else@23:
    // smart_contracts/proposal/contract.py:1014
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz unassign_voters_else_body@7
    // smart_contracts/proposal/contract.py:1015-1016
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    bury 3
    intc_1 // 1
    bury 5

unassign_voters_for_header@3:
    // smart_contracts/proposal/contract.py:1015-1016
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    dig 4
    dig 3
    <
    bz unassign_voters_after_if_else@8
    // smart_contracts/proposal/contract.py:1017
    // self.assert_same_app_and_method(i)
    dig 4
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:1015-1016
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    bury 5
    b unassign_voters_for_header@3

unassign_voters_after_if_else@8:
    intc_0 // 0
    bury 4

unassign_voters_for_header@9:
    // smart_contracts/proposal/contract.py:1022-1023
    // # remove voters
    // for voter in voters:
    dig 3
    dig 1
    <
    bz unassign_voters_after_for@14
    dig 1
    extract 2 0
    dig 4
    intc_2 // 32
    *
    intc_2 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 7
    // smart_contracts/proposal/contract.py:1024
    // if voter.native in self.voters:
    bytec 21 // "V"
    swap
    concat
    dup
    bury 8
    box_len
    bury 1
    bz unassign_voters_after_if_else@12
    // smart_contracts/proposal/contract.py:1025
    // votes = self.voters[voter.native]
    dig 6
    box_get
    assert // check self.voters entry exists
    btoi
    // smart_contracts/proposal/contract.py:1026
    // self._unassign_voter(voter.native, votes)
    dig 6
    swap
    callsub _unassign_voter

unassign_voters_after_if_else@12:
    dig 3
    intc_1 // 1
    +
    bury 4
    b unassign_voters_for_header@9

unassign_voters_after_for@14:
    // smart_contracts/proposal/contract.py:998
    // @arc4.abimethod()
    intc_1 // 1
    return

unassign_voters_else_body@7:
    // smart_contracts/proposal/contract.py:1019-1020
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b unassign_voters_after_if_else@8

unassign_voters_else_body@17:
    // smart_contracts/proposal/contract.py:231
    // self.status.value == enm.STATUS_APPROVED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 30 // 30
    ==
    // smart_contracts/proposal/contract.py:231-232
    // self.status.value == enm.STATUS_APPROVED
    // or self.status.value == enm.STATUS_REJECTED
    bnz unassign_voters_and_contd@19
    // smart_contracts/proposal/contract.py:232
    // or self.status.value == enm.STATUS_REJECTED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    ==
    // smart_contracts/proposal/contract.py:231-232
    // self.status.value == enm.STATUS_APPROVED
    // or self.status.value == enm.STATUS_REJECTED
    bz unassign_voters_bool_false@21

unassign_voters_and_contd@19:
    // smart_contracts/proposal/contract.py:233
    // ) and not self.finalized.value, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz unassign_voters_bool_false@21
    intc_1 // 1

unassign_voters_bool_merge@22:
    // smart_contracts/proposal/contract.py:230-233
    // assert (
    //     self.status.value == enm.STATUS_APPROVED
    //     or self.status.value == enm.STATUS_REJECTED
    // ) and not self.finalized.value, err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    b unassign_voters_after_if_else@23

unassign_voters_bool_false@21:
    intc_0 // 0
    b unassign_voters_bool_merge@22


// smart_contracts.proposal.contract.Proposal.finalize[routing]() -> void:
finalize:
    intc_0 // 0
    dup
    // smart_contracts/proposal/contract.py:237
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:239
    // if self.finalized.value or (
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    // smart_contracts/proposal/contract.py:239-245
    // if self.finalized.value or (
    //     self.status.value != enm.STATUS_EMPTY
    //     and self.status.value != enm.STATUS_DRAFT
    //     and self.status.value != enm.STATUS_FUNDED
    //     and self.status.value != enm.STATUS_BLOCKED
    //     and self.status.value != enm.STATUS_REJECTED
    // ):
    bnz finalize_if_body@15
    // smart_contracts/proposal/contract.py:240
    // self.status.value != enm.STATUS_EMPTY
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    // smart_contracts/proposal/contract.py:240-244
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:241
    // and self.status.value != enm.STATUS_DRAFT
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 10
    !=
    // smart_contracts/proposal/contract.py:240-244
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:242
    // and self.status.value != enm.STATUS_FUNDED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    !=
    // smart_contracts/proposal/contract.py:240-244
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:243
    // and self.status.value != enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    !=
    // smart_contracts/proposal/contract.py:240-244
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16
    // smart_contracts/proposal/contract.py:244
    // and self.status.value != enm.STATUS_REJECTED
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    !=
    // smart_contracts/proposal/contract.py:240-244
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@16

finalize_if_body@15:
    // smart_contracts/proposal/contract.py:246
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 30 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    bury 1

finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize_check_authorization@17:
    // smart_contracts/proposal/contract.py:1040
    // if error != typ.Error(""):
    bytec_1 // 0x0000
    bury 2
    dup
    bytec_1 // 0x0000
    !=
    bz finalize_after_if_else@3
    dup

finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8:
    // smart_contracts/proposal/contract.py:1028
    // @arc4.abimethod()
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

finalize_after_if_else@3:
    // smart_contracts/proposal/contract.py:1043-1044
    // # check no assigned voters
    // if self.assigned_members.value > 0:
    intc_0 // 0
    bytec 7 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    bz finalize_after_if_else@5
    // smart_contracts/proposal/contract.py:1045
    // return typ.Error(err.ARC_65_PREFIX + err.VOTERS_ASSIGNED)
    pushbytes 0x002e4552523a54686572652061726520766f746572732061737369676e656420746f20746869732070726f706f73616c
    // smart_contracts/proposal/contract.py:1028
    // @arc4.abimethod()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8

finalize_after_if_else@5:
    // smart_contracts/proposal/contract.py:1047-1050
    // # refund the locked amount for DRAFT proposals
    // # for REJECTED proposals, the locked amount is already refunded in the scrutiny method
    // # for EMPTY, FUNDED, or BLOCKED proposals, the locked amount is not refundable
    // if self.status.value == enm.STATUS_DRAFT:
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 10
    ==
    bz finalize_after_if_else@7
    // smart_contracts/proposal/contract.py:1052
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:1051-1053
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount

finalize_after_if_else@7:
    // smart_contracts/proposal/contract.py:1054
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:1056
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:1057
    // amount=Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:1058
    // - Global.current_application_address.min_balance,
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:1057-1058
    // amount=Global.current_application_address.balance
    // - Global.current_application_address.min_balance,
    -
    // smart_contracts/proposal/contract.py:1055-1059
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance
    //     - Global.current_application_address.min_balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:1060
    // self.finalized.value = True
    bytec_2 // 0x66696e616c697a6564
    intc_1 // 1
    app_global_put
    dig 1
    // smart_contracts/proposal/contract.py:1028
    // @arc4.abimethod()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize@8

finalize_after_if_else@16:
    // smart_contracts/proposal/contract.py:248
    // return typ.Error("")
    bytec_1 // 0x0000
    bury 1
    // smart_contracts/proposal/contract.py:1039
    // error = self.finalize_check_authorization()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize_check_authorization@17


// smart_contracts.proposal.contract.Proposal.delete[routing]() -> void:
delete:
    // smart_contracts/proposal/contract.py:252
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:253
    // assert self.finalized.value, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:1076-1077
    // # delete metadata box if it exists
    // del self.metadata.value
    bytec 12 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:1079
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:1081
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:1082
    // amount=Global.current_application_address.balance,
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:1080-1083
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:1064
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.get_state[routing]() -> void:
get_state:
    // smart_contracts/proposal/contract.py:1094
    // proposer=arc4.Address(self.proposer.value),
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:1095
    // registry_app_id=arc4.UInt64(self.registry_app_id.value),
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    itob
    // smart_contracts/proposal/contract.py:1096
    // title=arc4.String(self.title.value),
    intc_0 // 0
    bytec 33 // 0x7469746c65
    app_global_get_ex
    assert // check self.title exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/proposal/contract.py:1097
    // open_ts=arc4.UInt64(self.open_ts.value),
    intc_0 // 0
    bytec 24 // 0x6f70656e5f74696d657374616d70
    app_global_get_ex
    assert // check self.open_ts exists
    itob
    // smart_contracts/proposal/contract.py:1098
    // submission_ts=arc4.UInt64(self.submission_ts.value),
    intc_0 // 0
    bytec 31 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    itob
    // smart_contracts/proposal/contract.py:1099
    // vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    intc_0 // 0
    bytec 25 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    itob
    // smart_contracts/proposal/contract.py:1100
    // status=arc4.UInt64(self.status.value),
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    itob
    // smart_contracts/proposal/contract.py:1101
    // finalized=arc4.Bool(self.finalized.value),
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:1102
    // funding_category=arc4.UInt64(self.funding_category.value),
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    assert // check self.funding_category exists
    itob
    // smart_contracts/proposal/contract.py:1103
    // focus=arc4.UInt8(self.focus.value),
    intc_0 // 0
    bytec 34 // 0x666f637573
    app_global_get_ex
    assert // check self.focus exists
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:1104
    // funding_type=arc4.UInt64(self.funding_type.value),
    intc_0 // 0
    bytec 26 // 0x66756e64696e675f74797065
    app_global_get_ex
    assert // check self.funding_type exists
    itob
    // smart_contracts/proposal/contract.py:1105
    // requested_amount=arc4.UInt64(self.requested_amount.value),
    intc_0 // 0
    bytec 27 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    itob
    // smart_contracts/proposal/contract.py:1106
    // locked_amount=arc4.UInt64(self.locked_amount.value),
    intc_0 // 0
    bytec 18 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    itob
    // smart_contracts/proposal/contract.py:1107
    // committee_id=self.committee_id.value.copy(),
    intc_0 // 0
    bytec 17 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    // smart_contracts/proposal/contract.py:1108
    // committee_members=arc4.UInt64(self.committee_members.value),
    intc_0 // 0
    bytec 13 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    itob
    // smart_contracts/proposal/contract.py:1109
    // committee_votes=arc4.UInt64(self.committee_votes.value),
    intc_0 // 0
    bytec 15 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    itob
    // smart_contracts/proposal/contract.py:1110
    // voted_members=arc4.UInt64(self.voted_members.value),
    intc_0 // 0
    bytec 8 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    // smart_contracts/proposal/contract.py:1111
    // approvals=arc4.UInt64(self.approvals.value),
    intc_0 // 0
    bytec 9 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    // smart_contracts/proposal/contract.py:1112
    // rejections=arc4.UInt64(self.rejections.value),
    intc_0 // 0
    bytec 10 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    // smart_contracts/proposal/contract.py:1113
    // nulls=arc4.UInt64(self.nulls.value),
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    // smart_contracts/proposal/contract.py:1093-1114
    // return typ.ProposalTypedGlobalState(
    //     proposer=arc4.Address(self.proposer.value),
    //     registry_app_id=arc4.UInt64(self.registry_app_id.value),
    //     title=arc4.String(self.title.value),
    //     open_ts=arc4.UInt64(self.open_ts.value),
    //     submission_ts=arc4.UInt64(self.submission_ts.value),
    //     vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    //     status=arc4.UInt64(self.status.value),
    //     finalized=arc4.Bool(self.finalized.value),
    //     funding_category=arc4.UInt64(self.funding_category.value),
    //     focus=arc4.UInt8(self.focus.value),
    //     funding_type=arc4.UInt64(self.funding_type.value),
    //     requested_amount=arc4.UInt64(self.requested_amount.value),
    //     locked_amount=arc4.UInt64(self.locked_amount.value),
    //     committee_id=self.committee_id.value.copy(),
    //     committee_members=arc4.UInt64(self.committee_members.value),
    //     committee_votes=arc4.UInt64(self.committee_votes.value),
    //     voted_members=arc4.UInt64(self.voted_members.value),
    //     approvals=arc4.UInt64(self.approvals.value),
    //     rejections=arc4.UInt64(self.rejections.value),
    //     nulls=arc4.UInt64(self.nulls.value),
    // )
    uncover 19
    uncover 19
    concat
    pushbytes 0x00bc
    concat
    uncover 17
    concat
    uncover 16
    concat
    uncover 15
    concat
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/proposal/contract.py:1085
    // @arc4.abimethod(readonly=True)
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.get_voter_box[routing]() -> void:
get_voter_box:
    // smart_contracts/proposal/contract.py:1116
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/proposal/contract.py:1128
    // exists = voter_address.native in self.voters
    bytec 21 // "V"
    swap
    concat
    dup
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/proposal/contract.py:1129
    // if exists:
    bz get_voter_box_else_body@3
    // smart_contracts/proposal/contract.py:1130
    // votes = self.voters[voter_address.native]
    dig 1
    box_get
    assert // check self.voters entry exists
    btoi

get_voter_box_after_if_else@4:
    // smart_contracts/proposal/contract.py:1134
    // return arc4.UInt64(votes), exists
    itob
    // smart_contracts/proposal/contract.py:1116
    // @arc4.abimethod(readonly=True)
    bytec 5 // 0x00
    intc_0 // 0
    dig 3
    setbit
    concat
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_voter_box_else_body@3:
    // smart_contracts/proposal/contract.py:1132
    // votes = UInt64(0)
    intc_0 // 0
    b get_voter_box_after_if_else@4


// smart_contracts.proposal.contract.Proposal.get_voting_state[routing]() -> void:
get_voting_state:
    // smart_contracts/proposal/contract.py:1155
    // quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    intc_0 // 0
    bytec 19 // 0x71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.quorum_threshold exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1156
    // weighted_quorum_votes=arc4.UInt32(self.weighted_quorum_threshold.value),
    intc_0 // 0
    bytec 20 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.weighted_quorum_threshold exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1157
    // total_voters=arc4.UInt32(self.voted_members.value),
    intc_0 // 0
    bytec 8 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1158
    // total_approvals=arc4.UInt32(self.approvals.value),
    intc_0 // 0
    bytec 9 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1159
    // total_rejections=arc4.UInt32(self.rejections.value),
    intc_0 // 0
    bytec 10 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1160
    // total_nulls=arc4.UInt32(self.nulls.value),
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    // smart_contracts/proposal/contract.py:1161
    // quorum_reached=arc4.Bool(self.is_quorum_voters_reached()),
    callsub is_quorum_voters_reached
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:1162
    // weighted_quorum_reached=arc4.Bool(self.is_weighted_quorum_votes_reached()),
    callsub is_weighted_quorum_votes_reached
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:1163
    // majority_approved=arc4.Bool(self.has_majority_approved()),
    callsub has_majority_approved
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:1164
    // plebiscite=arc4.Bool(self.is_plebiscite()),
    callsub is_plebiscite
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:1154-1165
    // return typ.VotingState(
    //     quorum_voters=arc4.UInt32(self.quorum_threshold.value),
    //     weighted_quorum_votes=arc4.UInt32(self.weighted_quorum_threshold.value),
    //     total_voters=arc4.UInt32(self.voted_members.value),
    //     total_approvals=arc4.UInt32(self.approvals.value),
    //     total_rejections=arc4.UInt32(self.rejections.value),
    //     total_nulls=arc4.UInt32(self.nulls.value),
    //     quorum_reached=arc4.Bool(self.is_quorum_voters_reached()),
    //     weighted_quorum_reached=arc4.Bool(self.is_weighted_quorum_votes_reached()),
    //     majority_approved=arc4.Bool(self.has_majority_approved()),
    //     plebiscite=arc4.Bool(self.is_plebiscite()),
    // )
    uncover 9
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 3
    intc_0 // 0
    getbit
    uncover 4
    intc_1 // 1
    uncover 2
    setbit
    uncover 3
    intc_0 // 0
    getbit
    pushint 2 // 2
    swap
    setbit
    uncover 2
    intc_0 // 0
    getbit
    pushint 3 // 3
    swap
    setbit
    concat
    // smart_contracts/proposal/contract.py:1136
    // @arc4.abimethod(readonly=True)
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.get_uint_from_registry_config(global_state_key: bytes) -> uint64:
get_uint_from_registry_config:
    // smart_contracts/proposal/contract.py:191-192
    // @subroutine
    // def get_uint_from_registry_config(self, global_state_key: Bytes) -> UInt64:
    proto 1 1
    // smart_contracts/proposal/contract.py:194
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:193-195
    // value, exists = AppGlobal.get_ex_uint64(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:196
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:197
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.get_bytes_from_registry_config(global_state_key: bytes) -> bytes:
get_bytes_from_registry_config:
    // smart_contracts/proposal/contract.py:199-200
    // @subroutine
    // def get_bytes_from_registry_config(self, global_state_key: Bytes) -> Bytes:
    proto 1 1
    // smart_contracts/proposal/contract.py:202
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:201-203
    // value, exists = AppGlobal.get_ex_bytes(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:204
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:205
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.is_voting_open() -> uint64:
is_voting_open:
    // smart_contracts/proposal/contract.py:209
    // elapsed_voting_duration = Global.latest_timestamp - self.vote_open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 25 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    -
    // smart_contracts/proposal/contract.py:210
    // return elapsed_voting_duration <= self.voting_duration.value
    intc_0 // 0
    bytec 28 // 0x766f74696e675f6475726174696f6e
    app_global_get_ex
    assert // check self.voting_duration exists
    <=
    retsub


// smart_contracts.proposal.contract.Proposal.is_plebiscite() -> uint64:
is_plebiscite:
    // smart_contracts/proposal/contract.py:283
    // return self.voted_members.value == self.committee_members.value
    intc_0 // 0
    bytec 8 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_0 // 0
    bytec 13 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.assert_draft_and_proposer() -> void:
assert_draft_and_proposer:
    // smart_contracts/proposal/contract.py:371
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:373
    // self.status.value == enm.STATUS_DRAFT and not self.finalized.value
    intc_0 // 0
    bytec_0 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 10
    ==
    bz assert_draft_and_proposer_bool_false@3
    intc_0 // 0
    bytec_2 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz assert_draft_and_proposer_bool_false@3
    intc_1 // 1

assert_draft_and_proposer_bool_merge@4:
    // smart_contracts/proposal/contract.py:372-374
    // assert (
    //     self.status.value == enm.STATUS_DRAFT and not self.finalized.value
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    retsub

assert_draft_and_proposer_bool_false@3:
    intc_0 // 0
    b assert_draft_and_proposer_bool_merge@4


// smart_contracts.proposal.contract.Proposal.is_proposer() -> uint64:
is_proposer:
    // smart_contracts/proposal/contract.py:491
    // return Txn.sender == self.proposer.value
    txn Sender
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_xgov_daemon() -> uint64:
is_xgov_daemon:
    // smart_contracts/proposal/contract.py:501
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:502
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    bytec 36 // 0x78676f765f6461656d6f6e
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:501-503
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    // )
    dup
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_registry_call() -> uint64:
is_registry_call:
    // smart_contracts/proposal/contract.py:507
    // return Global.caller_application_id == self.registry_app_id.value
    global CallerApplicationID
    intc_0 // 0
    bytec 4 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.pay(receiver: bytes, amount: uint64) -> void:
pay:
    // smart_contracts/proposal/contract.py:509-510
    // @subroutine
    // def pay(self, receiver: Account, amount: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:511-515
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_begin
    frame_dig -1
    itxn_field Amount
    frame_dig -2
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:511
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:514
    // fee=UInt64(0),  # enforces the sender to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:511-515
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.proposal.contract.Proposal.transfer_locked_amount(receiver: bytes) -> void:
transfer_locked_amount:
    // smart_contracts/proposal/contract.py:517-518
    // @subroutine
    // def transfer_locked_amount(self, receiver: Account) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:519
    // self.pay(receiver, self.locked_amount.value)
    intc_0 // 0
    bytec 18 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    frame_dig -1
    swap
    callsub pay
    // smart_contracts/proposal/contract.py:520
    // self.locked_amount.value = UInt64(0)
    bytec 18 // 0x6c6f636b65645f616d6f756e74
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.assert_same_app_and_method(group_index: uint64) -> void:
assert_same_app_and_method:
    // smart_contracts/proposal/contract.py:522-523
    // @subroutine
    // def assert_same_app_and_method(self, group_index: UInt64) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:525
    // GTxn.application_id(group_index) == Global.current_application_id
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/proposal/contract.py:524-526
    // assert (
    //     GTxn.application_id(group_index) == Global.current_application_id
    // ), err.WRONG_APP_ID
    assert // Wrong App ID
    // smart_contracts/proposal/contract.py:527
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    frame_dig -1
    gtxnsa ApplicationArgs 0
    // smart_contracts/proposal/contract.py:527-529
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    //     0
    // ), err.WRONG_METHOD_CALL
    txna ApplicationArgs 0
    ==
    assert // Wrong Method Call
    retsub


// smart_contracts.proposal.contract.Proposal.is_quorum_voters_reached() -> uint64:
is_quorum_voters_reached:
    // smart_contracts/proposal/contract.py:547-549
    // # A category dependent quorum of all xGov Voting Committee (1 xGov, 1 vote) is reached.
    // # Null votes affect this quorum.
    // quorum_defined = self.quorum_threshold.value > 0
    intc_0 // 0
    bytec 19 // 0x71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.quorum_threshold exists
    // smart_contracts/proposal/contract.py:551
    // self.voted_members.value >= self.quorum_threshold.value and quorum_defined
    intc_0 // 0
    bytec 8 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    dig 1
    >=
    &&
    // smart_contracts/proposal/contract.py:550-552
    // return (
    //     self.voted_members.value >= self.quorum_threshold.value and quorum_defined
    // )
    retsub


// smart_contracts.proposal.contract.Proposal.is_weighted_quorum_votes_reached() -> uint64:
is_weighted_quorum_votes_reached:
    // smart_contracts/proposal/contract.py:556-558
    // # A category dependent weighted quorum of all xGov Voting Committee voting power (1 vote) is reached.
    // # Null votes affect this quorum.
    // weighted_quorum_defined = self.weighted_quorum_threshold.value > 0
    intc_0 // 0
    bytec 20 // 0x77656967687465645f71756f72756d5f7468726573686f6c64
    app_global_get_ex
    assert // check self.weighted_quorum_threshold exists
    // smart_contracts/proposal/contract.py:559
    // total_votes = self.approvals.value + self.rejections.value + self.nulls.value
    intc_0 // 0
    bytec 9 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 10 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    +
    intc_0 // 0
    bytec 14 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    // smart_contracts/proposal/contract.py:561
    // total_votes >= self.weighted_quorum_threshold.value
    dig 1
    >=
    // smart_contracts/proposal/contract.py:561-562
    // total_votes >= self.weighted_quorum_threshold.value
    // and weighted_quorum_defined
    &&
    // smart_contracts/proposal/contract.py:560-563
    // return (
    //     total_votes >= self.weighted_quorum_threshold.value
    //     and weighted_quorum_defined
    // )
    retsub


// smart_contracts.proposal.contract.Proposal.has_majority_approved() -> uint64:
has_majority_approved:
    // smart_contracts/proposal/contract.py:567-569
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // return self.approvals.value > self.rejections.value
    intc_0 // 0
    bytec 9 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 10 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    >
    retsub


// smart_contracts.proposal.contract.Proposal._unassign_voter(voter: bytes, voting_power: uint64) -> void:
_unassign_voter:
    // smart_contracts/proposal/contract.py:792-793
    // @subroutine
    // def _unassign_voter(self, voter: Account, voting_power: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:794
    // self.assigned_members.value -= 1
    intc_0 // 0
    bytec 7 // 0x61737369676e65645f6d656d62657273
    app_global_get_ex
    assert // check self.assigned_members exists
    intc_1 // 1
    -
    bytec 7 // 0x61737369676e65645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:795
    // self.assigned_votes.value -= voting_power
    intc_0 // 0
    bytec 16 // 0x61737369676e65645f766f746573
    app_global_get_ex
    assert // check self.assigned_votes exists
    frame_dig -1
    -
    bytec 16 // 0x61737369676e65645f766f746573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:796
    // del self.voters[voter]
    bytec 21 // "V"
    frame_dig -2
    concat
    box_del
    pop
    retsub
